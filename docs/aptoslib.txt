Directory structure:
└── aptos-stdlib/
    ├── Move.toml
    ├── doc/
    │   ├── any.md
    │   ├── big_vector.md
    │   ├── bls12381.md
    │   ├── bls12381_algebra.md
    │   ├── bn254_algebra.md
    │   ├── capability.md
    │   ├── comparator.md
    │   ├── copyable_any.md
    │   ├── crypto_algebra.md
    │   ├── debug.md
    │   ├── ed25519.md
    │   ├── fixed_point64.md
    │   ├── from_bcs.md
    │   ├── hash.md
    │   ├── math128.md
    │   ├── math64.md
    │   ├── math_fixed.md
    │   ├── math_fixed64.md
    │   ├── multi_ed25519.md
    │   ├── overview.md
    │   ├── pool_u64.md
    │   ├── pool_u64_unbound.md
    │   ├── ristretto255.md
    │   ├── ristretto255_bulletproofs.md
    │   ├── ristretto255_elgamal.md
    │   ├── ristretto255_pedersen.md
    │   ├── secp256k1.md
    │   ├── simple_map.md
    │   ├── smart_table.md
    │   ├── smart_vector.md
    │   ├── string_utils.md
    │   ├── table.md
    │   ├── table_with_length.md
    │   └── type_info.md
    ├── doc_template/
    │   ├── overview.md
    │   └── references.md
    ├── sources/
    │   ├── any.move
    │   ├── any.spec.move
    │   ├── capability.move
    │   ├── capability.spec.move
    │   ├── comparator.move
    │   ├── comparator.spec.move
    │   ├── copyable_any.move
    │   ├── copyable_any.spec.move
    │   ├── debug.move
    │   ├── debug.spec.move
    │   ├── fixed_point64.move
    │   ├── from_bcs.move
    │   ├── from_bcs.spec.move
    │   ├── hash.move
    │   ├── hash.spec.move
    │   ├── math128.move
    │   ├── math128.spec.move
    │   ├── math64.move
    │   ├── math64.spec.move
    │   ├── math_fixed.move
    │   ├── math_fixed64.move
    │   ├── pool_u64.move
    │   ├── pool_u64.spec.move
    │   ├── pool_u64_unbound.move
    │   ├── pool_u64_unbound.spec.move
    │   ├── simple_map.move
    │   ├── simple_map.spec.move
    │   ├── string_utils.move
    │   ├── string_utils.spec.move
    │   ├── table.move
    │   ├── table.spec.move
    │   ├── table_with_length.move
    │   ├── table_with_length.spec.move
    │   ├── type_info.move
    │   ├── type_info.spec.move
    │   ├── cryptography/
    │   │   ├── bls12381.move
    │   │   ├── bls12381.spec.move
    │   │   ├── bls12381_algebra.move
    │   │   ├── bn254_algebra.move
    │   │   ├── crypto_algebra.move
    │   │   ├── crypto_algebra.spec.move
    │   │   ├── ed25519.move
    │   │   ├── ed25519.spec.move
    │   │   ├── multi_ed25519.move
    │   │   ├── multi_ed25519.spec.move
    │   │   ├── ristretto255.move
    │   │   ├── ristretto255.spec.move
    │   │   ├── ristretto255_bulletproofs.move
    │   │   ├── ristretto255_bulletproofs.spec.move
    │   │   ├── ristretto255_elgamal.move
    │   │   ├── ristretto255_elgamal.spec.move
    │   │   ├── ristretto255_pedersen.move
    │   │   ├── ristretto255_pedersen.spec.move
    │   │   ├── secp256k1.move
    │   │   └── secp256k1.spec.move
    │   └── data_structures/
    │       ├── big_vector.move
    │       ├── big_vector.spec.move
    │       ├── smart_table.move
    │       ├── smart_table.spec.move
    │       ├── smart_vector.move
    │       ├── smart_vector.spec.move
    │       └── tests/
    │           ├── smart_table_test.move
    │           └── smart_vector_test.move
    └── tests/
        ├── fixedpoint64_tests.move
        └── math64_tests.move

================================================
File: aptos-move/framework/aptos-stdlib/Move.toml
================================================
[package]
name = "AptosStdlib"
version = "1.0.0"

[addresses]
std = "0x1"
aptos_std = "0x1"
supra_framework = "0x1"
Extensions = "0x1" # For Prover to instantiate `{{Ext}}` in prelude.

[dependencies]
MoveStdlib = { local = "../move-stdlib" }


================================================
File: aptos-move/framework/aptos-stdlib/doc/any.md
================================================

<a id="0x1_any"></a>

# Module `0x1::any`



-  [Struct `Any`](#0x1_any_Any)
-  [Constants](#@Constants_0)
-  [Function `pack`](#0x1_any_pack)
-  [Function `unpack`](#0x1_any_unpack)
-  [Function `type_name`](#0x1_any_type_name)
-  [Specification](#@Specification_1)
    -  [Function `pack`](#@Specification_1_pack)
    -  [Function `unpack`](#@Specification_1_unpack)
    -  [Function `type_name`](#@Specification_1_type_name)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/bcs.md#0x1_bcs">0x1::bcs</a>;
<b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="from_bcs.md#0x1_from_bcs">0x1::from_bcs</a>;
<b>use</b> <a href="../../move-stdlib/doc/string.md#0x1_string">0x1::string</a>;
<b>use</b> <a href="type_info.md#0x1_type_info">0x1::type_info</a>;
</code></pre>



<a id="0x1_any_Any"></a>

## Struct `Any`

A type which can represent a value of any type. This allows for representation of 'unknown' future
values. For example, to define a resource such that it can be later be extended without breaking
changes one can do

```move
struct Resource {
field: Type,
...
extension: Option<Any>
}
```


<pre><code><b>struct</b> <a href="any.md#0x1_any_Any">Any</a> <b>has</b> drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>type_name: <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a></code>
</dt>
<dd>

</dd>
<dt>
<code>data: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_any_ETYPE_MISMATCH"></a>

The type provided for <code>unpack</code> is not the same as was given for <code>pack</code>.


<pre><code><b>const</b> <a href="any.md#0x1_any_ETYPE_MISMATCH">ETYPE_MISMATCH</a>: u64 = 1;
</code></pre>



<a id="0x1_any_pack"></a>

## Function `pack`

Pack a value into the <code><a href="any.md#0x1_any_Any">Any</a></code> representation. Because Any can be stored and dropped, this is
also required from <code>T</code>.


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_pack">pack</a>&lt;T: drop, store&gt;(x: T): <a href="any.md#0x1_any_Any">any::Any</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_pack">pack</a>&lt;T: drop + store&gt;(x: T): <a href="any.md#0x1_any_Any">Any</a> {
    <a href="any.md#0x1_any_Any">Any</a> {
        type_name: <a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;(),
        data: to_bytes(&x)
    }
}
</code></pre>



</details>

<a id="0x1_any_unpack"></a>

## Function `unpack`

Unpack a value from the <code><a href="any.md#0x1_any_Any">Any</a></code> representation. This aborts if the value has not the expected type <code>T</code>.


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_unpack">unpack</a>&lt;T&gt;(x: <a href="any.md#0x1_any_Any">any::Any</a>): T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_unpack">unpack</a>&lt;T&gt;(x: <a href="any.md#0x1_any_Any">Any</a>): T {
    <b>assert</b>!(<a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;() == x.type_name, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="any.md#0x1_any_ETYPE_MISMATCH">ETYPE_MISMATCH</a>));
    from_bytes&lt;T&gt;(x.data)
}
</code></pre>



</details>

<a id="0x1_any_type_name"></a>

## Function `type_name`

Returns the type name of this Any


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_type_name">type_name</a>(x: &<a href="any.md#0x1_any_Any">any::Any</a>): &<a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_type_name">type_name</a>(x: &<a href="any.md#0x1_any_Any">Any</a>): &String {
    &x.type_name
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_pack"></a>

### Function `pack`


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_pack">pack</a>&lt;T: drop, store&gt;(x: T): <a href="any.md#0x1_any_Any">any::Any</a>
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="any.md#0x1_any_Any">Any</a> {
    type_name: <a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;(),
    data: <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_serialize">bcs::serialize</a>&lt;T&gt;(x)
};
<b>ensures</b> [abstract] <a href="from_bcs.md#0x1_from_bcs_deserializable">from_bcs::deserializable</a>&lt;T&gt;(result.data);
</code></pre>



<a id="@Specification_1_unpack"></a>

### Function `unpack`


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_unpack">unpack</a>&lt;T&gt;(x: <a href="any.md#0x1_any_Any">any::Any</a>): T
</code></pre>




<pre><code><b>include</b> <a href="any.md#0x1_any_UnpackAbortsIf">UnpackAbortsIf</a>&lt;T&gt;;
<b>ensures</b> result == <a href="from_bcs.md#0x1_from_bcs_deserialize">from_bcs::deserialize</a>&lt;T&gt;(x.data);
</code></pre>




<a id="0x1_any_UnpackAbortsIf"></a>


<pre><code><b>schema</b> <a href="any.md#0x1_any_UnpackAbortsIf">UnpackAbortsIf</a>&lt;T&gt; {
    x: <a href="any.md#0x1_any_Any">Any</a>;
    <b>aborts_if</b> <a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;() != x.type_name;
    <b>aborts_if</b> !<a href="from_bcs.md#0x1_from_bcs_deserializable">from_bcs::deserializable</a>&lt;T&gt;(x.data);
}
</code></pre>




<a id="0x1_any_UnpackRequirement"></a>


<pre><code><b>schema</b> <a href="any.md#0x1_any_UnpackRequirement">UnpackRequirement</a>&lt;T&gt; {
    x: <a href="any.md#0x1_any_Any">Any</a>;
    <b>requires</b> <a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;() == x.type_name;
    <b>requires</b> <a href="from_bcs.md#0x1_from_bcs_deserializable">from_bcs::deserializable</a>&lt;T&gt;(x.data);
}
</code></pre>



<a id="@Specification_1_type_name"></a>

### Function `type_name`


<pre><code><b>public</b> <b>fun</b> <a href="any.md#0x1_any_type_name">type_name</a>(x: &<a href="any.md#0x1_any_Any">any::Any</a>): &<a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == x.type_name;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/big_vector.md
================================================

<a id="0x1_big_vector"></a>

# Module `0x1::big_vector`



-  [Struct `BigVector`](#0x1_big_vector_BigVector)
-  [Constants](#@Constants_0)
-  [Function `empty`](#0x1_big_vector_empty)
-  [Function `singleton`](#0x1_big_vector_singleton)
-  [Function `destroy_empty`](#0x1_big_vector_destroy_empty)
-  [Function `destroy`](#0x1_big_vector_destroy)
-  [Function `borrow`](#0x1_big_vector_borrow)
-  [Function `borrow_mut`](#0x1_big_vector_borrow_mut)
-  [Function `append`](#0x1_big_vector_append)
-  [Function `push_back`](#0x1_big_vector_push_back)
-  [Function `pop_back`](#0x1_big_vector_pop_back)
-  [Function `remove`](#0x1_big_vector_remove)
-  [Function `swap_remove`](#0x1_big_vector_swap_remove)
-  [Function `swap`](#0x1_big_vector_swap)
-  [Function `reverse`](#0x1_big_vector_reverse)
-  [Function `index_of`](#0x1_big_vector_index_of)
-  [Function `contains`](#0x1_big_vector_contains)
-  [Function `to_vector`](#0x1_big_vector_to_vector)
-  [Function `length`](#0x1_big_vector_length)
-  [Function `is_empty`](#0x1_big_vector_is_empty)
-  [Specification](#@Specification_1)
    -  [Struct `BigVector`](#@Specification_1_BigVector)
    -  [Function `empty`](#@Specification_1_empty)
    -  [Function `singleton`](#@Specification_1_singleton)
    -  [Function `destroy_empty`](#@Specification_1_destroy_empty)
    -  [Function `borrow`](#@Specification_1_borrow)
    -  [Function `borrow_mut`](#@Specification_1_borrow_mut)
    -  [Function `append`](#@Specification_1_append)
    -  [Function `push_back`](#@Specification_1_push_back)
    -  [Function `pop_back`](#@Specification_1_pop_back)
    -  [Function `remove`](#@Specification_1_remove)
    -  [Function `swap_remove`](#@Specification_1_swap_remove)
    -  [Function `swap`](#@Specification_1_swap)
    -  [Function `reverse`](#@Specification_1_reverse)
    -  [Function `index_of`](#@Specification_1_index_of)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="table_with_length.md#0x1_table_with_length">0x1::table_with_length</a>;
<b>use</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">0x1::vector</a>;
</code></pre>



<a id="0x1_big_vector_BigVector"></a>

## Struct `BigVector`

A scalable vector implementation based on tables where elements are grouped into buckets.
Each bucket has a capacity of <code>bucket_size</code> elements.


<pre><code><b>struct</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt; <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>buckets: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;u64, <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;T&gt;&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>end_index: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>bucket_size: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_big_vector_EINDEX_OUT_OF_BOUNDS"></a>

Vector index is out of bounds


<pre><code><b>const</b> <a href="big_vector.md#0x1_big_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</a>: u64 = 1;
</code></pre>



<a id="0x1_big_vector_EVECTOR_EMPTY"></a>

Cannot pop back from an empty vector


<pre><code><b>const</b> <a href="big_vector.md#0x1_big_vector_EVECTOR_EMPTY">EVECTOR_EMPTY</a>: u64 = 3;
</code></pre>



<a id="0x1_big_vector_EVECTOR_NOT_EMPTY"></a>

Cannot destroy a non-empty vector


<pre><code><b>const</b> <a href="big_vector.md#0x1_big_vector_EVECTOR_NOT_EMPTY">EVECTOR_NOT_EMPTY</a>: u64 = 2;
</code></pre>



<a id="0x1_big_vector_EZERO_BUCKET_SIZE"></a>

bucket_size cannot be 0


<pre><code><b>const</b> <a href="big_vector.md#0x1_big_vector_EZERO_BUCKET_SIZE">EZERO_BUCKET_SIZE</a>: u64 = 4;
</code></pre>



<a id="0x1_big_vector_empty"></a>

## Function `empty`

Regular Vector API
Create an empty vector.


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="big_vector.md#0x1_big_vector_empty">empty</a>&lt;T: store&gt;(bucket_size: u64): <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="big_vector.md#0x1_big_vector_empty">empty</a>&lt;T: store&gt;(bucket_size: u64): <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt; {
    <b>assert</b>!(bucket_size &gt; 0, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="big_vector.md#0x1_big_vector_EZERO_BUCKET_SIZE">EZERO_BUCKET_SIZE</a>));
    <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a> {
        buckets: <a href="table_with_length.md#0x1_table_with_length_new">table_with_length::new</a>(),
        end_index: 0,
        bucket_size,
    }
}
</code></pre>



</details>

<a id="0x1_big_vector_singleton"></a>

## Function `singleton`

Create a vector of length 1 containing the passed in element.


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="big_vector.md#0x1_big_vector_singleton">singleton</a>&lt;T: store&gt;(element: T, bucket_size: u64): <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="big_vector.md#0x1_big_vector_singleton">singleton</a>&lt;T: store&gt;(element: T, bucket_size: u64): <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt; {
    <b>let</b> v = <a href="big_vector.md#0x1_big_vector_empty">empty</a>(bucket_size);
    <a href="big_vector.md#0x1_big_vector_push_back">push_back</a>(&<b>mut</b> v, element);
    v
}
</code></pre>



</details>

<a id="0x1_big_vector_destroy_empty"></a>

## Function `destroy_empty`

Destroy the vector <code>v</code>.
Aborts if <code>v</code> is not empty.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_destroy_empty">destroy_empty</a>&lt;T&gt;(v: <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_destroy_empty">destroy_empty</a>&lt;T&gt;(v: <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;) {
    <b>assert</b>!(<a href="big_vector.md#0x1_big_vector_is_empty">is_empty</a>(&v), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="big_vector.md#0x1_big_vector_EVECTOR_NOT_EMPTY">EVECTOR_NOT_EMPTY</a>));
    <b>let</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a> { buckets, end_index: _, bucket_size: _ } = v;
    <a href="table_with_length.md#0x1_table_with_length_destroy_empty">table_with_length::destroy_empty</a>(buckets);
}
</code></pre>



</details>

<a id="0x1_big_vector_destroy"></a>

## Function `destroy`

Destroy the vector <code>v</code> if T has <code>drop</code>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_destroy">destroy</a>&lt;T: drop&gt;(v: <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_destroy">destroy</a>&lt;T: drop&gt;(v: <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;) {
    <b>let</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a> { buckets, end_index, bucket_size: _ } = v;
    <b>let</b> i = 0;
    <b>while</b> (end_index &gt; 0) {
        <b>let</b> num_elements = <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&<a href="table_with_length.md#0x1_table_with_length_remove">table_with_length::remove</a>(&<b>mut</b> buckets, i));
        end_index = end_index - num_elements;
        i = i + 1;
    };
    <a href="table_with_length.md#0x1_table_with_length_destroy_empty">table_with_length::destroy_empty</a>(buckets);
}
</code></pre>



</details>

<a id="0x1_big_vector_borrow"></a>

## Function `borrow`

Acquire an immutable reference to the <code>i</code>th element of the vector <code>v</code>.
Aborts if <code>i</code> is out of bounds.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_borrow">borrow</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64): &T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_borrow">borrow</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, i: u64): &T {
    <b>assert</b>!(i &lt; <a href="big_vector.md#0x1_big_vector_length">length</a>(v), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="big_vector.md#0x1_big_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</a>));
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(<a href="table_with_length.md#0x1_table_with_length_borrow">table_with_length::borrow</a>(&v.buckets, i / v.bucket_size), i % v.bucket_size)
}
</code></pre>



</details>

<a id="0x1_big_vector_borrow_mut"></a>

## Function `borrow_mut`

Return a mutable reference to the <code>i</code>th element in the vector <code>v</code>.
Aborts if <code>i</code> is out of bounds.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_borrow_mut">borrow_mut</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64): &<b>mut</b> T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_borrow_mut">borrow_mut</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, i: u64): &<b>mut</b> T {
    <b>assert</b>!(i &lt; <a href="big_vector.md#0x1_big_vector_length">length</a>(v), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="big_vector.md#0x1_big_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</a>));
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow_mut">vector::borrow_mut</a>(<a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, i / v.bucket_size), i % v.bucket_size)
}
</code></pre>



</details>

<a id="0x1_big_vector_append"></a>

## Function `append`

Empty and destroy the other vector, and push each of the elements in the other vector onto the lhs vector in the
same order as they occurred in other.
Disclaimer: This function is costly. Use it at your own discretion.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_append">append</a>&lt;T: store&gt;(lhs: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, other: <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_append">append</a>&lt;T: store&gt;(lhs: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, other: <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;) {
    <b>let</b> other_len = <a href="big_vector.md#0x1_big_vector_length">length</a>(&other);
    <b>let</b> half_other_len = other_len / 2;
    <b>let</b> i = 0;
    <b>while</b> (i &lt; half_other_len) {
        <a href="big_vector.md#0x1_big_vector_push_back">push_back</a>(lhs, <a href="big_vector.md#0x1_big_vector_swap_remove">swap_remove</a>(&<b>mut</b> other, i));
        i = i + 1;
    };
    <b>while</b> (i &lt; other_len) {
        <a href="big_vector.md#0x1_big_vector_push_back">push_back</a>(lhs, <a href="big_vector.md#0x1_big_vector_pop_back">pop_back</a>(&<b>mut</b> other));
        i = i + 1;
    };
    <a href="big_vector.md#0x1_big_vector_destroy_empty">destroy_empty</a>(other);
}
</code></pre>



</details>

<a id="0x1_big_vector_push_back"></a>

## Function `push_back`

Add element <code>val</code> to the end of the vector <code>v</code>. It grows the buckets when the current buckets are full.
This operation will cost more gas when it adds new bucket.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_push_back">push_back</a>&lt;T: store&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, val: T)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_push_back">push_back</a>&lt;T: store&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, val: T) {
    <b>let</b> num_buckets = <a href="table_with_length.md#0x1_table_with_length_length">table_with_length::length</a>(&v.buckets);
    <b>if</b> (v.end_index == num_buckets * v.bucket_size) {
        <a href="table_with_length.md#0x1_table_with_length_add">table_with_length::add</a>(&<b>mut</b> v.buckets, num_buckets, <a href="../../move-stdlib/doc/vector.md#0x1_vector_empty">vector::empty</a>());
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(<a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, num_buckets), val);
    } <b>else</b> {
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(<a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, num_buckets - 1), val);
    };
    v.end_index = v.end_index + 1;
}
</code></pre>



</details>

<a id="0x1_big_vector_pop_back"></a>

## Function `pop_back`

Pop an element from the end of vector <code>v</code>. It doesn't shrink the buckets even if they're empty.
Call <code>shrink_to_fit</code> explicity to deallocate empty buckets.
Aborts if <code>v</code> is empty.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_pop_back">pop_back</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;): T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_pop_back">pop_back</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;): T {
    <b>assert</b>!(!<a href="big_vector.md#0x1_big_vector_is_empty">is_empty</a>(v), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_state">error::invalid_state</a>(<a href="big_vector.md#0x1_big_vector_EVECTOR_EMPTY">EVECTOR_EMPTY</a>));
    <b>let</b> num_buckets = <a href="table_with_length.md#0x1_table_with_length_length">table_with_length::length</a>(&v.buckets);
    <b>let</b> last_bucket = <a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, num_buckets - 1);
    <b>let</b> val = <a href="../../move-stdlib/doc/vector.md#0x1_vector_pop_back">vector::pop_back</a>(last_bucket);
    // Shrink the <a href="table.md#0x1_table">table</a> <b>if</b> the last <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a> is empty.
    <b>if</b> (<a href="../../move-stdlib/doc/vector.md#0x1_vector_is_empty">vector::is_empty</a>(last_bucket)) {
        <b>move</b> last_bucket;
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_destroy_empty">vector::destroy_empty</a>(<a href="table_with_length.md#0x1_table_with_length_remove">table_with_length::remove</a>(&<b>mut</b> v.buckets, num_buckets - 1));
    };
    v.end_index = v.end_index - 1;
    val
}
</code></pre>



</details>

<a id="0x1_big_vector_remove"></a>

## Function `remove`

Remove the element at index i in the vector v and return the owned value that was previously stored at i in v.
All elements occurring at indices greater than i will be shifted down by 1. Will abort if i is out of bounds.
Disclaimer: This function is costly. Use it at your own discretion.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_remove">remove</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64): T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_remove">remove</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, i: u64): T {
    <b>let</b> len = <a href="big_vector.md#0x1_big_vector_length">length</a>(v);
    <b>assert</b>!(i &lt; len, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="big_vector.md#0x1_big_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</a>));
    <b>let</b> num_buckets = <a href="table_with_length.md#0x1_table_with_length_length">table_with_length::length</a>(&v.buckets);
    <b>let</b> cur_bucket_index = i / v.bucket_size + 1;
    <b>let</b> cur_bucket = <a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, cur_bucket_index - 1);
    <b>let</b> res = <a href="../../move-stdlib/doc/vector.md#0x1_vector_remove">vector::remove</a>(cur_bucket, i % v.bucket_size);
    v.end_index = v.end_index - 1;
    <b>move</b> cur_bucket;
    <b>while</b> ({
        <b>spec</b> {
            <b>invariant</b> cur_bucket_index &lt;= num_buckets;
            <b>invariant</b> <a href="table_with_length.md#0x1_table_with_length_spec_len">table_with_length::spec_len</a>(v.buckets) == num_buckets;
        };
        (cur_bucket_index &lt; num_buckets)
    }) {
        // remove one element from the start of current <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>
        <b>let</b> cur_bucket = <a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, cur_bucket_index);
        <b>let</b> t = <a href="../../move-stdlib/doc/vector.md#0x1_vector_remove">vector::remove</a>(cur_bucket, 0);
        <b>move</b> cur_bucket;
        // and put it at the end of the last one
        <b>let</b> prev_bucket = <a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, cur_bucket_index - 1);
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(prev_bucket, t);
        cur_bucket_index = cur_bucket_index + 1;
    };
    <b>spec</b> {
        <b>assert</b> cur_bucket_index == num_buckets;
    };

    // Shrink the <a href="table.md#0x1_table">table</a> <b>if</b> the last <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a> is empty.
    <b>let</b> last_bucket = <a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, num_buckets - 1);
    <b>if</b> (<a href="../../move-stdlib/doc/vector.md#0x1_vector_is_empty">vector::is_empty</a>(last_bucket)) {
        <b>move</b> last_bucket;
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_destroy_empty">vector::destroy_empty</a>(<a href="table_with_length.md#0x1_table_with_length_remove">table_with_length::remove</a>(&<b>mut</b> v.buckets, num_buckets - 1));
    };

    res
}
</code></pre>



</details>

<a id="0x1_big_vector_swap_remove"></a>

## Function `swap_remove`

Swap the <code>i</code>th element of the vector <code>v</code> with the last element and then pop the vector.
This is O(1), but does not preserve ordering of elements in the vector.
Aborts if <code>i</code> is out of bounds.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_swap_remove">swap_remove</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64): T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_swap_remove">swap_remove</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, i: u64): T {
    <b>assert</b>!(i &lt; <a href="big_vector.md#0x1_big_vector_length">length</a>(v), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="big_vector.md#0x1_big_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</a>));
    <b>let</b> last_val = <a href="big_vector.md#0x1_big_vector_pop_back">pop_back</a>(v);
    // <b>if</b> the requested value is the last one, <b>return</b> it
    <b>if</b> (v.end_index == i) {
        <b>return</b> last_val
    };
    // because the lack of mem::swap, here we swap remove the requested value from the bucket
    // and append the last_val <b>to</b> the bucket then swap the last bucket val back
    <b>let</b> bucket = <a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, i / v.bucket_size);
    <b>let</b> bucket_len = <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(bucket);
    <b>let</b> val = <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap_remove">vector::swap_remove</a>(bucket, i % v.bucket_size);
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(bucket, last_val);
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap">vector::swap</a>(bucket, i % v.bucket_size, bucket_len - 1);
    val
}
</code></pre>



</details>

<a id="0x1_big_vector_swap"></a>

## Function `swap`

Swap the elements at the i'th and j'th indices in the vector v. Will abort if either of i or j are out of bounds
for v.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_swap">swap</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64, j: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_swap">swap</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, i: u64, j: u64) {
    <b>assert</b>!(i &lt; <a href="big_vector.md#0x1_big_vector_length">length</a>(v) && j &lt; <a href="big_vector.md#0x1_big_vector_length">length</a>(v), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="big_vector.md#0x1_big_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</a>));
    <b>let</b> i_bucket_index = i / v.bucket_size;
    <b>let</b> j_bucket_index = j / v.bucket_size;
    <b>let</b> i_vector_index = i % v.bucket_size;
    <b>let</b> j_vector_index = j % v.bucket_size;
    <b>if</b> (i_bucket_index == j_bucket_index) {
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap">vector::swap</a>(<a href="table_with_length.md#0x1_table_with_length_borrow_mut">table_with_length::borrow_mut</a>(&<b>mut</b> v.buckets, i_bucket_index), i_vector_index, j_vector_index);
        <b>return</b>
    };
    // If i and j are in different buckets, take the buckets out first for easy mutation.
    <b>let</b> bucket_i = <a href="table_with_length.md#0x1_table_with_length_remove">table_with_length::remove</a>(&<b>mut</b> v.buckets, i_bucket_index);
    <b>let</b> bucket_j = <a href="table_with_length.md#0x1_table_with_length_remove">table_with_length::remove</a>(&<b>mut</b> v.buckets, j_bucket_index);
    // Get the elements from buckets by calling `swap_remove`.
    <b>let</b> element_i = <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap_remove">vector::swap_remove</a>(&<b>mut</b> bucket_i, i_vector_index);
    <b>let</b> element_j = <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap_remove">vector::swap_remove</a>(&<b>mut</b> bucket_j, j_vector_index);
    // Swap the elements and push back <b>to</b> the other bucket.
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> bucket_i, element_j);
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> bucket_j, element_i);
    <b>let</b> last_index_in_bucket_i = <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&bucket_i) - 1;
    <b>let</b> last_index_in_bucket_j = <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&bucket_j) - 1;
    // Re-position the swapped elements <b>to</b> the right index.
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap">vector::swap</a>(&<b>mut</b> bucket_i, i_vector_index, last_index_in_bucket_i);
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap">vector::swap</a>(&<b>mut</b> bucket_j, j_vector_index, last_index_in_bucket_j);
    // Add back the buckets.
    <a href="table_with_length.md#0x1_table_with_length_add">table_with_length::add</a>(&<b>mut</b> v.buckets, i_bucket_index, bucket_i);
    <a href="table_with_length.md#0x1_table_with_length_add">table_with_length::add</a>(&<b>mut</b> v.buckets, j_bucket_index, bucket_j);
}
</code></pre>



</details>

<a id="0x1_big_vector_reverse"></a>

## Function `reverse`

Reverse the order of the elements in the vector v in-place.
Disclaimer: This function is costly. Use it at your own discretion.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_reverse">reverse</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_reverse">reverse</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;) {
    <b>let</b> new_buckets = <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>[];
    <b>let</b> push_bucket = <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>[];
    <b>let</b> num_buckets = <a href="table_with_length.md#0x1_table_with_length_length">table_with_length::length</a>(&v.buckets);
    <b>let</b> num_buckets_left = num_buckets;

    <b>while</b> (num_buckets_left &gt; 0) {
        <b>let</b> pop_bucket = <a href="table_with_length.md#0x1_table_with_length_remove">table_with_length::remove</a>(&<b>mut</b> v.buckets, num_buckets_left - 1);
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_for_each_reverse">vector::for_each_reverse</a>(pop_bucket, |val| {
            <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> push_bucket, val);
            <b>if</b> (<a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&push_bucket) == v.bucket_size) {
                <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> new_buckets, push_bucket);
                push_bucket = <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>[];
            };
        });
        num_buckets_left = num_buckets_left - 1;
    };

    <b>if</b> (<a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&push_bucket) &gt; 0) {
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> new_buckets, push_bucket);
    } <b>else</b> {
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_destroy_empty">vector::destroy_empty</a>(push_bucket);
    };

    <a href="../../move-stdlib/doc/vector.md#0x1_vector_reverse">vector::reverse</a>(&<b>mut</b> new_buckets);
    <b>let</b> i = 0;
    <b>assert</b>!(<a href="table_with_length.md#0x1_table_with_length_length">table_with_length::length</a>(&v.buckets) == 0, 0);
    <b>while</b> (i &lt; num_buckets) {
        <a href="table_with_length.md#0x1_table_with_length_add">table_with_length::add</a>(&<b>mut</b> v.buckets, i, <a href="../../move-stdlib/doc/vector.md#0x1_vector_pop_back">vector::pop_back</a>(&<b>mut</b> new_buckets));
        i = i + 1;
    };
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_destroy_empty">vector::destroy_empty</a>(new_buckets);
}
</code></pre>



</details>

<a id="0x1_big_vector_index_of"></a>

## Function `index_of`

Return the index of the first occurrence of an element in v that is equal to e. Returns (true, index) if such an
element was found, and (false, 0) otherwise.
Disclaimer: This function is costly. Use it at your own discretion.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_index_of">index_of</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, val: &T): (bool, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_index_of">index_of</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, val: &T): (bool, u64) {
    <b>let</b> num_buckets = <a href="table_with_length.md#0x1_table_with_length_length">table_with_length::length</a>(&v.buckets);
    <b>let</b> bucket_index = 0;
    <b>while</b> (bucket_index &lt; num_buckets) {
        <b>let</b> cur = <a href="table_with_length.md#0x1_table_with_length_borrow">table_with_length::borrow</a>(&v.buckets, bucket_index);
        <b>let</b> (found, i) = <a href="../../move-stdlib/doc/vector.md#0x1_vector_index_of">vector::index_of</a>(cur, val);
        <b>if</b> (found) {
            <b>return</b> (<b>true</b>, bucket_index * v.bucket_size + i)
        };
        bucket_index = bucket_index + 1;
    };
    (<b>false</b>, 0)
}
</code></pre>



</details>

<a id="0x1_big_vector_contains"></a>

## Function `contains`

Return if an element equal to e exists in the vector v.
Disclaimer: This function is costly. Use it at your own discretion.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_contains">contains</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, val: &T): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_contains">contains</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, val: &T): bool {
    <b>if</b> (<a href="big_vector.md#0x1_big_vector_is_empty">is_empty</a>(v)) <b>return</b> <b>false</b>;
    <b>let</b> (exist, _) = <a href="big_vector.md#0x1_big_vector_index_of">index_of</a>(v, val);
    exist
}
</code></pre>



</details>

<a id="0x1_big_vector_to_vector"></a>

## Function `to_vector`

Convert a big vector to a native vector, which is supposed to be called mostly by view functions to get an
atomic view of the whole vector.
Disclaimer: This function may be costly as the big vector may be huge in size. Use it at your own discretion.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_to_vector">to_vector</a>&lt;T: <b>copy</b>&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_to_vector">to_vector</a>&lt;T: <b>copy</b>&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;T&gt; {
    <b>let</b> res = <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>[];
    <b>let</b> num_buckets = <a href="table_with_length.md#0x1_table_with_length_length">table_with_length::length</a>(&v.buckets);
    <b>let</b> i = 0;
    <b>while</b> (i &lt; num_buckets) {
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_append">vector::append</a>(&<b>mut</b> res, *<a href="table_with_length.md#0x1_table_with_length_borrow">table_with_length::borrow</a>(&v.buckets, i));
        i = i + 1;
    };
    res
}
</code></pre>



</details>

<a id="0x1_big_vector_length"></a>

## Function `length`

Return the length of the vector.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_length">length</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_length">length</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;): u64 {
    v.end_index
}
</code></pre>



</details>

<a id="0x1_big_vector_is_empty"></a>

## Function `is_empty`

Return <code><b>true</b></code> if the vector <code>v</code> has no elements and <code><b>false</b></code> otherwise.


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_is_empty">is_empty</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_is_empty">is_empty</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;): bool {
    <a href="big_vector.md#0x1_big_vector_length">length</a>(v) == 0
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_BigVector"></a>

### Struct `BigVector`


<pre><code><b>struct</b> <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt; <b>has</b> store
</code></pre>



<dl>
<dt>
<code>buckets: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;u64, <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;T&gt;&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>end_index: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>bucket_size: u64</code>
</dt>
<dd>

</dd>
</dl>



<pre><code><b>invariant</b> bucket_size != 0;
<b>invariant</b> <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) == 0 ==&gt; end_index == 0;
<b>invariant</b> end_index == 0 ==&gt; <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) == 0;
<b>invariant</b> end_index &lt;= <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) * bucket_size;
<b>invariant</b> <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) == 0
    || (<b>forall</b> i in 0..<a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets)-1: len(<a href="table_with_length.md#0x1_table_with_length_spec_get">table_with_length::spec_get</a>(buckets, i)) == bucket_size);
<b>invariant</b> <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) == 0
    || len(<a href="table_with_length.md#0x1_table_with_length_spec_get">table_with_length::spec_get</a>(buckets, <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) -1 )) &lt;= bucket_size;
<b>invariant</b> <b>forall</b> i in 0..<a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets): <a href="big_vector.md#0x1_big_vector_spec_table_contains">spec_table_contains</a>(buckets, i);
<b>invariant</b> <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) == (end_index + bucket_size - 1) / bucket_size;
<b>invariant</b> (<a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) == 0 && end_index == 0)
    || (<a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) != 0 && ((<a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) - 1) * bucket_size) + (len(<a href="table_with_length.md#0x1_table_with_length_spec_get">table_with_length::spec_get</a>(buckets, <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) - 1))) == end_index);
<b>invariant</b> <b>forall</b> i: u64 <b>where</b> i &gt;= <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets):  {
    !<a href="big_vector.md#0x1_big_vector_spec_table_contains">spec_table_contains</a>(buckets, i)
};
<b>invariant</b> <b>forall</b> i: u64 <b>where</b> i &lt; <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets):  {
    <a href="big_vector.md#0x1_big_vector_spec_table_contains">spec_table_contains</a>(buckets, i)
};
<b>invariant</b> <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) == 0
    || (len(<a href="table_with_length.md#0x1_table_with_length_spec_get">table_with_length::spec_get</a>(buckets, <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(buckets) - 1)) &gt; 0);
</code></pre>



<a id="@Specification_1_empty"></a>

### Function `empty`


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="big_vector.md#0x1_big_vector_empty">empty</a>&lt;T: store&gt;(bucket_size: u64): <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;
</code></pre>




<pre><code><b>aborts_if</b> bucket_size == 0;
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_length">length</a>(result) == 0;
<b>ensures</b> result.bucket_size == bucket_size;
</code></pre>



<a id="@Specification_1_singleton"></a>

### Function `singleton`


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="big_vector.md#0x1_big_vector_singleton">singleton</a>&lt;T: store&gt;(element: T, bucket_size: u64): <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;
</code></pre>




<pre><code><b>aborts_if</b> bucket_size == 0;
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_length">length</a>(result) == 1;
<b>ensures</b> result.bucket_size == bucket_size;
</code></pre>



<a id="@Specification_1_destroy_empty"></a>

### Function `destroy_empty`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_destroy_empty">destroy_empty</a>&lt;T&gt;(v: <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;)
</code></pre>




<pre><code><b>aborts_if</b> !<a href="big_vector.md#0x1_big_vector_is_empty">is_empty</a>(v);
</code></pre>



<a id="@Specification_1_borrow"></a>

### Function `borrow`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_borrow">borrow</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64): &T
</code></pre>




<pre><code><b>aborts_if</b> i &gt;= <a href="big_vector.md#0x1_big_vector_length">length</a>(v);
<b>ensures</b> result == <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, i);
</code></pre>



<a id="@Specification_1_borrow_mut"></a>

### Function `borrow_mut`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_borrow_mut">borrow_mut</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64): &<b>mut</b> T
</code></pre>




<pre><code><b>aborts_if</b> i &gt;= <a href="big_vector.md#0x1_big_vector_length">length</a>(v);
<b>ensures</b> result == <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, i);
</code></pre>



<a id="@Specification_1_append"></a>

### Function `append`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_append">append</a>&lt;T: store&gt;(lhs: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, other: <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;)
</code></pre>




<pre><code><b>pragma</b> verify=<b>false</b>;
</code></pre>



<a id="@Specification_1_push_back"></a>

### Function `push_back`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_push_back">push_back</a>&lt;T: store&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, val: T)
</code></pre>




<pre><code><b>let</b> num_buckets = <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(v.buckets);
<b>include</b> <a href="big_vector.md#0x1_big_vector_PushbackAbortsIf">PushbackAbortsIf</a>&lt;T&gt;;
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_length">length</a>(v) == <a href="big_vector.md#0x1_big_vector_length">length</a>(<b>old</b>(v)) + 1;
<b>ensures</b> v.end_index == <b>old</b>(v.end_index) + 1;
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, v.end_index-1) == val;
<b>ensures</b> <b>forall</b> i in 0..v.end_index-1: <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, i) == <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(<b>old</b>(v), i);
<b>ensures</b> v.bucket_size == <b>old</b>(v).bucket_size;
</code></pre>




<a id="0x1_big_vector_PushbackAbortsIf"></a>


<pre><code><b>schema</b> <a href="big_vector.md#0x1_big_vector_PushbackAbortsIf">PushbackAbortsIf</a>&lt;T&gt; {
    v: <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;;
    <b>let</b> num_buckets = <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>(v.buckets);
    <b>aborts_if</b> num_buckets * v.bucket_size &gt; MAX_U64;
    <b>aborts_if</b> v.end_index + 1 &gt; MAX_U64;
}
</code></pre>



<a id="@Specification_1_pop_back"></a>

### Function `pop_back`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_pop_back">pop_back</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;): T
</code></pre>




<pre><code><b>aborts_if</b> <a href="big_vector.md#0x1_big_vector_is_empty">is_empty</a>(v);
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_length">length</a>(v) == <a href="big_vector.md#0x1_big_vector_length">length</a>(<b>old</b>(v)) - 1;
<b>ensures</b> result == <b>old</b>(<a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, v.end_index-1));
<b>ensures</b> <b>forall</b> i in 0..v.end_index: <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, i) == <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(<b>old</b>(v), i);
</code></pre>



<a id="@Specification_1_remove"></a>

### Function `remove`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_remove">remove</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64): T
</code></pre>




<pre><code><b>pragma</b> verify=<b>false</b>;
</code></pre>



<a id="@Specification_1_swap_remove"></a>

### Function `swap_remove`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_swap_remove">swap_remove</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64): T
</code></pre>




<pre><code><b>pragma</b> verify_duration_estimate = 120;
<b>aborts_if</b> i &gt;= <a href="big_vector.md#0x1_big_vector_length">length</a>(v);
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_length">length</a>(v) == <a href="big_vector.md#0x1_big_vector_length">length</a>(<b>old</b>(v)) - 1;
<b>ensures</b> result == <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(<b>old</b>(v), i);
</code></pre>



<a id="@Specification_1_swap"></a>

### Function `swap`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_swap">swap</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, i: u64, j: u64)
</code></pre>




<pre><code><b>pragma</b> verify_duration_estimate = 1000;
<b>aborts_if</b> i &gt;= <a href="big_vector.md#0x1_big_vector_length">length</a>(v) || j &gt;= <a href="big_vector.md#0x1_big_vector_length">length</a>(v);
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_length">length</a>(v) == <a href="big_vector.md#0x1_big_vector_length">length</a>(<b>old</b>(v));
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, i) == <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(<b>old</b>(v), j);
<b>ensures</b> <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, j) == <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(<b>old</b>(v), i);
<b>ensures</b> <b>forall</b> idx in 0..<a href="big_vector.md#0x1_big_vector_length">length</a>(v)
    <b>where</b> idx != i && idx != j:
    <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(v, idx) == <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>(<b>old</b>(v), idx);
</code></pre>



<a id="@Specification_1_reverse"></a>

### Function `reverse`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_reverse">reverse</a>&lt;T&gt;(v: &<b>mut</b> <a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;)
</code></pre>




<pre><code><b>pragma</b> verify=<b>false</b>;
</code></pre>



<a id="@Specification_1_index_of"></a>

### Function `index_of`


<pre><code><b>public</b> <b>fun</b> <a href="big_vector.md#0x1_big_vector_index_of">index_of</a>&lt;T&gt;(v: &<a href="big_vector.md#0x1_big_vector_BigVector">big_vector::BigVector</a>&lt;T&gt;, val: &T): (bool, u64)
</code></pre>




<pre><code><b>pragma</b> verify=<b>false</b>;
</code></pre>




<a id="0x1_big_vector_spec_table_len"></a>


<pre><code><b>fun</b> <a href="big_vector.md#0x1_big_vector_spec_table_len">spec_table_len</a>&lt;K, V&gt;(t: TableWithLength&lt;K, V&gt;): u64 {
   <a href="table_with_length.md#0x1_table_with_length_spec_len">table_with_length::spec_len</a>(t)
}
</code></pre>




<a id="0x1_big_vector_spec_table_contains"></a>


<pre><code><b>fun</b> <a href="big_vector.md#0x1_big_vector_spec_table_contains">spec_table_contains</a>&lt;K, V&gt;(t: TableWithLength&lt;K, V&gt;, k: K): bool {
   <a href="table_with_length.md#0x1_table_with_length_spec_contains">table_with_length::spec_contains</a>(t, k)
}
</code></pre>




<a id="0x1_big_vector_spec_at"></a>


<pre><code><b>fun</b> <a href="big_vector.md#0x1_big_vector_spec_at">spec_at</a>&lt;T&gt;(v: <a href="big_vector.md#0x1_big_vector_BigVector">BigVector</a>&lt;T&gt;, i: u64): T {
   <b>let</b> bucket = i / v.bucket_size;
   <b>let</b> idx = i % v.bucket_size;
   <b>let</b> v = <a href="table_with_length.md#0x1_table_with_length_spec_get">table_with_length::spec_get</a>(v.buckets, bucket);
   v[idx]
}
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/bls12381_algebra.md
================================================

<a id="0x1_bls12381_algebra"></a>

# Module `0x1::bls12381_algebra`

This module defines marker types, constants and test cases for working with BLS12-381 curves
using the generic API defined in <code>algebra.<b>move</b></code>.
See https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11#name-bls-curves-for-the-128-bit-
for the full specification of BLS12-381 curves.

Currently-supported BLS12-381 structures include <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fq12">Fq12</a></code>, <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fr">Fr</a></code>, <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code>, <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> and <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Gt">Gt</a></code>,
along with their widely-used serialization formats,
the pairing between <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code>, <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> and <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Gt">Gt</a></code>,
and the hash-to-curve operations for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code> and <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> defined in https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16.

Other unimplemented BLS12-381 structures and serialization formats are also listed here,
as they help define some of the currently supported structures.
Their implementation may also be added in the future.

<code>Fq</code>: the finite field $F_q$ used in BLS12-381 curves with a prime order $q$ equal to
0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab.

<code>FormatFqLsb</code>: a serialization format for <code>Fq</code> elements,
where an element is represented by a byte array <code>b[]</code> of size 48 with the least significant byte (LSB) coming first.

<code>FormatFqMsb</code>: a serialization format for <code>Fq</code> elements,
where an element is represented by a byte array <code>b[]</code> of size 48 with the most significant byte (MSB) coming first.

<code>Fq2</code>: the finite field $F_{q^2}$ used in BLS12-381 curves,
which is an extension field of <code>Fq</code>, constructed as $F_{q^2}=F_q[u]/(u^2+1)$.

<code>FormatFq2LscLsb</code>: a serialization format for <code>Fq2</code> elements,
where an element in the form $(c_0+c_1\cdot u)$ is represented by a byte array <code>b[]</code> of size 96,
which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first:
- <code>b[0..48]</code> is $c_0$ serialized using <code>FormatFqLsb</code>.
- <code>b[48..96]</code> is $c_1$ serialized using <code>FormatFqLsb</code>.

<code>FormatFq2MscMsb</code>: a serialization format for <code>Fq2</code> elements,
where an element in the form $(c_0+c_1\cdot u)$ is represented by a byte array <code>b[]</code> of size 96,
which is a concatenation of its coefficients serialized, with the most significant coefficient (MSC) coming first:
- <code>b[0..48]</code> is $c_1$ serialized using <code>FormatFqLsb</code>.
- <code>b[48..96]</code> is $c_0$ serialized using <code>FormatFqLsb</code>.

<code>Fq6</code>: the finite field $F_{q^6}$ used in BLS12-381 curves,
which is an extension field of <code>Fq2</code>, constructed as $F_{q^6}=F_{q^2}[v]/(v^3-u-1)$.

<code>FormatFq6LscLsb</code>: a serialization scheme for <code>Fq6</code> elements,
where an element in the form $(c_0+c_1\cdot v+c_2\cdot v^2)$ is represented by a byte array <code>b[]</code> of size 288,
which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first:
- <code>b[0..96]</code> is $c_0$ serialized using <code>FormatFq2LscLsb</code>.
- <code>b[96..192]</code> is $c_1$ serialized using <code>FormatFq2LscLsb</code>.
- <code>b[192..288]</code> is $c_2$ serialized using <code>FormatFq2LscLsb</code>.

<code>G1Full</code>: a group constructed by the points on the BLS12-381 curve $E(F_q): y^2=x^3+4$ and the point at infinity,
under the elliptic curve point addition.
It contains the prime-order subgroup $G_1$ used in pairing.

<code>G2Full</code>: a group constructed by the points on a curve $E'(F_{q^2}): y^2=x^3+4(u+1)$ and the point at infinity,
under the elliptic curve point addition.
It contains the prime-order subgroup $G_2$ used in pairing.


-  [Struct `Fq12`](#0x1_bls12381_algebra_Fq12)
-  [Struct `FormatFq12LscLsb`](#0x1_bls12381_algebra_FormatFq12LscLsb)
-  [Struct `G1`](#0x1_bls12381_algebra_G1)
-  [Struct `FormatG1Uncompr`](#0x1_bls12381_algebra_FormatG1Uncompr)
-  [Struct `FormatG1Compr`](#0x1_bls12381_algebra_FormatG1Compr)
-  [Struct `G2`](#0x1_bls12381_algebra_G2)
-  [Struct `FormatG2Uncompr`](#0x1_bls12381_algebra_FormatG2Uncompr)
-  [Struct `FormatG2Compr`](#0x1_bls12381_algebra_FormatG2Compr)
-  [Struct `Gt`](#0x1_bls12381_algebra_Gt)
-  [Struct `FormatGt`](#0x1_bls12381_algebra_FormatGt)
-  [Struct `Fr`](#0x1_bls12381_algebra_Fr)
-  [Struct `FormatFrLsb`](#0x1_bls12381_algebra_FormatFrLsb)
-  [Struct `FormatFrMsb`](#0x1_bls12381_algebra_FormatFrMsb)
-  [Struct `HashG1XmdSha256SswuRo`](#0x1_bls12381_algebra_HashG1XmdSha256SswuRo)
-  [Struct `HashG2XmdSha256SswuRo`](#0x1_bls12381_algebra_HashG2XmdSha256SswuRo)


<pre><code></code></pre>



<a id="0x1_bls12381_algebra_Fq12"></a>

## Struct `Fq12`

The finite field $F_{q^12}$ used in BLS12-381 curves,
which is an extension field of <code>Fq6</code> (defined in the module documentation), constructed as $F_{q^12}=F_{q^6}[w]/(w^2-v)$.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_Fq12">Fq12</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_FormatFq12LscLsb"></a>

## Struct `FormatFq12LscLsb`

A serialization scheme for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fq12">Fq12</a></code> elements,
where an element $(c_0+c_1\cdot w)$ is represented by a byte array <code>b[]</code> of size 576,
which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first.
- <code>b[0..288]</code> is $c_0$ serialized using <code>FormatFq6LscLsb</code> (defined in the module documentation).
- <code>b[288..576]</code> is $c_1$ serialized using <code>FormatFq6LscLsb</code>.

NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatFq12LscLsb">FormatFq12LscLsb</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_G1"></a>

## Struct `G1`

The group $G_1$ in BLS12-381-based pairing $G_1 \times G_2 \rightarrow G_t$.
It is a subgroup of <code>G1Full</code> (defined in the module documentation) with a prime order $r$
equal to 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.
(so <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fr">Fr</a></code> is the associated scalar field).


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_FormatG1Uncompr"></a>

## Struct `FormatG1Uncompr`

A serialization scheme for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code> elements derived from
https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-.

Below is the serialization procedure that takes a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code> element <code>p</code> and outputs a byte array of size 96.
1. Let <code>(x,y)</code> be the coordinates of <code>p</code> if <code>p</code> is on the curve, or <code>(0,0)</code> otherwise.
1. Serialize <code>x</code> and <code>y</code> into <code>b_x[]</code> and <code>b_y[]</code> respectively using <code>FormatFqMsb</code> (defined in the module documentation).
1. Concatenate <code>b_x[]</code> and <code>b_y[]</code> into <code>b[]</code>.
1. If <code>p</code> is the point at infinity, set the infinity bit: <code>b[0]: = b[0] | 0x40</code>.
1. Return <code>b[]</code>.

Below is the deserialization procedure that takes a byte array <code>b[]</code> and outputs either a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code> element or none.
1. If the size of <code>b[]</code> is not 96, return none.
1. Compute the compression flag as <code>b[0] & 0x80 != 0</code>.
1. If the compression flag is true, return none.
1. Compute the infinity flag as <code>b[0] & 0x40 != 0</code>.
1. If the infinity flag is set, return the point at infinity.
1. Deserialize <code>[b[0] & 0x1f, b[1], ..., b[47]]</code> to <code>x</code> using <code>FormatFqMsb</code>. If <code>x</code> is none, return none.
1. Deserialize <code>[b[48], ..., b[95]]</code> to <code>y</code> using <code>FormatFqMsb</code>. If <code>y</code> is none, return none.
1. Check if <code>(x,y)</code> is on curve <code>E</code>. If not, return none.
1. Check if <code>(x,y)</code> is in the subgroup of order <code>r</code>. If not, return none.
1. Return <code>(x,y)</code>.

NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatG1Uncompr">FormatG1Uncompr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_FormatG1Compr"></a>

## Struct `FormatG1Compr`

A serialization scheme for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code> elements derived from
https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-.

Below is the serialization procedure that takes a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code> element <code>p</code> and outputs a byte array of size 48.
1. Let <code>(x,y)</code> be the coordinates of <code>p</code> if <code>p</code> is on the curve, or <code>(0,0)</code> otherwise.
1. Serialize <code>x</code> into <code>b[]</code> using <code>FormatFqMsb</code> (defined in the module documentation).
1. Set the compression bit: <code>b[0] := b[0] | 0x80</code>.
1. If <code>p</code> is the point at infinity, set the infinity bit: <code>b[0]: = b[0] | 0x40</code>.
1. If <code>y &gt; -y</code>, set the lexicographical flag: <code>b[0] := b[0] | 0x20</code>.
1. Return <code>b[]</code>.

Below is the deserialization procedure that takes a byte array <code>b[]</code> and outputs either a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code> element or none.
1. If the size of <code>b[]</code> is not 48, return none.
1. Compute the compression flag as <code>b[0] & 0x80 != 0</code>.
1. If the compression flag is false, return none.
1. Compute the infinity flag as <code>b[0] & 0x40 != 0</code>.
1. If the infinity flag is set, return the point at infinity.
1. Compute the lexicographical flag as <code>b[0] & 0x20 != 0</code>.
1. Deserialize <code>[b[0] & 0x1f, b[1], ..., b[47]]</code> to <code>x</code> using <code>FormatFqMsb</code>. If <code>x</code> is none, return none.
1. Solve the curve equation with <code>x</code> for <code>y</code>. If no such <code>y</code> exists, return none.
1. Let <code>y'</code> be <code>max(y,-y)</code> if the lexicographical flag is set, or <code><b>min</b>(y,-y)</code> otherwise.
1. Check if <code>(x,y')</code> is in the subgroup of order <code>r</code>. If not, return none.
1. Return <code>(x,y')</code>.

NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatG1Compr">FormatG1Compr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_G2"></a>

## Struct `G2`

The group $G_2$ in BLS12-381-based pairing $G_1 \times G_2 \rightarrow G_t$.
It is a subgroup of <code>G2Full</code> (defined in the module documentation) with a prime order $r$ equal to
0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.
(so <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fr">Fr</a></code> is the scalar field).


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_FormatG2Uncompr"></a>

## Struct `FormatG2Uncompr`

A serialization scheme for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> elements derived from
https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-.

Below is the serialization procedure that takes a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> element <code>p</code> and outputs a byte array of size 192.
1. Let <code>(x,y)</code> be the coordinates of <code>p</code> if <code>p</code> is on the curve, or <code>(0,0)</code> otherwise.
1. Serialize <code>x</code> and <code>y</code> into <code>b_x[]</code> and <code>b_y[]</code> respectively using <code>FormatFq2MscMsb</code> (defined in the module documentation).
1. Concatenate <code>b_x[]</code> and <code>b_y[]</code> into <code>b[]</code>.
1. If <code>p</code> is the point at infinity, set the infinity bit in <code>b[]</code>: <code>b[0]: = b[0] | 0x40</code>.
1. Return <code>b[]</code>.

Below is the deserialization procedure that takes a byte array <code>b[]</code> and outputs either a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> element or none.
1. If the size of <code>b[]</code> is not 192, return none.
1. Compute the compression flag as <code>b[0] & 0x80 != 0</code>.
1. If the compression flag is true, return none.
1. Compute the infinity flag as <code>b[0] & 0x40 != 0</code>.
1. If the infinity flag is set, return the point at infinity.
1. Deserialize <code>[b[0] & 0x1f, ..., b[95]]</code> to <code>x</code> using <code>FormatFq2MscMsb</code>. If <code>x</code> is none, return none.
1. Deserialize <code>[b[96], ..., b[191]]</code> to <code>y</code> using <code>FormatFq2MscMsb</code>. If <code>y</code> is none, return none.
1. Check if <code>(x,y)</code> is on the curve <code>E'</code>. If not, return none.
1. Check if <code>(x,y)</code> is in the subgroup of order <code>r</code>. If not, return none.
1. Return <code>(x,y)</code>.

NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatG2Uncompr">FormatG2Uncompr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_FormatG2Compr"></a>

## Struct `FormatG2Compr`

A serialization scheme for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> elements derived from
https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-.

Below is the serialization procedure that takes a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> element <code>p</code> and outputs a byte array of size 96.
1. Let <code>(x,y)</code> be the coordinates of <code>p</code> if <code>p</code> is on the curve, or <code>(0,0)</code> otherwise.
1. Serialize <code>x</code> into <code>b[]</code> using <code>FormatFq2MscMsb</code> (defined in the module documentation).
1. Set the compression bit: <code>b[0] := b[0] | 0x80</code>.
1. If <code>p</code> is the point at infinity, set the infinity bit: <code>b[0]: = b[0] | 0x40</code>.
1. If <code>y &gt; -y</code>, set the lexicographical flag: <code>b[0] := b[0] | 0x20</code>.
1. Return <code>b[]</code>.

Below is the deserialization procedure that takes a byte array <code>b[]</code> and outputs either a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> element or none.
1. If the size of <code>b[]</code> is not 96, return none.
1. Compute the compression flag as <code>b[0] & 0x80 != 0</code>.
1. If the compression flag is false, return none.
1. Compute the infinity flag as <code>b[0] & 0x40 != 0</code>.
1. If the infinity flag is set, return the point at infinity.
1. Compute the lexicographical flag as <code>b[0] & 0x20 != 0</code>.
1. Deserialize <code>[b[0] & 0x1f, b[1], ..., b[95]]</code> to <code>x</code> using <code>FormatFq2MscMsb</code>. If <code>x</code> is none, return none.
1. Solve the curve equation with <code>x</code> for <code>y</code>. If no such <code>y</code> exists, return none.
1. Let <code>y'</code> be <code>max(y,-y)</code> if the lexicographical flag is set, or <code><b>min</b>(y,-y)</code> otherwise.
1. Check if <code>(x,y')</code> is in the subgroup of order <code>r</code>. If not, return none.
1. Return <code>(x,y')</code>.

NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatG2Compr">FormatG2Compr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_Gt"></a>

## Struct `Gt`

The group $G_t$ in BLS12-381-based pairing $G_1 \times G_2 \rightarrow G_t$.
It is a multiplicative subgroup of <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fq12">Fq12</a></code>,
with a prime order $r$ equal to 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.
(so <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fr">Fr</a></code> is the scalar field).
The identity of <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Gt">Gt</a></code> is 1.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_Gt">Gt</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_FormatGt"></a>

## Struct `FormatGt`

A serialization scheme for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Gt">Gt</a></code> elements.

To serialize, it treats a <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Gt">Gt</a></code> element <code>p</code> as an <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fq12">Fq12</a></code> element and serialize it using <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatFq12LscLsb">FormatFq12LscLsb</a></code>.

To deserialize, it uses <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatFq12LscLsb">FormatFq12LscLsb</a></code> to try deserializing to an <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fq12">Fq12</a></code> element then test the membership in <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Gt">Gt</a></code>.

NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatGt">FormatGt</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_Fr"></a>

## Struct `Fr`

The finite field $F_r$ that can be used as the scalar fields
associated with the groups $G_1$, $G_2$, $G_t$ in BLS12-381-based pairing.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_Fr">Fr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_FormatFrLsb"></a>

## Struct `FormatFrLsb`

A serialization format for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fr">Fr</a></code> elements,
where an element is represented by a byte array <code>b[]</code> of size 32 with the least significant byte (LSB) coming first.

NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0, blst-0.3.7.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatFrLsb">FormatFrLsb</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_FormatFrMsb"></a>

## Struct `FormatFrMsb`

A serialization scheme for <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_Fr">Fr</a></code> elements,
where an element is represented by a byte array <code>b[]</code> of size 32 with the most significant byte (MSB) coming first.

NOTE: other implementation(s) using this format: ark-bls12-381-0.4.0, blst-0.3.7.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_FormatFrMsb">FormatFrMsb</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_HashG1XmdSha256SswuRo"></a>

## Struct `HashG1XmdSha256SswuRo`

The hash-to-curve suite <code>BLS12381G1_XMD:SHA-256_SSWU_RO_</code> that hashes a byte array into <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G1">G1</a></code> elements.

Full specification is defined in https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#name-bls12-381-g1.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_HashG1XmdSha256SswuRo">HashG1XmdSha256SswuRo</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bls12381_algebra_HashG2XmdSha256SswuRo"></a>

## Struct `HashG2XmdSha256SswuRo`

The hash-to-curve suite <code>BLS12381G2_XMD:SHA-256_SSWU_RO_</code> that hashes a byte array into <code><a href="bls12381_algebra.md#0x1_bls12381_algebra_G2">G2</a></code> elements.

Full specification is defined in https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#name-bls12-381-g2.


<pre><code><b>struct</b> <a href="bls12381_algebra.md#0x1_bls12381_algebra_HashG2XmdSha256SswuRo">HashG2XmdSha256SswuRo</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/bn254_algebra.md
================================================

<a id="0x1_bn254_algebra"></a>

# Module `0x1::bn254_algebra`

This module defines marker types, constants and test cases for working with BN254 curves using the generic API defined in <code>algebra.<b>move</b></code>.
BN254 was sampled as part of the [\[BCTV14\]](https://eprint.iacr.org/2013/879.pdf) paper .
The name denotes that it is a Barreto-Naehrig curve of embedding degree 12, defined over a 254-bit (prime) field.
The scalar field is highly 2-adic which supports subgroups of roots of unity of size <= 2^28.
(as (21888242871839275222246405745257275088548364400416034343698204186575808495617 - 1) mod 2^28 = 0)

This curve is also implemented in [libff](https://github.com/scipr-lab/libff/tree/master/libff/algebra/curves/alt_bn128) under the name <code>bn128</code>.
It is the same as the <code>bn254</code> curve used in Ethereum (eg: [go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/crypto/bn254/cloudflare)).


<a id="@CAUTION_0"></a>

## CAUTION

**This curve does not satisfy the 128-bit security level anymore.**

Its current security is estimated at 128-bits (see "Updating Key Size Estimations for Pairings"; by Barbulescu, Razvan and Duquesne, Sylvain; in Journal of Cryptology; 2019; https://doi.org/10.1007/s00145-018-9280-5)


Curve information:
* Base field: q =
21888242871839275222246405745257275088696311157297823662689037894645226208583
* Scalar field: r =
21888242871839275222246405745257275088548364400416034343698204186575808495617
* valuation(q - 1, 2) = 1
* valuation(r - 1, 2) = 28
* G1 curve equation: y^2 = x^3 + 3
* G2 curve equation: y^2 = x^3 + B, where
* B = 3/(u+9) where Fq2 is represented as Fq\[u\]/(u^2+1) =
Fq2(19485874751759354771024239261021720505790618469301721065564631296452457478373,
266929791119991161246907387137283842545076965332900288569378510910307636690)


Currently-supported BN254 structures include <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq12">Fq12</a></code>, <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fr">Fr</a></code>, <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq">Fq</a></code>, <code>Fq2</code>, <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code>, <code><a href="bn254_algebra.md#0x1_bn254_algebra_G2">G2</a></code> and <code><a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a></code>,
along with their widely-used serialization formats,
the pairing between <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code>, <code><a href="bn254_algebra.md#0x1_bn254_algebra_G2">G2</a></code> and <code><a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a></code>.

Other unimplemented BN254 structures and serialization formats are also listed here,
as they help define some of the currently supported structures.
Their implementation may also be added in the future.

<code>Fq2</code>: The finite field $F_{q^2}$ that can be used as the base field of $G_2$
which is an extension field of <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq">Fq</a></code>, constructed as $F_{q^2}=F_{q}[u]/(u^2+1)$.

<code>FormatFq2LscLsb</code>: A serialization scheme for <code>Fq2</code> elements,
where an element $(c_0+c_1\cdot u)$ is represented by a byte array <code>b[]</code> of size N=64,
which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first.
- <code>b[0..32]</code> is $c_0$ serialized using <code>FormatFqLscLsb</code>.
- <code>b[32..64]</code> is $c_1$ serialized using <code>FormatFqLscLsb</code>.

<code>Fq6</code>: the finite field $F_{q^6}$ used in BN254 curves,
which is an extension field of <code>Fq2</code>, constructed as $F_{q^6}=F_{q^2}[v]/(v^3-u-9)$.

<code>FormatFq6LscLsb</code>: a serialization scheme for <code>Fq6</code> elements,
where an element in the form $(c_0+c_1\cdot v+c_2\cdot v^2)$ is represented by a byte array <code>b[]</code> of size 192,
which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first:
- <code>b[0..64]</code> is $c_0$ serialized using <code>FormatFq2LscLsb</code>.
- <code>b[64..128]</code> is $c_1$ serialized using <code>FormatFq2LscLsb</code>.
- <code>b[128..192]</code> is $c_2$ serialized using <code>FormatFq2LscLsb</code>.

<code>G1Full</code>: a group constructed by the points on the BN254 curve $E(F_q): y^2=x^3+3$ and the point at infinity,
under the elliptic curve point addition.
It contains the prime-order subgroup $G_1$ used in pairing.

<code>G2Full</code>: a group constructed by the points on a curve $E'(F_{q^2}): y^2=x^3+3/(u+9)$ and the point at infinity,
under the elliptic curve point addition.
It contains the prime-order subgroup $G_2$ used in pairing.


-  [CAUTION](#@CAUTION_0)
-  [Struct `Fr`](#0x1_bn254_algebra_Fr)
-  [Struct `FormatFrLsb`](#0x1_bn254_algebra_FormatFrLsb)
-  [Struct `FormatFrMsb`](#0x1_bn254_algebra_FormatFrMsb)
-  [Struct `Fq`](#0x1_bn254_algebra_Fq)
-  [Struct `FormatFqLsb`](#0x1_bn254_algebra_FormatFqLsb)
-  [Struct `FormatFqMsb`](#0x1_bn254_algebra_FormatFqMsb)
-  [Struct `Fq12`](#0x1_bn254_algebra_Fq12)
-  [Struct `FormatFq12LscLsb`](#0x1_bn254_algebra_FormatFq12LscLsb)
-  [Struct `G1`](#0x1_bn254_algebra_G1)
-  [Struct `FormatG1Uncompr`](#0x1_bn254_algebra_FormatG1Uncompr)
-  [Struct `FormatG1Compr`](#0x1_bn254_algebra_FormatG1Compr)
-  [Struct `G2`](#0x1_bn254_algebra_G2)
-  [Struct `FormatG2Uncompr`](#0x1_bn254_algebra_FormatG2Uncompr)
-  [Struct `FormatG2Compr`](#0x1_bn254_algebra_FormatG2Compr)
-  [Struct `Gt`](#0x1_bn254_algebra_Gt)
-  [Struct `FormatGt`](#0x1_bn254_algebra_FormatGt)


<pre><code></code></pre>



<a id="0x1_bn254_algebra_Fr"></a>

## Struct `Fr`

The finite field $F_r$ that can be used as the scalar fields
associated with the groups $G_1$, $G_2$, $G_t$ in BN254-based pairing.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_Fr">Fr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatFrLsb"></a>

## Struct `FormatFrLsb`

A serialization format for <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fr">Fr</a></code> elements,
where an element is represented by a byte array <code>b[]</code> of size 32 with the least significant byte (LSB) coming first.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatFrLsb">FormatFrLsb</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatFrMsb"></a>

## Struct `FormatFrMsb`

A serialization scheme for <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fr">Fr</a></code> elements,
where an element is represented by a byte array <code>b[]</code> of size 32 with the most significant byte (MSB) coming first.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatFrMsb">FormatFrMsb</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_Fq"></a>

## Struct `Fq`

The finite field $F_q$ that can be used as the base field of $G_1$


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_Fq">Fq</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatFqLsb"></a>

## Struct `FormatFqLsb`

A serialization format for <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq">Fq</a></code> elements,
where an element is represented by a byte array <code>b[]</code> of size 32 with the least significant byte (LSB) coming first.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatFqLsb">FormatFqLsb</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatFqMsb"></a>

## Struct `FormatFqMsb`

A serialization scheme for <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq">Fq</a></code> elements,
where an element is represented by a byte array <code>b[]</code> of size 32 with the most significant byte (MSB) coming first.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatFqMsb">FormatFqMsb</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_Fq12"></a>

## Struct `Fq12`

The finite field $F_{q^12}$ used in BN254 curves,
which is an extension field of <code>Fq6</code> (defined in the module documentation), constructed as $F_{q^12}=F_{q^6}[w]/(w^2-v)$.
The field can downcast to <code><a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a></code> if it's an element of the multiplicative subgroup <code><a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a></code> of <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq12">Fq12</a></code>
with a prime order $r$ = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_Fq12">Fq12</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatFq12LscLsb"></a>

## Struct `FormatFq12LscLsb`

A serialization scheme for <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq12">Fq12</a></code> elements,
where an element $(c_0+c_1\cdot w)$ is represented by a byte array <code>b[]</code> of size 384,
which is a concatenation of its coefficients serialized, with the least significant coefficient (LSC) coming first.
- <code>b[0..192]</code> is $c_0$ serialized using <code>FormatFq6LscLsb</code> (defined in the module documentation).
- <code>b[192..384]</code> is $c_1$ serialized using <code>FormatFq6LscLsb</code>.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatFq12LscLsb">FormatFq12LscLsb</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_G1"></a>

## Struct `G1`

The group $G_1$ in BN254-based pairing $G_1 \times G_2 \rightarrow G_t$.
It is a subgroup of <code>G1Full</code> (defined in the module documentation) with a prime order $r$
equal to 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.
(so <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fr">Fr</a></code> is the associated scalar field).


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatG1Uncompr"></a>

## Struct `FormatG1Uncompr`

A serialization scheme for <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> elements derived from arkworks.rs.

Below is the serialization procedure that takes a <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> element <code>p</code> and outputs a byte array of size N=64.
1. Let <code>(x,y)</code> be the coordinates of <code>p</code> if <code>p</code> is on the curve, or <code>(0,0)</code> otherwise.
1. Serialize <code>x</code> and <code>y</code> into <code>b_x[]</code> and <code>b_y[]</code> respectively using <code><a href="bn254_algebra.md#0x1_bn254_algebra_FormatFqLsb">FormatFqLsb</a></code> (defined in the module documentation).
1. Concatenate <code>b_x[]</code> and <code>b_y[]</code> into <code>b[]</code>.
1. If <code>p</code> is the point at infinity, set the infinity bit: <code>b[N-1]: = b[N-1] | 0b0100_0000</code>.
1. If <code>y &gt; -y</code>, set the lexicographical bit:  <code>b[N-1]: = b[N-1] | 0b1000_0000</code>.
1. Return <code>b[]</code>.

Below is the deserialization procedure that takes a byte array <code>b[]</code> and outputs either a <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> element or none.
1. If the size of <code>b[]</code> is not N, return none.
1. Compute the infinity flag as <code>b[N-1] & 0b0100_0000 != 0</code>.
1. If the infinity flag is set, return the point at infinity.
1. Deserialize <code>[b[0], b[1], ..., b[N/2-1]]</code> to <code>x</code> using <code><a href="bn254_algebra.md#0x1_bn254_algebra_FormatFqLsb">FormatFqLsb</a></code>. If <code>x</code> is none, return none.
1. Deserialize <code>[b[N/2], ..., b[N] & 0b0011_1111]</code> to <code>y</code> using <code><a href="bn254_algebra.md#0x1_bn254_algebra_FormatFqLsb">FormatFqLsb</a></code>. If <code>y</code> is none, return none.
1. Check if <code>(x,y)</code> is on curve <code>E</code>. If not, return none.
1. Check if <code>(x,y)</code> is in the subgroup of order <code>r</code>. If not, return none.
1. Return <code>(x,y)</code>.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatG1Uncompr">FormatG1Uncompr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatG1Compr"></a>

## Struct `FormatG1Compr`

A serialization scheme for <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> elements derived from arkworks.rs

Below is the serialization procedure that takes a <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> element <code>p</code> and outputs a byte array of size N=32.
1. Let <code>(x,y)</code> be the coordinates of <code>p</code> if <code>p</code> is on the curve, or <code>(0,0)</code> otherwise.
1. Serialize <code>x</code> into <code>b[]</code> using <code><a href="bn254_algebra.md#0x1_bn254_algebra_FormatFqLsb">FormatFqLsb</a></code> (defined in the module documentation).
1. If <code>p</code> is the point at infinity, set the infinity bit: <code>b[N-1]: = b[N-1] | 0b0100_0000</code>.
1. If <code>y &gt; -y</code>, set the lexicographical flag: <code>b[N-1] := b[N-1] | 0x1000_0000</code>.
1. Return <code>b[]</code>.

Below is the deserialization procedure that takes a byte array <code>b[]</code> and outputs either a <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> element or none.
1. If the size of <code>b[]</code> is not N, return none.
1. Compute the infinity flag as <code>b[N-1] & 0b0100_0000 != 0</code>.
1. If the infinity flag is set, return the point at infinity.
1. Compute the lexicographical flag as <code>b[N-1] & 0b1000_0000 != 0</code>.
1. Deserialize <code>[b[0], b[1], ..., b[N/2-1] & 0b0011_1111]</code> to <code>x</code> using <code><a href="bn254_algebra.md#0x1_bn254_algebra_FormatFqLsb">FormatFqLsb</a></code>. If <code>x</code> is none, return none.
1. Solve the curve equation with <code>x</code> for <code>y</code>. If no such <code>y</code> exists, return none.
1. Let <code>y'</code> be <code>max(y,-y)</code> if the lexicographical flag is set, or <code><b>min</b>(y,-y)</code> otherwise.
1. Check if <code>(x,y')</code> is in the subgroup of order <code>r</code>. If not, return none.
1. Return <code>(x,y')</code>.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatG1Compr">FormatG1Compr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_G2"></a>

## Struct `G2`

The group $G_2$ in BN254-based pairing $G_1 \times G_2 \rightarrow G_t$.
It is a subgroup of <code>G2Full</code> (defined in the module documentation) with a prime order $r$ equal to
0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.
(so <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fr">Fr</a></code> is the scalar field).


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_G2">G2</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatG2Uncompr"></a>

## Struct `FormatG2Uncompr`

A serialization scheme for <code><a href="bn254_algebra.md#0x1_bn254_algebra_G2">G2</a></code> elements derived from arkworks.rs.

Below is the serialization procedure that takes a <code><a href="bn254_algebra.md#0x1_bn254_algebra_G2">G2</a></code> element <code>p</code> and outputs a byte array of size N=128.
1. Let <code>(x,y)</code> be the coordinates of <code>p</code> if <code>p</code> is on the curve, or <code>(0,0)</code> otherwise.
1. Serialize <code>x</code> and <code>y</code> into <code>b_x[]</code> and <code>b_y[]</code> respectively using <code>FormatFq2LscLsb</code> (defined in the module documentation).
1. Concatenate <code>b_x[]</code> and <code>b_y[]</code> into <code>b[]</code>.
1. If <code>p</code> is the point at infinity, set the infinity bit: <code>b[N-1]: = b[N-1] | 0b0100_0000</code>.
1. If <code>y &gt; -y</code>, set the lexicographical bit:  <code>b[N-1]: = b[N-1] | 0b1000_0000</code>.
1. Return <code>b[]</code>.

Below is the deserialization procedure that takes a byte array <code>b[]</code> and outputs either a <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> element or none.
1. If the size of <code>b[]</code> is not N, return none.
1. Compute the infinity flag as <code>b[N-1] & 0b0100_0000 != 0</code>.
1. If the infinity flag is set, return the point at infinity.
1. Deserialize <code>[b[0], b[1], ..., b[N/2-1]]</code> to <code>x</code> using <code>FormatFq2LscLsb</code>. If <code>x</code> is none, return none.
1. Deserialize <code>[b[N/2], ..., b[N] & 0b0011_1111]</code> to <code>y</code> using <code>FormatFq2LscLsb</code>. If <code>y</code> is none, return none.
1. Check if <code>(x,y)</code> is on curve <code>E</code>. If not, return none.
1. Check if <code>(x,y)</code> is in the subgroup of order <code>r</code>. If not, return none.
1. Return <code>(x,y)</code>.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatG2Uncompr">FormatG2Uncompr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatG2Compr"></a>

## Struct `FormatG2Compr`

A serialization scheme for <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> elements derived from arkworks.rs

Below is the serialization procedure that takes a <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> element <code>p</code> and outputs a byte array of size N=64.
1. Let <code>(x,y)</code> be the coordinates of <code>p</code> if <code>p</code> is on the curve, or <code>(0,0)</code> otherwise.
1. Serialize <code>x</code> into <code>b[]</code> using <code>FormatFq2LscLsb</code> (defined in the module documentation).
1. If <code>p</code> is the point at infinity, set the infinity bit: <code>b[N-1]: = b[N-1] | 0b0100_0000</code>.
1. If <code>y &gt; -y</code>, set the lexicographical flag: <code>b[N-1] := b[N-1] | 0x1000_0000</code>.
1. Return <code>b[]</code>.

Below is the deserialization procedure that takes a byte array <code>b[]</code> and outputs either a <code><a href="bn254_algebra.md#0x1_bn254_algebra_G1">G1</a></code> element or none.
1. If the size of <code>b[]</code> is not N, return none.
1. Compute the infinity flag as <code>b[N-1] & 0b0100_0000 != 0</code>.
1. If the infinity flag is set, return the point at infinity.
1. Compute the lexicographical flag as <code>b[N-1] & 0b1000_0000 != 0</code>.
1. Deserialize <code>[b[0], b[1], ..., b[N/2-1] & 0b0011_1111]</code> to <code>x</code> using <code>FormatFq2LscLsb</code>. If <code>x</code> is none, return none.
1. Solve the curve equation with <code>x</code> for <code>y</code>. If no such <code>y</code> exists, return none.
1. Let <code>y'</code> be <code>max(y,-y)</code> if the lexicographical flag is set, or <code><b>min</b>(y,-y)</code> otherwise.
1. Check if <code>(x,y')</code> is in the subgroup of order <code>r</code>. If not, return none.
1. Return <code>(x,y')</code>.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatG2Compr">FormatG2Compr</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_Gt"></a>

## Struct `Gt`

The group $G_t$ in BN254-based pairing $G_1 \times G_2 \rightarrow G_t$.
It is a multiplicative subgroup of <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq12">Fq12</a></code>, so it  can upcast to <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq12">Fq12</a></code>.
with a prime order $r$ equal to 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001.
(so <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fr">Fr</a></code> is the scalar field).
The identity of <code><a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a></code> is 1.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_bn254_algebra_FormatGt"></a>

## Struct `FormatGt`

A serialization scheme for <code><a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a></code> elements.

To serialize, it treats a <code><a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a></code> element <code>p</code> as an <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq12">Fq12</a></code> element and serialize it using <code><a href="bn254_algebra.md#0x1_bn254_algebra_FormatFq12LscLsb">FormatFq12LscLsb</a></code>.

To deserialize, it uses <code><a href="bn254_algebra.md#0x1_bn254_algebra_FormatFq12LscLsb">FormatFq12LscLsb</a></code> to try deserializing to an <code><a href="bn254_algebra.md#0x1_bn254_algebra_Fq12">Fq12</a></code> element then test the membership in <code><a href="bn254_algebra.md#0x1_bn254_algebra_Gt">Gt</a></code>.

NOTE: other implementation(s) using this format: ark-bn254-0.4.0.


<pre><code><b>struct</b> <a href="bn254_algebra.md#0x1_bn254_algebra_FormatGt">FormatGt</a>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/capability.md
================================================

<a id="0x1_capability"></a>

# Module `0x1::capability`

A module which defines the basic concept of
[*capabilities*](https://en.wikipedia.org/wiki/Capability-based_security) for managing access control.

EXPERIMENTAL


<a id="@Overview_0"></a>

## Overview


A capability is a unforgeable token which testifies that a signer has authorized a certain operation.
The token is valid during the transaction where it is obtained. Since the type <code><a href="capability.md#0x1_capability_Cap">capability::Cap</a></code> has
no ability to be stored in global memory, capabilities cannot leak out of a transaction. For every function
called within a transaction which has a capability as a parameter, it is guaranteed that the capability
has been obtained via a proper signer-based authorization step previously in the transaction's execution.


<a id="@Usage_1"></a>

### Usage


Initializing and acquiring capabilities is usually encapsulated in a module with a type
tag which can only be constructed by this module.

```
module Pkg::Feature {
use std::capability::Cap;

/// A type tag used in Cap<Feature>. Only this module can create an instance,
/// and there is no public function other than Self::acquire which returns a value of this type.
/// This way, this module has full control how Cap<Feature> is given out.
struct Feature has drop {}

/// Initializes this module.
public fun initialize(s: &signer) {
// Create capability. This happens once at module initialization time.
// One needs to provide a witness for being the owner of Feature
// in the 2nd parameter.
<<additional conditions allowing to initialize this capability>>
capability::create<Feature>(s, &Feature{});
}

/// Acquires the capability to work with this feature.
public fun acquire(s: &signer): Cap<Feature> {
<<additional conditions allowing to acquire this capability>>
capability::acquire<Feature>(s, &Feature{});
}

/// Does something related to the feature. The caller must pass a Cap<Feature>.
public fun do_something(_cap: Cap<Feature>) { ... }
}
```


<a id="@Delegation_2"></a>

### Delegation


Capabilities come with the optional feature of *delegation*. Via <code><a href="capability.md#0x1_capability_delegate">Self::delegate</a></code>, an owner of a capability
can designate another signer to be also capable of acquiring the capability. Like the original creator,
the delegate needs to present his signer to obtain the capability in his transactions. Delegation can
be revoked via <code><a href="capability.md#0x1_capability_revoke">Self::revoke</a></code>, removing this access right from the delegate.

While the basic authorization mechanism for delegates is the same as with core capabilities, the
target of delegation might be subject of restrictions which need to be specified and verified. This can
be done via global invariants in the specification language. For example, in order to prevent delegation
all together for a capability, one can use the following invariant:

```
invariant forall a: address where capability::spec_has_cap<Feature>(a):
len(capability::spec_delegates<Feature>(a)) == 0;
```

Similarly, the following invariant would enforce that delegates, if existent, must satisfy a certain
predicate:

```
invariant forall a: address where capability::spec_has_cap<Feature>(a):
forall d in capability::spec_delegates<Feature>(a):
is_valid_delegate_for_feature(d);
```


-  [Overview](#@Overview_0)
    -  [Usage](#@Usage_1)
    -  [Delegation](#@Delegation_2)
-  [Struct `Cap`](#0x1_capability_Cap)
-  [Struct `LinearCap`](#0x1_capability_LinearCap)
-  [Resource `CapState`](#0x1_capability_CapState)
-  [Resource `CapDelegateState`](#0x1_capability_CapDelegateState)
-  [Constants](#@Constants_3)
-  [Function `create`](#0x1_capability_create)
-  [Function `acquire`](#0x1_capability_acquire)
-  [Function `acquire_linear`](#0x1_capability_acquire_linear)
-  [Function `validate_acquire`](#0x1_capability_validate_acquire)
-  [Function `root_addr`](#0x1_capability_root_addr)
-  [Function `linear_root_addr`](#0x1_capability_linear_root_addr)
-  [Function `delegate`](#0x1_capability_delegate)
-  [Function `revoke`](#0x1_capability_revoke)
-  [Function `remove_element`](#0x1_capability_remove_element)
-  [Function `add_element`](#0x1_capability_add_element)
-  [Specification](#@Specification_4)
    -  [Function `create`](#@Specification_4_create)
    -  [Function `acquire`](#@Specification_4_acquire)
    -  [Function `acquire_linear`](#@Specification_4_acquire_linear)
    -  [Function `delegate`](#@Specification_4_delegate)
    -  [Function `revoke`](#@Specification_4_revoke)
    -  [Function `remove_element`](#@Specification_4_remove_element)
    -  [Function `add_element`](#@Specification_4_add_element)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/signer.md#0x1_signer">0x1::signer</a>;
<b>use</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">0x1::vector</a>;
</code></pre>



<a id="0x1_capability_Cap"></a>

## Struct `Cap`

The token representing an acquired capability. Cannot be stored in memory, but copied and dropped freely.


<pre><code><b>struct</b> <a href="capability.md#0x1_capability_Cap">Cap</a>&lt;Feature&gt; <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>root: <b>address</b></code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_capability_LinearCap"></a>

## Struct `LinearCap`

A linear version of a capability token. This can be used if an acquired capability should be enforced
to be used only once for an authorization.


<pre><code><b>struct</b> <a href="capability.md#0x1_capability_LinearCap">LinearCap</a>&lt;Feature&gt; <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>root: <b>address</b></code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_capability_CapState"></a>

## Resource `CapState`

An internal data structure for representing a configured capability.


<pre><code><b>struct</b> <a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt; <b>has</b> key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>delegates: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;<b>address</b>&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_capability_CapDelegateState"></a>

## Resource `CapDelegateState`

An internal data structure for representing a configured delegated capability.


<pre><code><b>struct</b> <a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt; <b>has</b> key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>root: <b>address</b></code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_3"></a>

## Constants


<a id="0x1_capability_ECAPABILITY_ALREADY_EXISTS"></a>

Capability resource already exists on the specified account


<pre><code><b>const</b> <a href="capability.md#0x1_capability_ECAPABILITY_ALREADY_EXISTS">ECAPABILITY_ALREADY_EXISTS</a>: u64 = 1;
</code></pre>



<a id="0x1_capability_ECAPABILITY_NOT_FOUND"></a>

Capability resource not found


<pre><code><b>const</b> <a href="capability.md#0x1_capability_ECAPABILITY_NOT_FOUND">ECAPABILITY_NOT_FOUND</a>: u64 = 2;
</code></pre>



<a id="0x1_capability_EDELEGATE"></a>

Account does not have delegated permissions


<pre><code><b>const</b> <a href="capability.md#0x1_capability_EDELEGATE">EDELEGATE</a>: u64 = 3;
</code></pre>



<a id="0x1_capability_create"></a>

## Function `create`

Creates a new capability class, owned by the passed signer. A caller must pass a witness that
they own the <code>Feature</code> type parameter.


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_create">create</a>&lt;Feature&gt;(owner: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_create">create</a>&lt;Feature&gt;(owner: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature) {
    <b>let</b> addr = <a href="../../move-stdlib/doc/signer.md#0x1_signer_address_of">signer::address_of</a>(owner);
    <b>assert</b>!(!<b>exists</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(addr), <a href="../../move-stdlib/doc/error.md#0x1_error_already_exists">error::already_exists</a>(<a href="capability.md#0x1_capability_ECAPABILITY_ALREADY_EXISTS">ECAPABILITY_ALREADY_EXISTS</a>));
    <b>move_to</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(owner, <a href="capability.md#0x1_capability_CapState">CapState</a> { delegates: <a href="../../move-stdlib/doc/vector.md#0x1_vector_empty">vector::empty</a>() });
}
</code></pre>



</details>

<a id="0x1_capability_acquire"></a>

## Function `acquire`

Acquires a capability token. Only the owner of the capability class, or an authorized delegate,
can succeed with this operation. A caller must pass a witness that they own the <code>Feature</code> type
parameter.


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_acquire">acquire</a>&lt;Feature&gt;(requester: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature): <a href="capability.md#0x1_capability_Cap">capability::Cap</a>&lt;Feature&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_acquire">acquire</a>&lt;Feature&gt;(requester: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature): <a href="capability.md#0x1_capability_Cap">Cap</a>&lt;Feature&gt;
<b>acquires</b> <a href="capability.md#0x1_capability_CapState">CapState</a>, <a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a> {
    <a href="capability.md#0x1_capability_Cap">Cap</a>&lt;Feature&gt; { root: <a href="capability.md#0x1_capability_validate_acquire">validate_acquire</a>&lt;Feature&gt;(requester) }
}
</code></pre>



</details>

<a id="0x1_capability_acquire_linear"></a>

## Function `acquire_linear`

Acquires a linear capability token. It is up to the module which owns <code>Feature</code> to decide
whether to expose a linear or non-linear capability.


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_acquire_linear">acquire_linear</a>&lt;Feature&gt;(requester: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature): <a href="capability.md#0x1_capability_LinearCap">capability::LinearCap</a>&lt;Feature&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_acquire_linear">acquire_linear</a>&lt;Feature&gt;(requester: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature): <a href="capability.md#0x1_capability_LinearCap">LinearCap</a>&lt;Feature&gt;
<b>acquires</b> <a href="capability.md#0x1_capability_CapState">CapState</a>, <a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a> {
    <a href="capability.md#0x1_capability_LinearCap">LinearCap</a>&lt;Feature&gt; { root: <a href="capability.md#0x1_capability_validate_acquire">validate_acquire</a>&lt;Feature&gt;(requester) }
}
</code></pre>



</details>

<a id="0x1_capability_validate_acquire"></a>

## Function `validate_acquire`

Helper to validate an acquire. Returns the root address of the capability.


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_validate_acquire">validate_acquire</a>&lt;Feature&gt;(requester: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_validate_acquire">validate_acquire</a>&lt;Feature&gt;(requester: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>): <b>address</b>
<b>acquires</b> <a href="capability.md#0x1_capability_CapState">CapState</a>, <a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a> {
    <b>let</b> addr = <a href="../../move-stdlib/doc/signer.md#0x1_signer_address_of">signer::address_of</a>(requester);
    <b>if</b> (<b>exists</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(addr)) {
        <b>let</b> root_addr = <b>borrow_global</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(addr).root;
        // double check that requester is actually registered <b>as</b> a delegate
        <b>assert</b>!(<b>exists</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(root_addr), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_state">error::invalid_state</a>(<a href="capability.md#0x1_capability_EDELEGATE">EDELEGATE</a>));
        <b>assert</b>!(<a href="../../move-stdlib/doc/vector.md#0x1_vector_contains">vector::contains</a>(&<b>borrow_global</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(root_addr).delegates, &addr),
            <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_state">error::invalid_state</a>(<a href="capability.md#0x1_capability_EDELEGATE">EDELEGATE</a>));
        root_addr
    } <b>else</b> {
        <b>assert</b>!(<b>exists</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(addr), <a href="../../move-stdlib/doc/error.md#0x1_error_not_found">error::not_found</a>(<a href="capability.md#0x1_capability_ECAPABILITY_NOT_FOUND">ECAPABILITY_NOT_FOUND</a>));
        addr
    }
}
</code></pre>



</details>

<a id="0x1_capability_root_addr"></a>

## Function `root_addr`

Returns the root address associated with the given capability token. Only the owner
of the feature can do this.


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_root_addr">root_addr</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_Cap">capability::Cap</a>&lt;Feature&gt;, _feature_witness: &Feature): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_root_addr">root_addr</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_Cap">Cap</a>&lt;Feature&gt;, _feature_witness: &Feature): <b>address</b> {
    cap.root
}
</code></pre>



</details>

<a id="0x1_capability_linear_root_addr"></a>

## Function `linear_root_addr`

Returns the root address associated with the given linear capability token.


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_linear_root_addr">linear_root_addr</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_LinearCap">capability::LinearCap</a>&lt;Feature&gt;, _feature_witness: &Feature): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_linear_root_addr">linear_root_addr</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_LinearCap">LinearCap</a>&lt;Feature&gt;, _feature_witness: &Feature): <b>address</b> {
    cap.root
}
</code></pre>



</details>

<a id="0x1_capability_delegate"></a>

## Function `delegate`

Registers a delegation relation. If the relation already exists, this function does
nothing.


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_delegate">delegate</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_Cap">capability::Cap</a>&lt;Feature&gt;, _feature_witness: &Feature, <b>to</b>: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_delegate">delegate</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_Cap">Cap</a>&lt;Feature&gt;, _feature_witness: &Feature, <b>to</b>: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>)
<b>acquires</b> <a href="capability.md#0x1_capability_CapState">CapState</a> {
    <b>let</b> addr = <a href="../../move-stdlib/doc/signer.md#0x1_signer_address_of">signer::address_of</a>(<b>to</b>);
    <b>if</b> (<b>exists</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(addr)) <b>return</b>;
    <b>move_to</b>(<b>to</b>, <a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt; { root: cap.root });
    <a href="capability.md#0x1_capability_add_element">add_element</a>(&<b>mut</b> <b>borrow_global_mut</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(cap.root).delegates, addr);
}
</code></pre>



</details>

<a id="0x1_capability_revoke"></a>

## Function `revoke`

Revokes a delegation relation. If no relation exists, this function does nothing.


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_revoke">revoke</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_Cap">capability::Cap</a>&lt;Feature&gt;, _feature_witness: &Feature, from: <b>address</b>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_revoke">revoke</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_Cap">Cap</a>&lt;Feature&gt;, _feature_witness: &Feature, from: <b>address</b>)
<b>acquires</b> <a href="capability.md#0x1_capability_CapState">CapState</a>, <a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>
{
    <b>if</b> (!<b>exists</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(from)) <b>return</b>;
    <b>let</b> <a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a> { root: _root } = <b>move_from</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(from);
    <a href="capability.md#0x1_capability_remove_element">remove_element</a>(&<b>mut</b> <b>borrow_global_mut</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(cap.root).delegates, &from);
}
</code></pre>



</details>

<a id="0x1_capability_remove_element"></a>

## Function `remove_element`

Helper to remove an element from a vector.


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_remove_element">remove_element</a>&lt;E: drop&gt;(v: &<b>mut</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;E&gt;, x: &E)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_remove_element">remove_element</a>&lt;E: drop&gt;(v: &<b>mut</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;E&gt;, x: &E) {
    <b>let</b> (found, index) = <a href="../../move-stdlib/doc/vector.md#0x1_vector_index_of">vector::index_of</a>(v, x);
    <b>if</b> (found) {
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_remove">vector::remove</a>(v, index);
    }
}
</code></pre>



</details>

<a id="0x1_capability_add_element"></a>

## Function `add_element`

Helper to add an element to a vector.


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_add_element">add_element</a>&lt;E: drop&gt;(v: &<b>mut</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;E&gt;, x: E)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_add_element">add_element</a>&lt;E: drop&gt;(v: &<b>mut</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;E&gt;, x: E) {
    <b>if</b> (!<a href="../../move-stdlib/doc/vector.md#0x1_vector_contains">vector::contains</a>(v, &x)) {
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(v, x)
    }
}
</code></pre>



</details>

<a id="@Specification_4"></a>

## Specification

Helper specification function to check whether a capability exists at address.


<a id="0x1_capability_spec_has_cap"></a>


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_spec_has_cap">spec_has_cap</a>&lt;Feature&gt;(addr: <b>address</b>): bool {
   <b>exists</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(addr)
}
</code></pre>


Helper specification function to obtain the delegates of a capability.


<a id="0x1_capability_spec_delegates"></a>


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_spec_delegates">spec_delegates</a>&lt;Feature&gt;(addr: <b>address</b>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;<b>address</b>&gt; {
   <b>global</b>&lt;<a href="capability.md#0x1_capability_CapState">CapState</a>&lt;Feature&gt;&gt;(addr).delegates
}
</code></pre>


Helper specification function to check whether a delegated capability exists at address.


<a id="0x1_capability_spec_has_delegate_cap"></a>


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr: <b>address</b>): bool {
   <b>exists</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(addr)
}
</code></pre>



<a id="@Specification_4_create"></a>

### Function `create`


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_create">create</a>&lt;Feature&gt;(owner: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature)
</code></pre>




<pre><code><b>let</b> addr = <a href="../../move-stdlib/doc/signer.md#0x1_signer_address_of">signer::address_of</a>(owner);
<b>aborts_if</b> <a href="capability.md#0x1_capability_spec_has_cap">spec_has_cap</a>&lt;Feature&gt;(addr);
<b>ensures</b> <a href="capability.md#0x1_capability_spec_has_cap">spec_has_cap</a>&lt;Feature&gt;(addr);
</code></pre>



<a id="@Specification_4_acquire"></a>

### Function `acquire`


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_acquire">acquire</a>&lt;Feature&gt;(requester: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature): <a href="capability.md#0x1_capability_Cap">capability::Cap</a>&lt;Feature&gt;
</code></pre>




<pre><code><b>let</b> addr = <a href="../../move-stdlib/doc/signer.md#0x1_signer_address_of">signer::address_of</a>(requester);
<b>let</b> root_addr = <b>global</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(addr).root;
<b>include</b> <a href="capability.md#0x1_capability_AcquireSchema">AcquireSchema</a>&lt;Feature&gt;;
<b>ensures</b> <a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr) ==&gt; result.root == root_addr;
<b>ensures</b> !<a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr) ==&gt; result.root == addr;
</code></pre>



<a id="@Specification_4_acquire_linear"></a>

### Function `acquire_linear`


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_acquire_linear">acquire_linear</a>&lt;Feature&gt;(requester: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>, _feature_witness: &Feature): <a href="capability.md#0x1_capability_LinearCap">capability::LinearCap</a>&lt;Feature&gt;
</code></pre>




<pre><code><b>let</b> addr = <a href="../../move-stdlib/doc/signer.md#0x1_signer_address_of">signer::address_of</a>(requester);
<b>let</b> root_addr = <b>global</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(addr).root;
<b>include</b> <a href="capability.md#0x1_capability_AcquireSchema">AcquireSchema</a>&lt;Feature&gt;;
<b>ensures</b> <a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr) ==&gt; result.root == root_addr;
<b>ensures</b> !<a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr) ==&gt; result.root == addr;
</code></pre>




<a id="0x1_capability_AcquireSchema"></a>


<pre><code><b>schema</b> <a href="capability.md#0x1_capability_AcquireSchema">AcquireSchema</a>&lt;Feature&gt; {
    addr: <b>address</b>;
    root_addr: <b>address</b>;
    <b>aborts_if</b> <a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr) && !<a href="capability.md#0x1_capability_spec_has_cap">spec_has_cap</a>&lt;Feature&gt;(root_addr);
    <b>aborts_if</b> <a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr) && !<a href="../../move-stdlib/doc/vector.md#0x1_vector_spec_contains">vector::spec_contains</a>(<a href="capability.md#0x1_capability_spec_delegates">spec_delegates</a>&lt;Feature&gt;(root_addr), addr);
    <b>aborts_if</b> !<a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr) && !<a href="capability.md#0x1_capability_spec_has_cap">spec_has_cap</a>&lt;Feature&gt;(addr);
}
</code></pre>



<a id="@Specification_4_delegate"></a>

### Function `delegate`


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_delegate">delegate</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_Cap">capability::Cap</a>&lt;Feature&gt;, _feature_witness: &Feature, <b>to</b>: &<a href="../../move-stdlib/doc/signer.md#0x1_signer">signer</a>)
</code></pre>




<pre><code><b>let</b> addr = <a href="../../move-stdlib/doc/signer.md#0x1_signer_address_of">signer::address_of</a>(<b>to</b>);
<b>ensures</b> <a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr);
<b>ensures</b> !<b>old</b>(<a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr)) ==&gt; <b>global</b>&lt;<a href="capability.md#0x1_capability_CapDelegateState">CapDelegateState</a>&lt;Feature&gt;&gt;(addr).root == cap.root;
<b>ensures</b> !<b>old</b>(<a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(addr)) ==&gt; <a href="../../move-stdlib/doc/vector.md#0x1_vector_spec_contains">vector::spec_contains</a>(<a href="capability.md#0x1_capability_spec_delegates">spec_delegates</a>&lt;Feature&gt;(cap.root), addr);
</code></pre>



<a id="@Specification_4_revoke"></a>

### Function `revoke`


<pre><code><b>public</b> <b>fun</b> <a href="capability.md#0x1_capability_revoke">revoke</a>&lt;Feature&gt;(cap: <a href="capability.md#0x1_capability_Cap">capability::Cap</a>&lt;Feature&gt;, _feature_witness: &Feature, from: <b>address</b>)
</code></pre>




<pre><code><b>ensures</b> !<a href="capability.md#0x1_capability_spec_has_delegate_cap">spec_has_delegate_cap</a>&lt;Feature&gt;(from);
</code></pre>



<a id="@Specification_4_remove_element"></a>

### Function `remove_element`


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_remove_element">remove_element</a>&lt;E: drop&gt;(v: &<b>mut</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;E&gt;, x: &E)
</code></pre>




<a id="@Specification_4_add_element"></a>

### Function `add_element`


<pre><code><b>fun</b> <a href="capability.md#0x1_capability_add_element">add_element</a>&lt;E: drop&gt;(v: &<b>mut</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;E&gt;, x: E)
</code></pre>




<pre><code><b>ensures</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector_spec_contains">vector::spec_contains</a>(v, x);
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/comparator.md
================================================

<a id="0x1_comparator"></a>

# Module `0x1::comparator`

Provides a framework for comparing two elements


-  [Struct `Result`](#0x1_comparator_Result)
-  [Constants](#@Constants_0)
-  [Function `is_equal`](#0x1_comparator_is_equal)
-  [Function `is_smaller_than`](#0x1_comparator_is_smaller_than)
-  [Function `is_greater_than`](#0x1_comparator_is_greater_than)
-  [Function `compare`](#0x1_comparator_compare)
-  [Function `compare_u8_vector`](#0x1_comparator_compare_u8_vector)
-  [Specification](#@Specification_1)
    -  [Struct `Result`](#@Specification_1_Result)
    -  [Function `is_equal`](#@Specification_1_is_equal)
    -  [Function `is_smaller_than`](#@Specification_1_is_smaller_than)
    -  [Function `is_greater_than`](#@Specification_1_is_greater_than)
    -  [Function `compare`](#@Specification_1_compare)
    -  [Function `compare_u8_vector`](#@Specification_1_compare_u8_vector)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/bcs.md#0x1_bcs">0x1::bcs</a>;
</code></pre>



<a id="0x1_comparator_Result"></a>

## Struct `Result`



<pre><code><b>struct</b> <a href="comparator.md#0x1_comparator_Result">Result</a> <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>inner: u8</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_comparator_EQUAL"></a>



<pre><code><b>const</b> <a href="comparator.md#0x1_comparator_EQUAL">EQUAL</a>: u8 = 0;
</code></pre>



<a id="0x1_comparator_GREATER"></a>



<pre><code><b>const</b> <a href="comparator.md#0x1_comparator_GREATER">GREATER</a>: u8 = 2;
</code></pre>



<a id="0x1_comparator_SMALLER"></a>



<pre><code><b>const</b> <a href="comparator.md#0x1_comparator_SMALLER">SMALLER</a>: u8 = 1;
</code></pre>



<a id="0x1_comparator_is_equal"></a>

## Function `is_equal`



<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_equal">is_equal</a>(result: &<a href="comparator.md#0x1_comparator_Result">comparator::Result</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_equal">is_equal</a>(result: &<a href="comparator.md#0x1_comparator_Result">Result</a>): bool {
    result.inner == <a href="comparator.md#0x1_comparator_EQUAL">EQUAL</a>
}
</code></pre>



</details>

<a id="0x1_comparator_is_smaller_than"></a>

## Function `is_smaller_than`



<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_smaller_than">is_smaller_than</a>(result: &<a href="comparator.md#0x1_comparator_Result">comparator::Result</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_smaller_than">is_smaller_than</a>(result: &<a href="comparator.md#0x1_comparator_Result">Result</a>): bool {
    result.inner == <a href="comparator.md#0x1_comparator_SMALLER">SMALLER</a>
}
</code></pre>



</details>

<a id="0x1_comparator_is_greater_than"></a>

## Function `is_greater_than`



<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_greater_than">is_greater_than</a>(result: &<a href="comparator.md#0x1_comparator_Result">comparator::Result</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_greater_than">is_greater_than</a>(result: &<a href="comparator.md#0x1_comparator_Result">Result</a>): bool {
    result.inner == <a href="comparator.md#0x1_comparator_GREATER">GREATER</a>
}
</code></pre>



</details>

<a id="0x1_comparator_compare"></a>

## Function `compare`



<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_compare">compare</a>&lt;T&gt;(left: &T, right: &T): <a href="comparator.md#0x1_comparator_Result">comparator::Result</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_compare">compare</a>&lt;T&gt;(left: &T, right: &T): <a href="comparator.md#0x1_comparator_Result">Result</a> {
    <b>let</b> left_bytes = <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a>(left);
    <b>let</b> right_bytes = <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a>(right);

    <a href="comparator.md#0x1_comparator_compare_u8_vector">compare_u8_vector</a>(left_bytes, right_bytes)
}
</code></pre>



</details>

<a id="0x1_comparator_compare_u8_vector"></a>

## Function `compare_u8_vector`



<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_compare_u8_vector">compare_u8_vector</a>(left: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, right: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="comparator.md#0x1_comparator_Result">comparator::Result</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_compare_u8_vector">compare_u8_vector</a>(left: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, right: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="comparator.md#0x1_comparator_Result">Result</a> {
    <b>let</b> left_length = <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&left);
    <b>let</b> right_length = <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&right);

    <b>let</b> idx = 0;

    <b>while</b> (idx &lt; left_length && idx &lt; right_length) {
        <b>let</b> left_byte = *<a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(&left, idx);
        <b>let</b> right_byte = *<a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(&right, idx);

        <b>if</b> (left_byte &lt; right_byte) {
            <b>return</b> <a href="comparator.md#0x1_comparator_Result">Result</a> { inner: <a href="comparator.md#0x1_comparator_SMALLER">SMALLER</a> }
        } <b>else</b> <b>if</b> (left_byte &gt; right_byte) {
            <b>return</b> <a href="comparator.md#0x1_comparator_Result">Result</a> { inner: <a href="comparator.md#0x1_comparator_GREATER">GREATER</a> }
        };
        idx = idx + 1;
    };

    <b>if</b> (left_length &lt; right_length) {
        <a href="comparator.md#0x1_comparator_Result">Result</a> { inner: <a href="comparator.md#0x1_comparator_SMALLER">SMALLER</a> }
    } <b>else</b> <b>if</b> (left_length &gt; right_length) {
        <a href="comparator.md#0x1_comparator_Result">Result</a> { inner: <a href="comparator.md#0x1_comparator_GREATER">GREATER</a> }
    } <b>else</b> {
        <a href="comparator.md#0x1_comparator_Result">Result</a> { inner: <a href="comparator.md#0x1_comparator_EQUAL">EQUAL</a> }
    }
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_Result"></a>

### Struct `Result`


<pre><code><b>struct</b> <a href="comparator.md#0x1_comparator_Result">Result</a> <b>has</b> drop
</code></pre>



<dl>
<dt>
<code>inner: u8</code>
</dt>
<dd>

</dd>
</dl>



<pre><code><b>invariant</b> inner == <a href="comparator.md#0x1_comparator_EQUAL">EQUAL</a> || inner == <a href="comparator.md#0x1_comparator_SMALLER">SMALLER</a> || inner == <a href="comparator.md#0x1_comparator_GREATER">GREATER</a>;
</code></pre>



<a id="@Specification_1_is_equal"></a>

### Function `is_equal`


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_equal">is_equal</a>(result: &<a href="comparator.md#0x1_comparator_Result">comparator::Result</a>): bool
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>let</b> res = result;
<b>ensures</b> result == (res.inner == <a href="comparator.md#0x1_comparator_EQUAL">EQUAL</a>);
</code></pre>



<a id="@Specification_1_is_smaller_than"></a>

### Function `is_smaller_than`


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_smaller_than">is_smaller_than</a>(result: &<a href="comparator.md#0x1_comparator_Result">comparator::Result</a>): bool
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>let</b> res = result;
<b>ensures</b> result == (res.inner == <a href="comparator.md#0x1_comparator_SMALLER">SMALLER</a>);
</code></pre>



<a id="@Specification_1_is_greater_than"></a>

### Function `is_greater_than`


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_is_greater_than">is_greater_than</a>(result: &<a href="comparator.md#0x1_comparator_Result">comparator::Result</a>): bool
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>let</b> res = result;
<b>ensures</b> result == (res.inner == <a href="comparator.md#0x1_comparator_GREATER">GREATER</a>);
</code></pre>



<a id="@Specification_1_compare"></a>

### Function `compare`


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_compare">compare</a>&lt;T&gt;(left: &T, right: &T): <a href="comparator.md#0x1_comparator_Result">comparator::Result</a>
</code></pre>




<pre><code><b>let</b> left_bytes = <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a>(left);
<b>let</b> right_bytes = <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a>(right);
<b>ensures</b> result == <a href="comparator.md#0x1_comparator_spec_compare_u8_vector">spec_compare_u8_vector</a>(left_bytes, right_bytes);
</code></pre>




<a id="0x1_comparator_spec_compare_u8_vector"></a>


<pre><code><b>fun</b> <a href="comparator.md#0x1_comparator_spec_compare_u8_vector">spec_compare_u8_vector</a>(left: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, right: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="comparator.md#0x1_comparator_Result">Result</a>;
</code></pre>



<a id="@Specification_1_compare_u8_vector"></a>

### Function `compare_u8_vector`


<pre><code><b>public</b> <b>fun</b> <a href="comparator.md#0x1_comparator_compare_u8_vector">compare_u8_vector</a>(left: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, right: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="comparator.md#0x1_comparator_Result">comparator::Result</a>
</code></pre>




<pre><code><b>pragma</b> unroll = 5;
<b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>let</b> left_length = len(left);
<b>let</b> right_length = len(right);
<b>ensures</b> (result.inner == <a href="comparator.md#0x1_comparator_EQUAL">EQUAL</a>) ==&gt; (
    (left_length == right_length) &&
        (<b>forall</b> i: u64 <b>where</b> i &lt; left_length: left[i] == right[i])
);
<b>ensures</b> (result.inner == <a href="comparator.md#0x1_comparator_SMALLER">SMALLER</a>) ==&gt; (
    (<b>exists</b> i: u64 <b>where</b> i &lt; left_length:
        (i &lt; right_length) &&
            (left[i] &lt; right[i]) &&
            (<b>forall</b> j: u64 <b>where</b> j &lt; i: left[j] == right[j])
    ) ||
        (left_length &lt; right_length)
);
<b>ensures</b> (result.inner == <a href="comparator.md#0x1_comparator_GREATER">GREATER</a>) ==&gt; (
    (<b>exists</b> i: u64 <b>where</b> i &lt; left_length:
        (i &lt; right_length) &&
            (left[i] &gt; right[i]) &&
            (<b>forall</b> j: u64 <b>where</b> j &lt; i: left[j] == right[j])
    ) ||
        (left_length &gt; right_length)
);
<b>ensures</b> [abstract] result == <a href="comparator.md#0x1_comparator_spec_compare_u8_vector">spec_compare_u8_vector</a>(left, right);
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/copyable_any.md
================================================

<a id="0x1_copyable_any"></a>

# Module `0x1::copyable_any`



-  [Struct `Any`](#0x1_copyable_any_Any)
-  [Constants](#@Constants_0)
-  [Function `pack`](#0x1_copyable_any_pack)
-  [Function `unpack`](#0x1_copyable_any_unpack)
-  [Function `type_name`](#0x1_copyable_any_type_name)
-  [Specification](#@Specification_1)
    -  [Function `pack`](#@Specification_1_pack)
    -  [Function `unpack`](#@Specification_1_unpack)
    -  [Function `type_name`](#@Specification_1_type_name)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/bcs.md#0x1_bcs">0x1::bcs</a>;
<b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="from_bcs.md#0x1_from_bcs">0x1::from_bcs</a>;
<b>use</b> <a href="../../move-stdlib/doc/string.md#0x1_string">0x1::string</a>;
<b>use</b> <a href="type_info.md#0x1_type_info">0x1::type_info</a>;
</code></pre>



<a id="0x1_copyable_any_Any"></a>

## Struct `Any`

The same as <code><a href="any.md#0x1_any_Any">any::Any</a></code> but with the copy ability.


<pre><code><b>struct</b> <a href="copyable_any.md#0x1_copyable_any_Any">Any</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>type_name: <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a></code>
</dt>
<dd>

</dd>
<dt>
<code>data: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_copyable_any_ETYPE_MISMATCH"></a>

The type provided for <code>unpack</code> is not the same as was given for <code>pack</code>.


<pre><code><b>const</b> <a href="copyable_any.md#0x1_copyable_any_ETYPE_MISMATCH">ETYPE_MISMATCH</a>: u64 = 0;
</code></pre>



<a id="0x1_copyable_any_pack"></a>

## Function `pack`

Pack a value into the <code><a href="copyable_any.md#0x1_copyable_any_Any">Any</a></code> representation. Because Any can be stored, dropped, and copied this is
also required from <code>T</code>.


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_pack">pack</a>&lt;T: <b>copy</b>, drop, store&gt;(x: T): <a href="copyable_any.md#0x1_copyable_any_Any">copyable_any::Any</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_pack">pack</a>&lt;T: drop + store + <b>copy</b>&gt;(x: T): <a href="copyable_any.md#0x1_copyable_any_Any">Any</a> {
    <a href="copyable_any.md#0x1_copyable_any_Any">Any</a> {
        type_name: <a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;(),
        data: <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a>(&x)
    }
}
</code></pre>



</details>

<a id="0x1_copyable_any_unpack"></a>

## Function `unpack`

Unpack a value from the <code><a href="copyable_any.md#0x1_copyable_any_Any">Any</a></code> representation. This aborts if the value has not the expected type <code>T</code>.


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_unpack">unpack</a>&lt;T&gt;(x: <a href="copyable_any.md#0x1_copyable_any_Any">copyable_any::Any</a>): T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_unpack">unpack</a>&lt;T&gt;(x: <a href="copyable_any.md#0x1_copyable_any_Any">Any</a>): T {
    <b>assert</b>!(<a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;() == x.type_name, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="copyable_any.md#0x1_copyable_any_ETYPE_MISMATCH">ETYPE_MISMATCH</a>));
    from_bytes&lt;T&gt;(x.data)
}
</code></pre>



</details>

<a id="0x1_copyable_any_type_name"></a>

## Function `type_name`

Returns the type name of this Any


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_type_name">type_name</a>(x: &<a href="copyable_any.md#0x1_copyable_any_Any">copyable_any::Any</a>): &<a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_type_name">type_name</a>(x: &<a href="copyable_any.md#0x1_copyable_any_Any">Any</a>): &String {
    &x.type_name
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_pack"></a>

### Function `pack`


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_pack">pack</a>&lt;T: <b>copy</b>, drop, store&gt;(x: T): <a href="copyable_any.md#0x1_copyable_any_Any">copyable_any::Any</a>
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>pragma</b> opaque;
<b>ensures</b> result == <a href="copyable_any.md#0x1_copyable_any_Any">Any</a> {
    type_name: <a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;(),
    data: <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_serialize">bcs::serialize</a>&lt;T&gt;(x)
};
<b>ensures</b> [abstract] <a href="from_bcs.md#0x1_from_bcs_deserializable">from_bcs::deserializable</a>&lt;T&gt;(result.data);
</code></pre>



<a id="@Specification_1_unpack"></a>

### Function `unpack`


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_unpack">unpack</a>&lt;T&gt;(x: <a href="copyable_any.md#0x1_copyable_any_Any">copyable_any::Any</a>): T
</code></pre>




<pre><code><b>include</b> <a href="copyable_any.md#0x1_copyable_any_UnpackAbortsIf">UnpackAbortsIf</a>&lt;T&gt;;
<b>ensures</b> result == <a href="from_bcs.md#0x1_from_bcs_deserialize">from_bcs::deserialize</a>&lt;T&gt;(x.data);
</code></pre>




<a id="0x1_copyable_any_UnpackAbortsIf"></a>


<pre><code><b>schema</b> <a href="copyable_any.md#0x1_copyable_any_UnpackAbortsIf">UnpackAbortsIf</a>&lt;T&gt; {
    x: <a href="copyable_any.md#0x1_copyable_any_Any">Any</a>;
    <b>aborts_if</b> <a href="type_info.md#0x1_type_info_type_name">type_info::type_name</a>&lt;T&gt;() != x.type_name;
    <b>aborts_if</b> !<a href="from_bcs.md#0x1_from_bcs_deserializable">from_bcs::deserializable</a>&lt;T&gt;(x.data);
}
</code></pre>



<a id="@Specification_1_type_name"></a>

### Function `type_name`


<pre><code><b>public</b> <b>fun</b> <a href="copyable_any.md#0x1_copyable_any_type_name">type_name</a>(x: &<a href="copyable_any.md#0x1_copyable_any_Any">copyable_any::Any</a>): &<a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == x.type_name;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/debug.md
================================================

<a id="0x1_debug"></a>

# Module `0x1::debug`

Module providing debug functionality.


-  [Constants](#@Constants_0)
-  [Function `print`](#0x1_debug_print)
-  [Function `print_stack_trace`](#0x1_debug_print_stack_trace)
-  [Function `format`](#0x1_debug_format)
-  [Function `native_print`](#0x1_debug_native_print)
-  [Function `native_stack_trace`](#0x1_debug_native_stack_trace)
-  [Specification](#@Specification_1)
    -  [Function `print`](#@Specification_1_print)
    -  [Function `print_stack_trace`](#@Specification_1_print_stack_trace)
    -  [Function `native_print`](#@Specification_1_native_print)
    -  [Function `native_stack_trace`](#@Specification_1_native_stack_trace)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/string.md#0x1_string">0x1::string</a>;
<b>use</b> <a href="string_utils.md#0x1_string_utils">0x1::string_utils</a>;
</code></pre>



<a id="@Constants_0"></a>

## Constants


<a id="0x1_debug_MSG_1"></a>



<pre><code><b>const</b> <a href="debug.md#0x1_debug_MSG_1">MSG_1</a>: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; = [97, 98, 99, 100, 101, 102];
</code></pre>



<a id="0x1_debug_MSG_2"></a>



<pre><code><b>const</b> <a href="debug.md#0x1_debug_MSG_2">MSG_2</a>: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; = [49, 50, 51, 52, 53, 54];
</code></pre>



<a id="0x1_debug_print"></a>

## Function `print`



<pre><code><b>public</b> <b>fun</b> <a href="debug.md#0x1_debug_print">print</a>&lt;T&gt;(x: &T)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="debug.md#0x1_debug_print">print</a>&lt;T&gt;(x: &T) {
    <a href="debug.md#0x1_debug_native_print">native_print</a>(<a href="debug.md#0x1_debug_format">format</a>(x));
}
</code></pre>



</details>

<a id="0x1_debug_print_stack_trace"></a>

## Function `print_stack_trace`



<pre><code><b>public</b> <b>fun</b> <a href="debug.md#0x1_debug_print_stack_trace">print_stack_trace</a>()
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="debug.md#0x1_debug_print_stack_trace">print_stack_trace</a>() {
    <a href="debug.md#0x1_debug_native_print">native_print</a>(<a href="debug.md#0x1_debug_native_stack_trace">native_stack_trace</a>());
}
</code></pre>



</details>

<a id="0x1_debug_format"></a>

## Function `format`



<pre><code><b>fun</b> <a href="debug.md#0x1_debug_format">format</a>&lt;T&gt;(x: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="debug.md#0x1_debug_format">format</a>&lt;T&gt;(x: &T): String {
    aptos_std::string_utils::debug_string(x)
}
</code></pre>



</details>

<a id="0x1_debug_native_print"></a>

## Function `native_print`



<pre><code><b>fun</b> <a href="debug.md#0x1_debug_native_print">native_print</a>(x: <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="debug.md#0x1_debug_native_print">native_print</a>(x: String);
</code></pre>



</details>

<a id="0x1_debug_native_stack_trace"></a>

## Function `native_stack_trace`



<pre><code><b>fun</b> <a href="debug.md#0x1_debug_native_stack_trace">native_stack_trace</a>(): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="debug.md#0x1_debug_native_stack_trace">native_stack_trace</a>(): String;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_print"></a>

### Function `print`


<pre><code><b>public</b> <b>fun</b> <a href="debug.md#0x1_debug_print">print</a>&lt;T&gt;(x: &T)
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
</code></pre>



<a id="@Specification_1_print_stack_trace"></a>

### Function `print_stack_trace`


<pre><code><b>public</b> <b>fun</b> <a href="debug.md#0x1_debug_print_stack_trace">print_stack_trace</a>()
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
</code></pre>



<a id="@Specification_1_native_print"></a>

### Function `native_print`


<pre><code><b>fun</b> <a href="debug.md#0x1_debug_native_print">native_print</a>(x: <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>)
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
</code></pre>



<a id="@Specification_1_native_stack_trace"></a>

### Function `native_stack_trace`


<pre><code><b>fun</b> <a href="debug.md#0x1_debug_native_stack_trace">native_stack_trace</a>(): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/ed25519.md
================================================

<a id="0x1_ed25519"></a>

# Module `0x1::ed25519`

Contains functions for:

1. [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) digital signatures: i.e., EdDSA signatures over Edwards25519 curves with co-factor 8


-  [Struct `SignedMessage`](#0x1_ed25519_SignedMessage)
-  [Struct `UnvalidatedPublicKey`](#0x1_ed25519_UnvalidatedPublicKey)
-  [Struct `ValidatedPublicKey`](#0x1_ed25519_ValidatedPublicKey)
-  [Struct `Signature`](#0x1_ed25519_Signature)
-  [Constants](#@Constants_0)
-  [Function `new_unvalidated_public_key_from_bytes`](#0x1_ed25519_new_unvalidated_public_key_from_bytes)
-  [Function `new_validated_public_key_from_bytes`](#0x1_ed25519_new_validated_public_key_from_bytes)
-  [Function `new_signature_from_bytes`](#0x1_ed25519_new_signature_from_bytes)
-  [Function `public_key_to_unvalidated`](#0x1_ed25519_public_key_to_unvalidated)
-  [Function `public_key_into_unvalidated`](#0x1_ed25519_public_key_into_unvalidated)
-  [Function `unvalidated_public_key_to_bytes`](#0x1_ed25519_unvalidated_public_key_to_bytes)
-  [Function `validated_public_key_to_bytes`](#0x1_ed25519_validated_public_key_to_bytes)
-  [Function `signature_to_bytes`](#0x1_ed25519_signature_to_bytes)
-  [Function `public_key_validate`](#0x1_ed25519_public_key_validate)
-  [Function `signature_verify_strict`](#0x1_ed25519_signature_verify_strict)
-  [Function `signature_verify_strict_t`](#0x1_ed25519_signature_verify_strict_t)
-  [Function `new_signed_message`](#0x1_ed25519_new_signed_message)
-  [Function `unvalidated_public_key_to_authentication_key`](#0x1_ed25519_unvalidated_public_key_to_authentication_key)
-  [Function `validated_public_key_to_authentication_key`](#0x1_ed25519_validated_public_key_to_authentication_key)
-  [Function `public_key_bytes_to_authentication_key`](#0x1_ed25519_public_key_bytes_to_authentication_key)
-  [Function `public_key_validate_internal`](#0x1_ed25519_public_key_validate_internal)
-  [Function `signature_verify_strict_internal`](#0x1_ed25519_signature_verify_strict_internal)
-  [Specification](#@Specification_1)
    -  [Function `new_unvalidated_public_key_from_bytes`](#@Specification_1_new_unvalidated_public_key_from_bytes)
    -  [Function `new_validated_public_key_from_bytes`](#@Specification_1_new_validated_public_key_from_bytes)
    -  [Function `new_signature_from_bytes`](#@Specification_1_new_signature_from_bytes)
    -  [Function `public_key_bytes_to_authentication_key`](#@Specification_1_public_key_bytes_to_authentication_key)
    -  [Function `public_key_validate_internal`](#@Specification_1_public_key_validate_internal)
    -  [Function `signature_verify_strict_internal`](#@Specification_1_signature_verify_strict_internal)
    -  [Helper functions](#@Helper_functions_2)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/bcs.md#0x1_bcs">0x1::bcs</a>;
<b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/hash.md#0x1_hash">0x1::hash</a>;
<b>use</b> <a href="../../move-stdlib/doc/option.md#0x1_option">0x1::option</a>;
<b>use</b> <a href="type_info.md#0x1_type_info">0x1::type_info</a>;
</code></pre>



<a id="0x1_ed25519_SignedMessage"></a>

## Struct `SignedMessage`

A BCS-serializable message, which one can verify signatures on via <code>signature_verify_strict_t</code>


<pre><code><b>struct</b> <a href="ed25519.md#0x1_ed25519_SignedMessage">SignedMessage</a>&lt;MessageType&gt; <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code><a href="type_info.md#0x1_type_info">type_info</a>: <a href="type_info.md#0x1_type_info_TypeInfo">type_info::TypeInfo</a></code>
</dt>
<dd>

</dd>
<dt>
<code>inner: MessageType</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ed25519_UnvalidatedPublicKey"></a>

## Struct `UnvalidatedPublicKey`

An *unvalidated* Ed25519 public key: not necessarily an elliptic curve point, just a sequence of 32 bytes


<pre><code><b>struct</b> <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ed25519_ValidatedPublicKey"></a>

## Struct `ValidatedPublicKey`

A *validated* Ed25519 public key: not necessarily a prime-order point, could be mixed-order, but will never be
a small-order point.

For now, this struct is not used in any verification functions, but it might be in the future.


<pre><code><b>struct</b> <a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ed25519_Signature"></a>

## Struct `Signature`

A purported Ed25519 signature that can be verified via <code>signature_verify_strict</code> or <code>signature_verify_strict_t</code>.


<pre><code><b>struct</b> <a href="ed25519.md#0x1_ed25519_Signature">Signature</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_ed25519_PUBLIC_KEY_NUM_BYTES"></a>

The size of a serialized public key, in bytes.


<pre><code><b>const</b> <a href="ed25519.md#0x1_ed25519_PUBLIC_KEY_NUM_BYTES">PUBLIC_KEY_NUM_BYTES</a>: u64 = 32;
</code></pre>



<a id="0x1_ed25519_E_WRONG_PUBKEY_SIZE"></a>

Wrong number of bytes were given as input when deserializing an Ed25519 public key.


<pre><code><b>const</b> <a href="ed25519.md#0x1_ed25519_E_WRONG_PUBKEY_SIZE">E_WRONG_PUBKEY_SIZE</a>: u64 = 1;
</code></pre>



<a id="0x1_ed25519_E_WRONG_SIGNATURE_SIZE"></a>

Wrong number of bytes were given as input when deserializing an Ed25519 signature.


<pre><code><b>const</b> <a href="ed25519.md#0x1_ed25519_E_WRONG_SIGNATURE_SIZE">E_WRONG_SIGNATURE_SIZE</a>: u64 = 2;
</code></pre>



<a id="0x1_ed25519_SIGNATURE_NUM_BYTES"></a>

The size of a serialized signature, in bytes.


<pre><code><b>const</b> <a href="ed25519.md#0x1_ed25519_SIGNATURE_NUM_BYTES">SIGNATURE_NUM_BYTES</a>: u64 = 64;
</code></pre>



<a id="0x1_ed25519_SIGNATURE_SCHEME_ID"></a>

The identifier of the Ed25519 signature scheme, which is used when deriving Supra authentication keys by hashing
it together with an Ed25519 public key.


<pre><code><b>const</b> <a href="ed25519.md#0x1_ed25519_SIGNATURE_SCHEME_ID">SIGNATURE_SCHEME_ID</a>: u8 = 0;
</code></pre>



<a id="0x1_ed25519_new_unvalidated_public_key_from_bytes"></a>

## Function `new_unvalidated_public_key_from_bytes`

Parses the input 32 bytes as an *unvalidated* Ed25519 public key.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_unvalidated_public_key_from_bytes">new_unvalidated_public_key_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_unvalidated_public_key_from_bytes">new_unvalidated_public_key_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a> {
    <b>assert</b>!(std::vector::length(&bytes) == <a href="ed25519.md#0x1_ed25519_PUBLIC_KEY_NUM_BYTES">PUBLIC_KEY_NUM_BYTES</a>, std::error::invalid_argument(<a href="ed25519.md#0x1_ed25519_E_WRONG_PUBKEY_SIZE">E_WRONG_PUBKEY_SIZE</a>));
    <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a> { bytes }
}
</code></pre>



</details>

<a id="0x1_ed25519_new_validated_public_key_from_bytes"></a>

## Function `new_validated_public_key_from_bytes`

Parses the input 32 bytes as a *validated* Ed25519 public key.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_validated_public_key_from_bytes">new_validated_public_key_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ed25519::ValidatedPublicKey</a>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_validated_public_key_from_bytes">new_validated_public_key_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): Option&lt;<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>&gt; {
    <b>if</b> (<a href="ed25519.md#0x1_ed25519_public_key_validate_internal">public_key_validate_internal</a>(bytes)) {
        <a href="../../move-stdlib/doc/option.md#0x1_option_some">option::some</a>(<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a> {
            bytes
        })
    } <b>else</b> {
        <a href="../../move-stdlib/doc/option.md#0x1_option_none">option::none</a>&lt;<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>&gt;()
    }
}
</code></pre>



</details>

<a id="0x1_ed25519_new_signature_from_bytes"></a>

## Function `new_signature_from_bytes`

Parses the input 64 bytes as a purported Ed25519 signature.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_signature_from_bytes">new_signature_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="ed25519.md#0x1_ed25519_Signature">ed25519::Signature</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_signature_from_bytes">new_signature_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="ed25519.md#0x1_ed25519_Signature">Signature</a> {
    <b>assert</b>!(std::vector::length(&bytes) == <a href="ed25519.md#0x1_ed25519_SIGNATURE_NUM_BYTES">SIGNATURE_NUM_BYTES</a>, std::error::invalid_argument(<a href="ed25519.md#0x1_ed25519_E_WRONG_SIGNATURE_SIZE">E_WRONG_SIGNATURE_SIZE</a>));
    <a href="ed25519.md#0x1_ed25519_Signature">Signature</a> { bytes }
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_to_unvalidated"></a>

## Function `public_key_to_unvalidated`

Converts a ValidatedPublicKey to an UnvalidatedPublicKey, which can be used in the strict verification APIs.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_to_unvalidated">public_key_to_unvalidated</a>(pk: &<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ed25519::ValidatedPublicKey</a>): <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_to_unvalidated">public_key_to_unvalidated</a>(pk: &<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>): <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a> {
    <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a> {
        bytes: pk.bytes
    }
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_into_unvalidated"></a>

## Function `public_key_into_unvalidated`

Moves a ValidatedPublicKey into an UnvalidatedPublicKey, which can be used in the strict verification APIs.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_into_unvalidated">public_key_into_unvalidated</a>(pk: <a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ed25519::ValidatedPublicKey</a>): <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_into_unvalidated">public_key_into_unvalidated</a>(pk: <a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>): <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a> {
    <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a> {
        bytes: pk.bytes
    }
}
</code></pre>



</details>

<a id="0x1_ed25519_unvalidated_public_key_to_bytes"></a>

## Function `unvalidated_public_key_to_bytes`

Serializes an UnvalidatedPublicKey struct to 32-bytes.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_unvalidated_public_key_to_bytes">unvalidated_public_key_to_bytes</a>(pk: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_unvalidated_public_key_to_bytes">unvalidated_public_key_to_bytes</a>(pk: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    pk.bytes
}
</code></pre>



</details>

<a id="0x1_ed25519_validated_public_key_to_bytes"></a>

## Function `validated_public_key_to_bytes`

Serializes an ValidatedPublicKey struct to 32-bytes.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_validated_public_key_to_bytes">validated_public_key_to_bytes</a>(pk: &<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ed25519::ValidatedPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_validated_public_key_to_bytes">validated_public_key_to_bytes</a>(pk: &<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    pk.bytes
}
</code></pre>



</details>

<a id="0x1_ed25519_signature_to_bytes"></a>

## Function `signature_to_bytes`

Serializes a Signature struct to 64-bytes.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_to_bytes">signature_to_bytes</a>(sig: &<a href="ed25519.md#0x1_ed25519_Signature">ed25519::Signature</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_to_bytes">signature_to_bytes</a>(sig: &<a href="ed25519.md#0x1_ed25519_Signature">Signature</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    sig.bytes
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_validate"></a>

## Function `public_key_validate`

Takes in an *unvalidated* public key and attempts to validate it.
Returns <code>Some(<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>)</code> if successful and <code>None</code> otherwise.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_validate">public_key_validate</a>(pk: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ed25519::ValidatedPublicKey</a>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_validate">public_key_validate</a>(pk: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a>): Option&lt;<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>&gt; {
    <a href="ed25519.md#0x1_ed25519_new_validated_public_key_from_bytes">new_validated_public_key_from_bytes</a>(pk.bytes)
}
</code></pre>



</details>

<a id="0x1_ed25519_signature_verify_strict"></a>

## Function `signature_verify_strict`

Verifies a purported Ed25519 <code>signature</code> under an *unvalidated* <code>public_key</code> on the specified <code>message</code>.
This call will validate the public key by checking it is NOT in the small subgroup.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_verify_strict">signature_verify_strict</a>(signature: &<a href="ed25519.md#0x1_ed25519_Signature">ed25519::Signature</a>, public_key: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>, message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_verify_strict">signature_verify_strict</a>(
    signature: &<a href="ed25519.md#0x1_ed25519_Signature">Signature</a>,
    public_key: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a>,
    message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
): bool {
    <a href="ed25519.md#0x1_ed25519_signature_verify_strict_internal">signature_verify_strict_internal</a>(signature.bytes, public_key.bytes, message)
}
</code></pre>



</details>

<a id="0x1_ed25519_signature_verify_strict_t"></a>

## Function `signature_verify_strict_t`

This function is used to verify a signature on any BCS-serializable type T. For now, it is used to verify the
proof of private key ownership when rotating authentication keys.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_verify_strict_t">signature_verify_strict_t</a>&lt;T: drop&gt;(signature: &<a href="ed25519.md#0x1_ed25519_Signature">ed25519::Signature</a>, public_key: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>, data: T): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_verify_strict_t">signature_verify_strict_t</a>&lt;T: drop&gt;(signature: &<a href="ed25519.md#0x1_ed25519_Signature">Signature</a>, public_key: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a>, data: T): bool {
    <b>let</b> encoded = <a href="ed25519.md#0x1_ed25519_SignedMessage">SignedMessage</a> {
        <a href="type_info.md#0x1_type_info">type_info</a>: <a href="type_info.md#0x1_type_info_type_of">type_info::type_of</a>&lt;T&gt;(),
        inner: data,
    };

    <a href="ed25519.md#0x1_ed25519_signature_verify_strict_internal">signature_verify_strict_internal</a>(signature.bytes, public_key.bytes, <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a>(&encoded))
}
</code></pre>



</details>

<a id="0x1_ed25519_new_signed_message"></a>

## Function `new_signed_message`

Helper method to construct a SignedMessage struct.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_signed_message">new_signed_message</a>&lt;T: drop&gt;(data: T): <a href="ed25519.md#0x1_ed25519_SignedMessage">ed25519::SignedMessage</a>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_signed_message">new_signed_message</a>&lt;T: drop&gt;(data: T): <a href="ed25519.md#0x1_ed25519_SignedMessage">SignedMessage</a>&lt;T&gt; {
    <a href="ed25519.md#0x1_ed25519_SignedMessage">SignedMessage</a> {
        <a href="type_info.md#0x1_type_info">type_info</a>: <a href="type_info.md#0x1_type_info_type_of">type_info::type_of</a>&lt;T&gt;(),
        inner: data,
    }
}
</code></pre>



</details>

<a id="0x1_ed25519_unvalidated_public_key_to_authentication_key"></a>

## Function `unvalidated_public_key_to_authentication_key`

Derives the Supra-specific authentication key of the given Ed25519 public key.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_unvalidated_public_key_to_authentication_key">unvalidated_public_key_to_authentication_key</a>(pk: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_unvalidated_public_key_to_authentication_key">unvalidated_public_key_to_authentication_key</a>(pk: &<a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <a href="ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key">public_key_bytes_to_authentication_key</a>(pk.bytes)
}
</code></pre>



</details>

<a id="0x1_ed25519_validated_public_key_to_authentication_key"></a>

## Function `validated_public_key_to_authentication_key`

Derives the Supra-specific authentication key of the given Ed25519 public key.


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_validated_public_key_to_authentication_key">validated_public_key_to_authentication_key</a>(pk: &<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ed25519::ValidatedPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_validated_public_key_to_authentication_key">validated_public_key_to_authentication_key</a>(pk: &<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <a href="ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key">public_key_bytes_to_authentication_key</a>(pk.bytes)
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_bytes_to_authentication_key"></a>

## Function `public_key_bytes_to_authentication_key`

Derives the Supra-specific authentication key of the given Ed25519 public key.


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key">public_key_bytes_to_authentication_key</a>(pk_bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key">public_key_bytes_to_authentication_key</a>(pk_bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    std::vector::push_back(&<b>mut</b> pk_bytes, <a href="ed25519.md#0x1_ed25519_SIGNATURE_SCHEME_ID">SIGNATURE_SCHEME_ID</a>);
    std::hash::sha3_256(pk_bytes)
}
</code></pre>



</details>

<a id="0x1_ed25519_public_key_validate_internal"></a>

## Function `public_key_validate_internal`

Return <code><b>true</b></code> if the bytes in <code>public_key</code> can be parsed as a valid Ed25519 public key: i.e., it passes
points-on-curve and not-in-small-subgroup checks.
Returns <code><b>false</b></code> otherwise.


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_validate_internal">public_key_validate_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_validate_internal">public_key_validate_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool;
</code></pre>



</details>

<a id="0x1_ed25519_signature_verify_strict_internal"></a>

## Function `signature_verify_strict_internal`

Return true if the Ed25519 <code>signature</code> on <code>message</code> verifies against the Ed25519 <code>public_key</code>.
Returns <code><b>false</b></code> if either:
- <code>signature</code> or <code><b>public</b> key</code> are of wrong sizes
- <code>public_key</code> does not pass points-on-curve or not-in-small-subgroup checks,
- <code>signature</code> does not pass points-on-curve or not-in-small-subgroup checks,
- the signature on <code>message</code> does not verify.


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_verify_strict_internal">signature_verify_strict_internal</a>(signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, public_key: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_verify_strict_internal">signature_verify_strict_internal</a>(
    signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;,
    public_key: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;,
    message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
): bool;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_new_unvalidated_public_key_from_bytes"></a>

### Function `new_unvalidated_public_key_from_bytes`


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_unvalidated_public_key_from_bytes">new_unvalidated_public_key_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">ed25519::UnvalidatedPublicKey</a>
</code></pre>




<pre><code><b>include</b> <a href="ed25519.md#0x1_ed25519_NewUnvalidatedPublicKeyFromBytesAbortsIf">NewUnvalidatedPublicKeyFromBytesAbortsIf</a>;
<b>ensures</b> result == <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a> { bytes };
</code></pre>




<a id="0x1_ed25519_NewUnvalidatedPublicKeyFromBytesAbortsIf"></a>


<pre><code><b>schema</b> <a href="ed25519.md#0x1_ed25519_NewUnvalidatedPublicKeyFromBytesAbortsIf">NewUnvalidatedPublicKeyFromBytesAbortsIf</a> {
    bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
    <b>aborts_if</b> len(bytes) != <a href="ed25519.md#0x1_ed25519_PUBLIC_KEY_NUM_BYTES">PUBLIC_KEY_NUM_BYTES</a>;
}
</code></pre>



<a id="@Specification_1_new_validated_public_key_from_bytes"></a>

### Function `new_validated_public_key_from_bytes`


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_validated_public_key_from_bytes">new_validated_public_key_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ed25519::ValidatedPublicKey</a>&gt;
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>let</b> cond = <a href="ed25519.md#0x1_ed25519_spec_public_key_validate_internal">spec_public_key_validate_internal</a>(bytes);
<b>ensures</b> cond ==&gt; result == <a href="../../move-stdlib/doc/option.md#0x1_option_spec_some">option::spec_some</a>(<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>{bytes});
<b>ensures</b> !cond ==&gt; result == <a href="../../move-stdlib/doc/option.md#0x1_option_spec_none">option::spec_none</a>&lt;<a href="ed25519.md#0x1_ed25519_ValidatedPublicKey">ValidatedPublicKey</a>&gt;();
</code></pre>



<a id="@Specification_1_new_signature_from_bytes"></a>

### Function `new_signature_from_bytes`


<pre><code><b>public</b> <b>fun</b> <a href="ed25519.md#0x1_ed25519_new_signature_from_bytes">new_signature_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="ed25519.md#0x1_ed25519_Signature">ed25519::Signature</a>
</code></pre>




<pre><code><b>include</b> <a href="ed25519.md#0x1_ed25519_NewSignatureFromBytesAbortsIf">NewSignatureFromBytesAbortsIf</a>;
<b>ensures</b> result == <a href="ed25519.md#0x1_ed25519_Signature">Signature</a> { bytes };
</code></pre>




<a id="0x1_ed25519_NewSignatureFromBytesAbortsIf"></a>


<pre><code><b>schema</b> <a href="ed25519.md#0x1_ed25519_NewSignatureFromBytesAbortsIf">NewSignatureFromBytesAbortsIf</a> {
    bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
    <b>aborts_if</b> len(bytes) != <a href="ed25519.md#0x1_ed25519_SIGNATURE_NUM_BYTES">SIGNATURE_NUM_BYTES</a>;
}
</code></pre>



<a id="@Specification_1_public_key_bytes_to_authentication_key"></a>

### Function `public_key_bytes_to_authentication_key`


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_bytes_to_authentication_key">public_key_bytes_to_authentication_key</a>(pk_bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> [abstract] result == <a href="ed25519.md#0x1_ed25519_spec_public_key_bytes_to_authentication_key">spec_public_key_bytes_to_authentication_key</a>(pk_bytes);
</code></pre>



<a id="@Specification_1_public_key_validate_internal"></a>

### Function `public_key_validate_internal`


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_public_key_validate_internal">public_key_validate_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="ed25519.md#0x1_ed25519_spec_public_key_validate_internal">spec_public_key_validate_internal</a>(bytes);
</code></pre>



<a id="@Specification_1_signature_verify_strict_internal"></a>

### Function `signature_verify_strict_internal`


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_signature_verify_strict_internal">signature_verify_strict_internal</a>(signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, public_key: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="ed25519.md#0x1_ed25519_spec_signature_verify_strict_internal">spec_signature_verify_strict_internal</a>(signature, public_key, message);
</code></pre>



<a id="@Helper_functions_2"></a>

### Helper functions



<a id="0x1_ed25519_spec_signature_verify_strict_internal"></a>


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_spec_signature_verify_strict_internal">spec_signature_verify_strict_internal</a>(
   signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;,
   public_key: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;,
   message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
): bool;
</code></pre>




<a id="0x1_ed25519_spec_public_key_validate_internal"></a>


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_spec_public_key_validate_internal">spec_public_key_validate_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool;
</code></pre>




<a id="0x1_ed25519_spec_public_key_bytes_to_authentication_key"></a>


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_spec_public_key_bytes_to_authentication_key">spec_public_key_bytes_to_authentication_key</a>(pk_bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>




<a id="0x1_ed25519_spec_signature_verify_strict_t"></a>


<pre><code><b>fun</b> <a href="ed25519.md#0x1_ed25519_spec_signature_verify_strict_t">spec_signature_verify_strict_t</a>&lt;T&gt;(signature: <a href="ed25519.md#0x1_ed25519_Signature">Signature</a>, public_key: <a href="ed25519.md#0x1_ed25519_UnvalidatedPublicKey">UnvalidatedPublicKey</a>, data: T): bool {
   <b>let</b> encoded = <a href="ed25519.md#0x1_ed25519_SignedMessage">SignedMessage</a>&lt;T&gt; {
       <a href="type_info.md#0x1_type_info">type_info</a>: <a href="type_info.md#0x1_type_info_type_of">type_info::type_of</a>&lt;T&gt;(),
       inner: data,
   };
   <b>let</b> message = <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_serialize">bcs::serialize</a>(encoded);
   <a href="ed25519.md#0x1_ed25519_spec_signature_verify_strict_internal">spec_signature_verify_strict_internal</a>(signature.bytes, public_key.bytes, message)
}
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/fixed_point64.md
================================================

<a id="0x1_fixed_point64"></a>

# Module `0x1::fixed_point64`

Defines a fixed-point numeric type with a 64-bit integer part and
a 64-bit fractional part.


-  [Struct `FixedPoint64`](#0x1_fixed_point64_FixedPoint64)
-  [Constants](#@Constants_0)
-  [Function `sub`](#0x1_fixed_point64_sub)
-  [Function `add`](#0x1_fixed_point64_add)
-  [Function `multiply_u128`](#0x1_fixed_point64_multiply_u128)
-  [Function `divide_u128`](#0x1_fixed_point64_divide_u128)
-  [Function `create_from_rational`](#0x1_fixed_point64_create_from_rational)
-  [Function `create_from_raw_value`](#0x1_fixed_point64_create_from_raw_value)
-  [Function `get_raw_value`](#0x1_fixed_point64_get_raw_value)
-  [Function `is_zero`](#0x1_fixed_point64_is_zero)
-  [Function `min`](#0x1_fixed_point64_min)
-  [Function `max`](#0x1_fixed_point64_max)
-  [Function `less_or_equal`](#0x1_fixed_point64_less_or_equal)
-  [Function `less`](#0x1_fixed_point64_less)
-  [Function `greater_or_equal`](#0x1_fixed_point64_greater_or_equal)
-  [Function `greater`](#0x1_fixed_point64_greater)
-  [Function `equal`](#0x1_fixed_point64_equal)
-  [Function `almost_equal`](#0x1_fixed_point64_almost_equal)
-  [Function `create_from_u128`](#0x1_fixed_point64_create_from_u128)
-  [Function `floor`](#0x1_fixed_point64_floor)
-  [Function `ceil`](#0x1_fixed_point64_ceil)
-  [Function `round`](#0x1_fixed_point64_round)
-  [Specification](#@Specification_1)
    -  [Function `sub`](#@Specification_1_sub)
    -  [Function `add`](#@Specification_1_add)
    -  [Function `multiply_u128`](#@Specification_1_multiply_u128)
    -  [Function `divide_u128`](#@Specification_1_divide_u128)
    -  [Function `create_from_rational`](#@Specification_1_create_from_rational)
    -  [Function `create_from_raw_value`](#@Specification_1_create_from_raw_value)
    -  [Function `min`](#@Specification_1_min)
    -  [Function `max`](#@Specification_1_max)
    -  [Function `less_or_equal`](#@Specification_1_less_or_equal)
    -  [Function `less`](#@Specification_1_less)
    -  [Function `greater_or_equal`](#@Specification_1_greater_or_equal)
    -  [Function `greater`](#@Specification_1_greater)
    -  [Function `equal`](#@Specification_1_equal)
    -  [Function `almost_equal`](#@Specification_1_almost_equal)
    -  [Function `create_from_u128`](#@Specification_1_create_from_u128)
    -  [Function `floor`](#@Specification_1_floor)
    -  [Function `ceil`](#@Specification_1_ceil)
    -  [Function `round`](#@Specification_1_round)


<pre><code></code></pre>



<a id="0x1_fixed_point64_FixedPoint64"></a>

## Struct `FixedPoint64`

Define a fixed-point numeric type with 64 fractional bits.
This is just a u128 integer but it is wrapped in a struct to
make a unique type. This is a binary representation, so decimal
values may not be exactly representable, but it provides more
than 9 decimal digits of precision both before and after the
decimal point (18 digits total). For comparison, double precision
floating-point has less than 16 decimal digits of precision, so
be careful about using floating-point to convert these values to
decimal.


<pre><code><b>struct</b> <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>value: u128</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_fixed_point64_MAX_U128"></a>



<pre><code><b>const</b> <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a>: u256 = 340282366920938463463374607431768211455;
</code></pre>



<a id="0x1_fixed_point64_EDENOMINATOR"></a>

The denominator provided was zero


<pre><code><b>const</b> <a href="fixed_point64.md#0x1_fixed_point64_EDENOMINATOR">EDENOMINATOR</a>: u64 = 65537;
</code></pre>



<a id="0x1_fixed_point64_EDIVISION"></a>

The quotient value would be too large to be held in a <code>u128</code>


<pre><code><b>const</b> <a href="fixed_point64.md#0x1_fixed_point64_EDIVISION">EDIVISION</a>: u64 = 131074;
</code></pre>



<a id="0x1_fixed_point64_EDIVISION_BY_ZERO"></a>

A division by zero was encountered


<pre><code><b>const</b> <a href="fixed_point64.md#0x1_fixed_point64_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>: u64 = 65540;
</code></pre>



<a id="0x1_fixed_point64_EMULTIPLICATION"></a>

The multiplied value would be too large to be held in a <code>u128</code>


<pre><code><b>const</b> <a href="fixed_point64.md#0x1_fixed_point64_EMULTIPLICATION">EMULTIPLICATION</a>: u64 = 131075;
</code></pre>



<a id="0x1_fixed_point64_ENEGATIVE_RESULT"></a>

Abort code on calculation result is negative.


<pre><code><b>const</b> <a href="fixed_point64.md#0x1_fixed_point64_ENEGATIVE_RESULT">ENEGATIVE_RESULT</a>: u64 = 65542;
</code></pre>



<a id="0x1_fixed_point64_ERATIO_OUT_OF_RANGE"></a>

The computed ratio when converting to a <code><a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a></code> would be unrepresentable


<pre><code><b>const</b> <a href="fixed_point64.md#0x1_fixed_point64_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>: u64 = 131077;
</code></pre>



<a id="0x1_fixed_point64_sub"></a>

## Function `sub`

Returns x - y. x must be not less than y.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_sub">sub</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, y: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_sub">sub</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, y: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
    <b>let</b> x_raw = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">get_raw_value</a>(x);
    <b>let</b> y_raw = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">get_raw_value</a>(y);
    <b>assert</b>!(x_raw &gt;= y_raw, <a href="fixed_point64.md#0x1_fixed_point64_ENEGATIVE_RESULT">ENEGATIVE_RESULT</a>);
    <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">create_from_raw_value</a>(x_raw - y_raw)
}
</code></pre>



</details>

<a id="0x1_fixed_point64_add"></a>

## Function `add`

Returns x + y. The result cannot be greater than MAX_U128.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_add">add</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, y: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_add">add</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, y: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
    <b>let</b> x_raw = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">get_raw_value</a>(x);
    <b>let</b> y_raw = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">get_raw_value</a>(y);
    <b>let</b> result = (x_raw <b>as</b> u256) + (y_raw <b>as</b> u256);
    <b>assert</b>!(result &lt;= <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a>, <a href="fixed_point64.md#0x1_fixed_point64_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>);
    <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">create_from_raw_value</a>((result <b>as</b> u128))
}
</code></pre>



</details>

<a id="0x1_fixed_point64_multiply_u128"></a>

## Function `multiply_u128`

Multiply a u128 integer by a fixed-point number, truncating any
fractional part of the product. This will abort if the product
overflows.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_multiply_u128">multiply_u128</a>(val: u128, multiplier: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_multiply_u128">multiply_u128</a>(val: u128, multiplier: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
    // The product of two 128 bit values <b>has</b> 256 bits, so perform the
    // multiplication <b>with</b> u256 types and keep the full 256 bit product
    // <b>to</b> avoid losing accuracy.
    <b>let</b> unscaled_product = (val <b>as</b> u256) * (multiplier.value <b>as</b> u256);
    // The unscaled product <b>has</b> 64 fractional bits (from the multiplier)
    // so rescale it by shifting away the low bits.
    <b>let</b> product = unscaled_product &gt;&gt; 64;
    // Check whether the value is too large.
    <b>assert</b>!(product &lt;= <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a>, <a href="fixed_point64.md#0x1_fixed_point64_EMULTIPLICATION">EMULTIPLICATION</a>);
    (product <b>as</b> u128)
}
</code></pre>



</details>

<a id="0x1_fixed_point64_divide_u128"></a>

## Function `divide_u128`

Divide a u128 integer by a fixed-point number, truncating any
fractional part of the quotient. This will abort if the divisor
is zero or if the quotient overflows.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_divide_u128">divide_u128</a>(val: u128, divisor: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_divide_u128">divide_u128</a>(val: u128, divisor: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
    // Check for division by zero.
    <b>assert</b>!(divisor.value != 0, <a href="fixed_point64.md#0x1_fixed_point64_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>);
    // First convert <b>to</b> 256 bits and then shift left <b>to</b>
    // add 64 fractional zero bits <b>to</b> the dividend.
    <b>let</b> scaled_value = (val <b>as</b> u256) &lt;&lt; 64;
    <b>let</b> quotient = scaled_value / (divisor.value <b>as</b> u256);
    // Check whether the value is too large.
    <b>assert</b>!(quotient &lt;= <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a>, <a href="fixed_point64.md#0x1_fixed_point64_EDIVISION">EDIVISION</a>);
    // the value may be too large, which will cause the cast <b>to</b> fail
    // <b>with</b> an arithmetic <a href="../../move-stdlib/doc/error.md#0x1_error">error</a>.
    (quotient <b>as</b> u128)
}
</code></pre>



</details>

<a id="0x1_fixed_point64_create_from_rational"></a>

## Function `create_from_rational`

Create a fixed-point value from a rational number specified by its
numerator and denominator. Calling this function should be preferred
for using <code><a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">Self::create_from_raw_value</a></code> which is also available.
This will abort if the denominator is zero. It will also
abort if the numerator is nonzero and the ratio is not in the range
2^-64 .. 2^64-1. When specifying decimal fractions, be careful about
rounding errors: if you round to display N digits after the decimal
point, you can use a denominator of 10^N to avoid numbers where the
very small imprecision in the binary representation could change the
rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_rational">create_from_rational</a>(numerator: u128, denominator: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_rational">create_from_rational</a>(numerator: u128, denominator: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
    // If the denominator is zero, this will <b>abort</b>.
    // Scale the numerator <b>to</b> have 64 fractional bits, so that the quotient will have 64
    // fractional bits.
    <b>let</b> scaled_numerator = (numerator <b>as</b> u256) &lt;&lt; 64;
    <b>assert</b>!(denominator != 0, <a href="fixed_point64.md#0x1_fixed_point64_EDENOMINATOR">EDENOMINATOR</a>);
    <b>let</b> quotient = scaled_numerator / (denominator <b>as</b> u256);
    <b>assert</b>!(quotient != 0 || numerator == 0, <a href="fixed_point64.md#0x1_fixed_point64_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>);
    // Return the quotient <b>as</b> a fixed-point number. We first need <b>to</b> check whether the cast
    // can succeed.
    <b>assert</b>!(quotient &lt;= <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a>, <a href="fixed_point64.md#0x1_fixed_point64_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>);
    <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> { value: (quotient <b>as</b> u128) }
}
</code></pre>



</details>

<a id="0x1_fixed_point64_create_from_raw_value"></a>

## Function `create_from_raw_value`

Create a fixedpoint value from a raw value.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">create_from_raw_value</a>(value: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">create_from_raw_value</a>(value: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
    <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> { value }
}
</code></pre>



</details>

<a id="0x1_fixed_point64_get_raw_value"></a>

## Function `get_raw_value`

Accessor for the raw u128 value. Other less common operations, such as
adding or subtracting FixedPoint64 values, can be done using the raw
values directly.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">get_raw_value</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">get_raw_value</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
    num.value
}
</code></pre>



</details>

<a id="0x1_fixed_point64_is_zero"></a>

## Function `is_zero`

Returns true if the ratio is zero.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_is_zero">is_zero</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_is_zero">is_zero</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
    num.value == 0
}
</code></pre>



</details>

<a id="0x1_fixed_point64_min"></a>

## Function `min`

Returns the smaller of the two FixedPoint64 numbers.


<pre><code><b>public</b> <b>fun</b> <b>min</b>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <b>min</b>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
    <b>if</b> (num1.value &lt; num2.value) {
        num1
    } <b>else</b> {
        num2
    }
}
</code></pre>



</details>

<a id="0x1_fixed_point64_max"></a>

## Function `max`

Returns the larger of the two FixedPoint64 numbers.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_max">max</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_max">max</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
    <b>if</b> (num1.value &gt; num2.value) {
        num1
    } <b>else</b> {
        num2
    }
}
</code></pre>



</details>

<a id="0x1_fixed_point64_less_or_equal"></a>

## Function `less_or_equal`

Returns true if num1 <= num2


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_less_or_equal">less_or_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_less_or_equal">less_or_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
    num1.value &lt;= num2.value
}
</code></pre>



</details>

<a id="0x1_fixed_point64_less"></a>

## Function `less`

Returns true if num1 < num2


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_less">less</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_less">less</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
    num1.value &lt; num2.value
}
</code></pre>



</details>

<a id="0x1_fixed_point64_greater_or_equal"></a>

## Function `greater_or_equal`

Returns true if num1 >= num2


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_greater_or_equal">greater_or_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_greater_or_equal">greater_or_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
    num1.value &gt;= num2.value
}
</code></pre>



</details>

<a id="0x1_fixed_point64_greater"></a>

## Function `greater`

Returns true if num1 > num2


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_greater">greater</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_greater">greater</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
    num1.value &gt; num2.value
}
</code></pre>



</details>

<a id="0x1_fixed_point64_equal"></a>

## Function `equal`

Returns true if num1 = num2


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_equal">equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_equal">equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
    num1.value == num2.value
}
</code></pre>



</details>

<a id="0x1_fixed_point64_almost_equal"></a>

## Function `almost_equal`

Returns true if num1 almost equals to num2, which means abs(num1-num2) <= precision


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_almost_equal">almost_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, precision: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_almost_equal">almost_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, precision: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
    <b>if</b> (num1.value &gt; num2.value) {
        (num1.value - num2.value &lt;= precision.value)
    } <b>else</b> {
        (num2.value - num1.value &lt;= precision.value)
    }
}
</code></pre>



</details>

<a id="0x1_fixed_point64_create_from_u128"></a>

## Function `create_from_u128`

Create a fixedpoint value from a u128 value.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_u128">create_from_u128</a>(val: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_u128">create_from_u128</a>(val: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
    <b>let</b> value = (val <b>as</b> u256) &lt;&lt; 64;
    <b>assert</b>!(value &lt;= <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a>, <a href="fixed_point64.md#0x1_fixed_point64_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>);
    <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {value: (value <b>as</b> u128)}
}
</code></pre>



</details>

<a id="0x1_fixed_point64_floor"></a>

## Function `floor`

Returns the largest integer less than or equal to a given number.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_floor">floor</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_floor">floor</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
    num.value &gt;&gt; 64
}
</code></pre>



</details>

<a id="0x1_fixed_point64_ceil"></a>

## Function `ceil`

Rounds up the given FixedPoint64 to the next largest integer.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_ceil">ceil</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_ceil">ceil</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
    <b>let</b> floored_num = <a href="fixed_point64.md#0x1_fixed_point64_floor">floor</a>(num) &lt;&lt; 64;
    <b>if</b> (num.value == floored_num) {
        <b>return</b> floored_num &gt;&gt; 64
    };
    <b>let</b> val = ((floored_num <b>as</b> u256) + (1 &lt;&lt; 64));
    (val &gt;&gt; 64 <b>as</b> u128)
}
</code></pre>



</details>

<a id="0x1_fixed_point64_round"></a>

## Function `round`

Returns the value of a FixedPoint64 to the nearest integer.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_round">round</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_round">round</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
    <b>let</b> floored_num = <a href="fixed_point64.md#0x1_fixed_point64_floor">floor</a>(num) &lt;&lt; 64;
    <b>let</b> boundary = floored_num + ((1 &lt;&lt; 64) / 2);
    <b>if</b> (num.value &lt; boundary) {
        floored_num &gt;&gt; 64
    } <b>else</b> {
        <a href="fixed_point64.md#0x1_fixed_point64_ceil">ceil</a>(num)
    }
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification




<pre><code><b>pragma</b> aborts_if_is_strict;
</code></pre>



<a id="@Specification_1_sub"></a>

### Function `sub`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_sub">sub</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, y: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> x.value &lt; y.value <b>with</b> <a href="fixed_point64.md#0x1_fixed_point64_ENEGATIVE_RESULT">ENEGATIVE_RESULT</a>;
<b>ensures</b> result.value == x.value - y.value;
</code></pre>



<a id="@Specification_1_add"></a>

### Function `add`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_add">add</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, y: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> (x.value <b>as</b> u256) + (y.value <b>as</b> u256) &gt; <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a> <b>with</b> <a href="fixed_point64.md#0x1_fixed_point64_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>;
<b>ensures</b> result.value == x.value + y.value;
</code></pre>



<a id="@Specification_1_multiply_u128"></a>

### Function `multiply_u128`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_multiply_u128">multiply_u128</a>(val: u128, multiplier: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="fixed_point64.md#0x1_fixed_point64_MultiplyAbortsIf">MultiplyAbortsIf</a>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_multiply_u128">spec_multiply_u128</a>(val, multiplier);
</code></pre>




<a id="0x1_fixed_point64_MultiplyAbortsIf"></a>


<pre><code><b>schema</b> <a href="fixed_point64.md#0x1_fixed_point64_MultiplyAbortsIf">MultiplyAbortsIf</a> {
    val: num;
    multiplier: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>;
    <b>aborts_if</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_multiply_u128">spec_multiply_u128</a>(val, multiplier) &gt; <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a> <b>with</b> <a href="fixed_point64.md#0x1_fixed_point64_EMULTIPLICATION">EMULTIPLICATION</a>;
}
</code></pre>




<a id="0x1_fixed_point64_spec_multiply_u128"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_multiply_u128">spec_multiply_u128</a>(val: num, multiplier: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): num {
   (val * multiplier.value) &gt;&gt; 64
}
</code></pre>



<a id="@Specification_1_divide_u128"></a>

### Function `divide_u128`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_divide_u128">divide_u128</a>(val: u128, divisor: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="fixed_point64.md#0x1_fixed_point64_DivideAbortsIf">DivideAbortsIf</a>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_divide_u128">spec_divide_u128</a>(val, divisor);
</code></pre>




<a id="0x1_fixed_point64_DivideAbortsIf"></a>


<pre><code><b>schema</b> <a href="fixed_point64.md#0x1_fixed_point64_DivideAbortsIf">DivideAbortsIf</a> {
    val: num;
    divisor: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>;
    <b>aborts_if</b> divisor.value == 0 <b>with</b> <a href="fixed_point64.md#0x1_fixed_point64_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>;
    <b>aborts_if</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_divide_u128">spec_divide_u128</a>(val, divisor) &gt; <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a> <b>with</b> <a href="fixed_point64.md#0x1_fixed_point64_EDIVISION">EDIVISION</a>;
}
</code></pre>




<a id="0x1_fixed_point64_spec_divide_u128"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_divide_u128">spec_divide_u128</a>(val: num, divisor: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): num {
   (val &lt;&lt; 64) / divisor.value
}
</code></pre>



<a id="@Specification_1_create_from_rational"></a>

### Function `create_from_rational`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_rational">create_from_rational</a>(numerator: u128, denominator: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>pragma</b> verify_duration_estimate = 1000;
<b>include</b> <a href="fixed_point64.md#0x1_fixed_point64_CreateFromRationalAbortsIf">CreateFromRationalAbortsIf</a>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_create_from_rational">spec_create_from_rational</a>(numerator, denominator);
</code></pre>




<a id="0x1_fixed_point64_CreateFromRationalAbortsIf"></a>


<pre><code><b>schema</b> <a href="fixed_point64.md#0x1_fixed_point64_CreateFromRationalAbortsIf">CreateFromRationalAbortsIf</a> {
    numerator: u128;
    denominator: u128;
    <b>let</b> scaled_numerator = (numerator <b>as</b> u256)&lt;&lt; 64;
    <b>let</b> scaled_denominator = (denominator <b>as</b> u256);
    <b>let</b> quotient = scaled_numerator / scaled_denominator;
    <b>aborts_if</b> scaled_denominator == 0 <b>with</b> <a href="fixed_point64.md#0x1_fixed_point64_EDENOMINATOR">EDENOMINATOR</a>;
    <b>aborts_if</b> quotient == 0 && scaled_numerator != 0 <b>with</b> <a href="fixed_point64.md#0x1_fixed_point64_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>;
    <b>aborts_if</b> quotient &gt; <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a> <b>with</b> <a href="fixed_point64.md#0x1_fixed_point64_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>;
}
</code></pre>




<a id="0x1_fixed_point64_spec_create_from_rational"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_create_from_rational">spec_create_from_rational</a>(numerator: num, denominator: num): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
   <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>{value: (numerator &lt;&lt; 128) / (denominator &lt;&lt; 64)}
}
</code></pre>



<a id="@Specification_1_create_from_raw_value"></a>

### Function `create_from_raw_value`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">create_from_raw_value</a>(value: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result.value == value;
</code></pre>



<a id="@Specification_1_min"></a>

### Function `min`


<pre><code><b>public</b> <b>fun</b> <b>min</b>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_min">spec_min</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point64_spec_min"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_min">spec_min</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
   <b>if</b> (num1.value &lt; num2.value) {
       num1
   } <b>else</b> {
       num2
   }
}
</code></pre>



<a id="@Specification_1_max"></a>

### Function `max`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_max">max</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_max">spec_max</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point64_spec_max"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_max">spec_max</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
   <b>if</b> (num1.value &gt; num2.value) {
       num1
   } <b>else</b> {
       num2
   }
}
</code></pre>



<a id="@Specification_1_less_or_equal"></a>

### Function `less_or_equal`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_less_or_equal">less_or_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_less_or_equal">spec_less_or_equal</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point64_spec_less_or_equal"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_less_or_equal">spec_less_or_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
   num1.value &lt;= num2.value
}
</code></pre>



<a id="@Specification_1_less"></a>

### Function `less`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_less">less</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_less">spec_less</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point64_spec_less"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_less">spec_less</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
   num1.value &lt; num2.value
}
</code></pre>



<a id="@Specification_1_greater_or_equal"></a>

### Function `greater_or_equal`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_greater_or_equal">greater_or_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_greater_or_equal">spec_greater_or_equal</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point64_spec_greater_or_equal"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_greater_or_equal">spec_greater_or_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
   num1.value &gt;= num2.value
}
</code></pre>



<a id="@Specification_1_greater"></a>

### Function `greater`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_greater">greater</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_greater">spec_greater</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point64_spec_greater"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_greater">spec_greater</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
   num1.value &gt; num2.value
}
</code></pre>



<a id="@Specification_1_equal"></a>

### Function `equal`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_equal">equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_equal">spec_equal</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point64_spec_equal"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_equal">spec_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
   num1.value == num2.value
}
</code></pre>



<a id="@Specification_1_almost_equal"></a>

### Function `almost_equal`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_almost_equal">almost_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, precision: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_almost_equal">spec_almost_equal</a>(num1, num2, precision);
</code></pre>




<a id="0x1_fixed_point64_spec_almost_equal"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_almost_equal">spec_almost_equal</a>(num1: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, num2: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>, precision: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): bool {
   <b>if</b> (num1.value &gt; num2.value) {
       (num1.value - num2.value &lt;= precision.value)
   } <b>else</b> {
       (num2.value - num1.value &lt;= precision.value)
   }
}
</code></pre>



<a id="@Specification_1_create_from_u128"></a>

### Function `create_from_u128`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_create_from_u128">create_from_u128</a>(val: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="fixed_point64.md#0x1_fixed_point64_CreateFromU64AbortsIf">CreateFromU64AbortsIf</a>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_create_from_u128">spec_create_from_u128</a>(val);
</code></pre>




<a id="0x1_fixed_point64_CreateFromU64AbortsIf"></a>


<pre><code><b>schema</b> <a href="fixed_point64.md#0x1_fixed_point64_CreateFromU64AbortsIf">CreateFromU64AbortsIf</a> {
    val: num;
    <b>let</b> scaled_value = (val <b>as</b> u256) &lt;&lt; 64;
    <b>aborts_if</b> scaled_value &gt; <a href="fixed_point64.md#0x1_fixed_point64_MAX_U128">MAX_U128</a>;
}
</code></pre>




<a id="0x1_fixed_point64_spec_create_from_u128"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_create_from_u128">spec_create_from_u128</a>(val: num): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {
   <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a> {value: val &lt;&lt; 64}
}
</code></pre>



<a id="@Specification_1_floor"></a>

### Function `floor`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_floor">floor</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_floor">spec_floor</a>(num);
</code></pre>




<a id="0x1_fixed_point64_spec_floor"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_floor">spec_floor</a>(val: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
   <b>let</b> fractional = val.value % (1 &lt;&lt; 64);
   <b>if</b> (fractional == 0) {
       val.value &gt;&gt; 64
   } <b>else</b> {
       (val.value - fractional) &gt;&gt; 64
   }
}
</code></pre>



<a id="@Specification_1_ceil"></a>

### Function `ceil`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_ceil">ceil</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>




<pre><code><b>pragma</b> verify_duration_estimate = 1000;
<b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_ceil">spec_ceil</a>(num);
</code></pre>




<a id="0x1_fixed_point64_spec_ceil"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_ceil">spec_ceil</a>(val: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
   <b>let</b> fractional = val.value % (1 &lt;&lt; 64);
   <b>let</b> one = 1 &lt;&lt; 64;
   <b>if</b> (fractional == 0) {
       val.value &gt;&gt; 64
   } <b>else</b> {
       (val.value - fractional + one) &gt;&gt; 64
   }
}
</code></pre>



<a id="@Specification_1_round"></a>

### Function `round`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_round">round</a>(num: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): u128
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point64.md#0x1_fixed_point64_spec_round">spec_round</a>(num);
</code></pre>




<a id="0x1_fixed_point64_spec_round"></a>


<pre><code><b>fun</b> <a href="fixed_point64.md#0x1_fixed_point64_spec_round">spec_round</a>(val: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">FixedPoint64</a>): u128 {
   <b>let</b> fractional = val.value % (1 &lt;&lt; 64);
   <b>let</b> boundary = (1 &lt;&lt; 64) / 2;
   <b>let</b> one = 1 &lt;&lt; 64;
   <b>if</b> (fractional &lt; boundary) {
       (val.value - fractional) &gt;&gt; 64
   } <b>else</b> {
       (val.value - fractional + one) &gt;&gt; 64
   }
}
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/from_bcs.md
================================================

<a id="0x1_from_bcs"></a>

# Module `0x1::from_bcs`

This module provides a number of functions to convert _primitive_ types from their representation in <code>std::bcs</code>
to values. This is the opposite of <code><a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a></code>. Note that it is not safe to define a generic public <code>from_bytes</code>
function because this can violate implicit struct invariants, therefore only primitive types are offerred. If
a general conversion back-and-force is needed, consider the <code>aptos_std::Any</code> type which preserves invariants.

Example:
```
use std::bcs;
use aptos_std::from_bcs;

assert!(from_bcs::to_address(bcs::to_bytes(&@0xabcdef)) == @0xabcdef, 0);
```


-  [Constants](#@Constants_0)
-  [Function `to_bool`](#0x1_from_bcs_to_bool)
-  [Function `to_u8`](#0x1_from_bcs_to_u8)
-  [Function `to_u16`](#0x1_from_bcs_to_u16)
-  [Function `to_u32`](#0x1_from_bcs_to_u32)
-  [Function `to_u64`](#0x1_from_bcs_to_u64)
-  [Function `to_u128`](#0x1_from_bcs_to_u128)
-  [Function `to_u256`](#0x1_from_bcs_to_u256)
-  [Function `to_address`](#0x1_from_bcs_to_address)
-  [Function `to_bytes`](#0x1_from_bcs_to_bytes)
-  [Function `to_string`](#0x1_from_bcs_to_string)
-  [Function `from_bytes`](#0x1_from_bcs_from_bytes)
-  [Specification](#@Specification_1)
    -  [Function `from_bytes`](#@Specification_1_from_bytes)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/string.md#0x1_string">0x1::string</a>;
</code></pre>



<a id="@Constants_0"></a>

## Constants


<a id="0x1_from_bcs_EINVALID_UTF8"></a>

UTF8 check failed in conversion from bytes to string


<pre><code><b>const</b> <a href="from_bcs.md#0x1_from_bcs_EINVALID_UTF8">EINVALID_UTF8</a>: u64 = 1;
</code></pre>



<a id="0x1_from_bcs_to_bool"></a>

## Function `to_bool`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_bool">to_bool</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_bool">to_bool</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;bool&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_u8"></a>

## Function `to_u8`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u8">to_u8</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u8">to_u8</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u8 {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;u8&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_u16"></a>

## Function `to_u16`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u16">to_u16</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u16
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u16">to_u16</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u16 {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;u16&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_u32"></a>

## Function `to_u32`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u32">to_u32</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u32
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u32">to_u32</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u32 {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;u32&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_u64"></a>

## Function `to_u64`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u64">to_u64</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u64">to_u64</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64 {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;u64&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_u128"></a>

## Function `to_u128`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u128">to_u128</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u128">to_u128</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u128 {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;u128&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_u256"></a>

## Function `to_u256`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u256">to_u256</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_u256">to_u256</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u256 {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;u256&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_address"></a>

## Function `to_address`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_address">to_address</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_address">to_address</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <b>address</b> {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;<b>address</b>&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_bytes"></a>

## Function `to_bytes`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_bytes">to_bytes</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_bytes">to_bytes</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;&gt;(v)
}
</code></pre>



</details>

<a id="0x1_from_bcs_to_string"></a>

## Function `to_string`



<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_string">to_string</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_to_string">to_string</a>(v: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): String {
    // To make this safe, we need <b>to</b> evaluate the utf8 <b>invariant</b>.
    <b>let</b> s = <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;String&gt;(v);
    <b>assert</b>!(<a href="../../move-stdlib/doc/string.md#0x1_string_internal_check_utf8">string::internal_check_utf8</a>(<a href="../../move-stdlib/doc/string.md#0x1_string_bytes">string::bytes</a>(&s)), <a href="from_bcs.md#0x1_from_bcs_EINVALID_UTF8">EINVALID_UTF8</a>);
    s
}
</code></pre>



</details>

<a id="0x1_from_bcs_from_bytes"></a>

## Function `from_bytes`

Package private native function to deserialize a type T.

Note that this function does not put any constraint on <code>T</code>. If code uses this function to
deserialize a linear value, its their responsibility that the data they deserialize is
owned.


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;T&gt;(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b>(<b>friend</b>) <b>native</b> <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;T&gt;(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): T;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification



<a id="0x1_from_bcs_deserialize"></a>


<pre><code><b>fun</b> <a href="from_bcs.md#0x1_from_bcs_deserialize">deserialize</a>&lt;T&gt;(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): T;
<a id="0x1_from_bcs_deserializable"></a>
<b>fun</b> <a href="from_bcs.md#0x1_from_bcs_deserializable">deserializable</a>&lt;T&gt;(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool;
<b>axiom</b>&lt;T&gt; <b>forall</b> b1: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, b2: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;:
    ( b1 == b2 ==&gt; <a href="from_bcs.md#0x1_from_bcs_deserializable">deserializable</a>&lt;T&gt;(b1) == <a href="from_bcs.md#0x1_from_bcs_deserializable">deserializable</a>&lt;T&gt;(b2) );
<b>axiom</b>&lt;T&gt; <b>forall</b> b1: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, b2: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;:
    ( b1 == b2 ==&gt; <a href="from_bcs.md#0x1_from_bcs_deserialize">deserialize</a>&lt;T&gt;(b1) == <a href="from_bcs.md#0x1_from_bcs_deserialize">deserialize</a>&lt;T&gt;(b2) );
</code></pre>



<a id="@Specification_1_from_bytes"></a>

### Function `from_bytes`


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="from_bcs.md#0x1_from_bcs_from_bytes">from_bytes</a>&lt;T&gt;(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): T
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> !<a href="from_bcs.md#0x1_from_bcs_deserializable">deserializable</a>&lt;T&gt;(bytes);
<b>ensures</b> result == <a href="from_bcs.md#0x1_from_bcs_deserialize">deserialize</a>&lt;T&gt;(bytes);
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/hash.md
================================================

<a id="0x1_aptos_hash"></a>

# Module `0x1::aptos_hash`

Cryptographic hashes:
- Keccak-256: see https://keccak.team/keccak.html

In addition, SHA2-256 and SHA3-256 are available in <code>std::hash</code>. Note that SHA3-256 is a variant of Keccak: it is
NOT the same as Keccak-256.

Non-cryptograhic hashes:
- SipHash: an add-rotate-xor (ARX) based family of pseudorandom functions created by Jean-Philippe Aumasson and Daniel J. Bernstein in 2012


-  [Constants](#@Constants_0)
-  [Function `sip_hash`](#0x1_aptos_hash_sip_hash)
-  [Function `sip_hash_from_value`](#0x1_aptos_hash_sip_hash_from_value)
-  [Function `keccak256`](#0x1_aptos_hash_keccak256)
-  [Function `sha2_512`](#0x1_aptos_hash_sha2_512)
-  [Function `sha3_512`](#0x1_aptos_hash_sha3_512)
-  [Function `ripemd160`](#0x1_aptos_hash_ripemd160)
-  [Function `blake2b_256`](#0x1_aptos_hash_blake2b_256)
-  [Function `sha2_512_internal`](#0x1_aptos_hash_sha2_512_internal)
-  [Function `sha3_512_internal`](#0x1_aptos_hash_sha3_512_internal)
-  [Function `ripemd160_internal`](#0x1_aptos_hash_ripemd160_internal)
-  [Function `blake2b_256_internal`](#0x1_aptos_hash_blake2b_256_internal)
-  [Specification](#@Specification_1)
    -  [Function `sip_hash`](#@Specification_1_sip_hash)
    -  [Function `sip_hash_from_value`](#@Specification_1_sip_hash_from_value)
    -  [Function `keccak256`](#@Specification_1_keccak256)
    -  [Function `sha2_512`](#@Specification_1_sha2_512)
    -  [Function `sha3_512`](#@Specification_1_sha3_512)
    -  [Function `ripemd160`](#@Specification_1_ripemd160)
    -  [Function `blake2b_256`](#@Specification_1_blake2b_256)
    -  [Function `sha2_512_internal`](#@Specification_1_sha2_512_internal)
    -  [Function `sha3_512_internal`](#@Specification_1_sha3_512_internal)
    -  [Function `ripemd160_internal`](#@Specification_1_ripemd160_internal)
    -  [Function `blake2b_256_internal`](#@Specification_1_blake2b_256_internal)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/bcs.md#0x1_bcs">0x1::bcs</a>;
<b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/features.md#0x1_features">0x1::features</a>;
</code></pre>



<a id="@Constants_0"></a>

## Constants


<a id="0x1_aptos_hash_E_NATIVE_FUN_NOT_AVAILABLE"></a>

A newly-added native function is not yet enabled.


<pre><code><b>const</b> <a href="hash.md#0x1_aptos_hash_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>: u64 = 1;
</code></pre>



<a id="0x1_aptos_hash_sip_hash"></a>

## Function `sip_hash`

Returns the (non-cryptographic) SipHash of <code>bytes</code>. See https://en.wikipedia.org/wiki/SipHash


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sip_hash">sip_hash</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sip_hash">sip_hash</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64;
</code></pre>



</details>

<a id="0x1_aptos_hash_sip_hash_from_value"></a>

## Function `sip_hash_from_value`

Returns the (non-cryptographic) SipHash of the BCS serialization of <code>v</code>. See https://en.wikipedia.org/wiki/SipHash


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sip_hash_from_value">sip_hash_from_value</a>&lt;MoveValue&gt;(v: &MoveValue): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sip_hash_from_value">sip_hash_from_value</a>&lt;MoveValue&gt;(v: &MoveValue): u64 {
    <b>let</b> bytes = <a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a>(v);

    <a href="hash.md#0x1_aptos_hash_sip_hash">sip_hash</a>(bytes)
}
</code></pre>



</details>

<a id="0x1_aptos_hash_keccak256"></a>

## Function `keccak256`

Returns the Keccak-256 hash of <code>bytes</code>.


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_keccak256">keccak256</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_keccak256">keccak256</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>

<a id="0x1_aptos_hash_sha2_512"></a>

## Function `sha2_512`

Returns the SHA2-512 hash of <code>bytes</code>.


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sha2_512">sha2_512</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sha2_512">sha2_512</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <b>if</b>(!<a href="../../move-stdlib/doc/features.md#0x1_features_sha_512_and_ripemd_160_enabled">features::sha_512_and_ripemd_160_enabled</a>()) {
        <b>abort</b>(std::error::invalid_state(<a href="hash.md#0x1_aptos_hash_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>))
    };

    <a href="hash.md#0x1_aptos_hash_sha2_512_internal">sha2_512_internal</a>(bytes)
}
</code></pre>



</details>

<a id="0x1_aptos_hash_sha3_512"></a>

## Function `sha3_512`

Returns the SHA3-512 hash of <code>bytes</code>.


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sha3_512">sha3_512</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sha3_512">sha3_512</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <b>if</b>(!<a href="../../move-stdlib/doc/features.md#0x1_features_sha_512_and_ripemd_160_enabled">features::sha_512_and_ripemd_160_enabled</a>()) {
        <b>abort</b>(std::error::invalid_state(<a href="hash.md#0x1_aptos_hash_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>))
    };

    <a href="hash.md#0x1_aptos_hash_sha3_512_internal">sha3_512_internal</a>(bytes)
}
</code></pre>



</details>

<a id="0x1_aptos_hash_ripemd160"></a>

## Function `ripemd160`

Returns the RIPEMD-160 hash of <code>bytes</code>.

WARNING: Only 80-bit security is provided by this function. This means an adversary who can compute roughly 2^80
hashes will, with high probability, find a collision x_1 != x_2 such that RIPEMD-160(x_1) = RIPEMD-160(x_2).


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_ripemd160">ripemd160</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_ripemd160">ripemd160</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <b>if</b>(!<a href="../../move-stdlib/doc/features.md#0x1_features_sha_512_and_ripemd_160_enabled">features::sha_512_and_ripemd_160_enabled</a>()) {
        <b>abort</b>(std::error::invalid_state(<a href="hash.md#0x1_aptos_hash_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>))
    };

    <a href="hash.md#0x1_aptos_hash_ripemd160_internal">ripemd160_internal</a>(bytes)
}
</code></pre>



</details>

<a id="0x1_aptos_hash_blake2b_256"></a>

## Function `blake2b_256`

Returns the BLAKE2B-256 hash of <code>bytes</code>.


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_blake2b_256">blake2b_256</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_blake2b_256">blake2b_256</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <b>if</b>(!<a href="../../move-stdlib/doc/features.md#0x1_features_blake2b_256_enabled">features::blake2b_256_enabled</a>()) {
        <b>abort</b>(std::error::invalid_state(<a href="hash.md#0x1_aptos_hash_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>))
    };

    <a href="hash.md#0x1_aptos_hash_blake2b_256_internal">blake2b_256_internal</a>(bytes)
}
</code></pre>



</details>

<a id="0x1_aptos_hash_sha2_512_internal"></a>

## Function `sha2_512_internal`

Returns the SHA2-512 hash of <code>bytes</code>.


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_sha2_512_internal">sha2_512_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sha2_512_internal">sha2_512_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>

<a id="0x1_aptos_hash_sha3_512_internal"></a>

## Function `sha3_512_internal`

Returns the SHA3-512 hash of <code>bytes</code>.


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_sha3_512_internal">sha3_512_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sha3_512_internal">sha3_512_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>

<a id="0x1_aptos_hash_ripemd160_internal"></a>

## Function `ripemd160_internal`

Returns the RIPEMD-160 hash of <code>bytes</code>.

WARNING: Only 80-bit security is provided by this function. This means an adversary who can compute roughly 2^80
hashes will, with high probability, find a collision x_1 != x_2 such that RIPEMD-160(x_1) = RIPEMD-160(x_2).


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_ripemd160_internal">ripemd160_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_ripemd160_internal">ripemd160_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>

<a id="0x1_aptos_hash_blake2b_256_internal"></a>

## Function `blake2b_256_internal`

Returns the BLAKE2B-256 hash of <code>bytes</code>.


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_blake2b_256_internal">blake2b_256_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_blake2b_256_internal">blake2b_256_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<code>spec_sip_hash</code> is not assumed to be injective.


<a id="0x1_aptos_hash_spec_sip_hash"></a>


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_spec_sip_hash">spec_sip_hash</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64;
</code></pre>


<code>spec_keccak256</code> is an injective function.


<a id="0x1_aptos_hash_spec_keccak256"></a>


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_spec_keccak256">spec_keccak256</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
<b>axiom</b> <b>forall</b> b1: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, b2: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;:
    (<a href="hash.md#0x1_aptos_hash_spec_keccak256">spec_keccak256</a>(b1) == <a href="hash.md#0x1_aptos_hash_spec_keccak256">spec_keccak256</a>(b2) ==&gt; b1 == b2);
</code></pre>


<code>spec_sha2_512_internal</code> is an injective function.


<a id="0x1_aptos_hash_spec_sha2_512_internal"></a>


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_spec_sha2_512_internal">spec_sha2_512_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
<b>axiom</b> <b>forall</b> b1: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, b2: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;:
    (<a href="hash.md#0x1_aptos_hash_spec_sha2_512_internal">spec_sha2_512_internal</a>(b1) == <a href="hash.md#0x1_aptos_hash_spec_sha2_512_internal">spec_sha2_512_internal</a>(b2) ==&gt; b1 == b2);
</code></pre>


<code>spec_sha3_512_internal</code> is an injective function.


<a id="0x1_aptos_hash_spec_sha3_512_internal"></a>


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_spec_sha3_512_internal">spec_sha3_512_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
<b>axiom</b> <b>forall</b> b1: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, b2: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;:
    (<a href="hash.md#0x1_aptos_hash_spec_sha3_512_internal">spec_sha3_512_internal</a>(b1) == <a href="hash.md#0x1_aptos_hash_spec_sha3_512_internal">spec_sha3_512_internal</a>(b2) ==&gt; b1 == b2);
</code></pre>


<code>spec_ripemd160_internal</code> is an injective function.


<a id="0x1_aptos_hash_spec_ripemd160_internal"></a>


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_spec_ripemd160_internal">spec_ripemd160_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
<b>axiom</b> <b>forall</b> b1: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, b2: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;:
    (<a href="hash.md#0x1_aptos_hash_spec_ripemd160_internal">spec_ripemd160_internal</a>(b1) == <a href="hash.md#0x1_aptos_hash_spec_ripemd160_internal">spec_ripemd160_internal</a>(b2) ==&gt; b1 == b2);
</code></pre>


<code>spec_blake2b_256_internal</code> is an injective function.


<a id="0x1_aptos_hash_spec_blake2b_256_internal"></a>


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_spec_blake2b_256_internal">spec_blake2b_256_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
<b>axiom</b> <b>forall</b> b1: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, b2: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;:
    (<a href="hash.md#0x1_aptos_hash_spec_blake2b_256_internal">spec_blake2b_256_internal</a>(b1) == <a href="hash.md#0x1_aptos_hash_spec_blake2b_256_internal">spec_blake2b_256_internal</a>(b2) ==&gt; b1 == b2);
</code></pre>



<a id="@Specification_1_sip_hash"></a>

### Function `sip_hash`


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sip_hash">sip_hash</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="hash.md#0x1_aptos_hash_spec_sip_hash">spec_sip_hash</a>(bytes);
</code></pre>



<a id="@Specification_1_sip_hash_from_value"></a>

### Function `sip_hash_from_value`


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sip_hash_from_value">sip_hash_from_value</a>&lt;MoveValue&gt;(v: &MoveValue): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>ensures</b> result == <a href="hash.md#0x1_aptos_hash_spec_sip_hash">spec_sip_hash</a>(<a href="../../move-stdlib/doc/bcs.md#0x1_bcs_serialize">bcs::serialize</a>(v));
</code></pre>



<a id="@Specification_1_keccak256"></a>

### Function `keccak256`


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_keccak256">keccak256</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="hash.md#0x1_aptos_hash_spec_keccak256">spec_keccak256</a>(bytes);
</code></pre>



<a id="@Specification_1_sha2_512"></a>

### Function `sha2_512`


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sha2_512">sha2_512</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> !<a href="../../move-stdlib/doc/features.md#0x1_features_spec_is_enabled">features::spec_is_enabled</a>(<a href="../../move-stdlib/doc/features.md#0x1_features_SHA_512_AND_RIPEMD_160_NATIVES">features::SHA_512_AND_RIPEMD_160_NATIVES</a>);
<b>ensures</b> result == <a href="hash.md#0x1_aptos_hash_spec_sha2_512_internal">spec_sha2_512_internal</a>(bytes);
</code></pre>



<a id="@Specification_1_sha3_512"></a>

### Function `sha3_512`


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_sha3_512">sha3_512</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> !<a href="../../move-stdlib/doc/features.md#0x1_features_spec_is_enabled">features::spec_is_enabled</a>(<a href="../../move-stdlib/doc/features.md#0x1_features_SHA_512_AND_RIPEMD_160_NATIVES">features::SHA_512_AND_RIPEMD_160_NATIVES</a>);
<b>ensures</b> result == <a href="hash.md#0x1_aptos_hash_spec_sha3_512_internal">spec_sha3_512_internal</a>(bytes);
</code></pre>



<a id="@Specification_1_ripemd160"></a>

### Function `ripemd160`


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_ripemd160">ripemd160</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> !<a href="../../move-stdlib/doc/features.md#0x1_features_spec_is_enabled">features::spec_is_enabled</a>(<a href="../../move-stdlib/doc/features.md#0x1_features_SHA_512_AND_RIPEMD_160_NATIVES">features::SHA_512_AND_RIPEMD_160_NATIVES</a>);
<b>ensures</b> result == <a href="hash.md#0x1_aptos_hash_spec_ripemd160_internal">spec_ripemd160_internal</a>(bytes);
</code></pre>



<a id="@Specification_1_blake2b_256"></a>

### Function `blake2b_256`


<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_aptos_hash_blake2b_256">blake2b_256</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> !<a href="../../move-stdlib/doc/features.md#0x1_features_spec_is_enabled">features::spec_is_enabled</a>(<a href="../../move-stdlib/doc/features.md#0x1_features_BLAKE2B_256_NATIVE">features::BLAKE2B_256_NATIVE</a>);
<b>ensures</b> result == <a href="hash.md#0x1_aptos_hash_spec_blake2b_256_internal">spec_blake2b_256_internal</a>(bytes);
</code></pre>



<a id="@Specification_1_sha2_512_internal"></a>

### Function `sha2_512_internal`


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_sha2_512_internal">sha2_512_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="hash.md#0x1_aptos_hash_spec_sha2_512_internal">spec_sha2_512_internal</a>(bytes);
</code></pre>



<a id="@Specification_1_sha3_512_internal"></a>

### Function `sha3_512_internal`


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_sha3_512_internal">sha3_512_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="hash.md#0x1_aptos_hash_spec_sha3_512_internal">spec_sha3_512_internal</a>(bytes);
</code></pre>



<a id="@Specification_1_ripemd160_internal"></a>

### Function `ripemd160_internal`


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_ripemd160_internal">ripemd160_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="hash.md#0x1_aptos_hash_spec_ripemd160_internal">spec_ripemd160_internal</a>(bytes);
</code></pre>



<a id="@Specification_1_blake2b_256_internal"></a>

### Function `blake2b_256_internal`


<pre><code><b>fun</b> <a href="hash.md#0x1_aptos_hash_blake2b_256_internal">blake2b_256_internal</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="hash.md#0x1_aptos_hash_spec_blake2b_256_internal">spec_blake2b_256_internal</a>(bytes);
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/math128.md
================================================

<a id="0x1_math128"></a>

# Module `0x1::math128`

Standard math utilities missing in the Move Language.


-  [Constants](#@Constants_0)
-  [Function `max`](#0x1_math128_max)
-  [Function `min`](#0x1_math128_min)
-  [Function `average`](#0x1_math128_average)
-  [Function `gcd`](#0x1_math128_gcd)
-  [Function `mul_div`](#0x1_math128_mul_div)
-  [Function `clamp`](#0x1_math128_clamp)
-  [Function `pow`](#0x1_math128_pow)
-  [Function `floor_log2`](#0x1_math128_floor_log2)
-  [Function `log2`](#0x1_math128_log2)
-  [Function `log2_64`](#0x1_math128_log2_64)
-  [Function `sqrt`](#0x1_math128_sqrt)
-  [Function `ceil_div`](#0x1_math128_ceil_div)
-  [Specification](#@Specification_1)
    -  [Function `max`](#@Specification_1_max)
    -  [Function `min`](#@Specification_1_min)
    -  [Function `average`](#@Specification_1_average)
    -  [Function `clamp`](#@Specification_1_clamp)
    -  [Function `pow`](#@Specification_1_pow)
    -  [Function `floor_log2`](#@Specification_1_floor_log2)
    -  [Function `sqrt`](#@Specification_1_sqrt)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32">0x1::fixed_point32</a>;
<b>use</b> <a href="fixed_point64.md#0x1_fixed_point64">0x1::fixed_point64</a>;
</code></pre>



<a id="@Constants_0"></a>

## Constants


<a id="0x1_math128_EINVALID_ARG_FLOOR_LOG2"></a>

Cannot log2 the value 0


<pre><code><b>const</b> <a href="math128.md#0x1_math128_EINVALID_ARG_FLOOR_LOG2">EINVALID_ARG_FLOOR_LOG2</a>: u64 = 1;
</code></pre>



<a id="0x1_math128_max"></a>

## Function `max`

Return the largest of two numbers.


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_max">max</a>(a: u128, b: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_max">max</a>(a: u128, b: u128): u128 {
    <b>if</b> (a &gt;= b) a <b>else</b> b
}
</code></pre>



</details>

<a id="0x1_math128_min"></a>

## Function `min`

Return the smallest of two numbers.


<pre><code><b>public</b> <b>fun</b> <b>min</b>(a: u128, b: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <b>min</b>(a: u128, b: u128): u128 {
    <b>if</b> (a &lt; b) a <b>else</b> b
}
</code></pre>



</details>

<a id="0x1_math128_average"></a>

## Function `average`

Return the average of two.


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_average">average</a>(a: u128, b: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_average">average</a>(a: u128, b: u128): u128 {
    <b>if</b> (a &lt; b) {
        a + (b - a) / 2
    } <b>else</b> {
        b + (a - b) / 2
    }
}
</code></pre>



</details>

<a id="0x1_math128_gcd"></a>

## Function `gcd`

Return greatest common divisor of <code>a</code> & <code>b</code>, via the Euclidean algorithm.


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_gcd">gcd</a>(a: u128, b: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="math128.md#0x1_math128_gcd">gcd</a>(a: u128, b: u128): u128 {
    <b>let</b> (large, small) = <b>if</b> (a &gt; b) (a, b) <b>else</b> (b, a);
    <b>while</b> (small != 0) {
        <b>let</b> tmp = small;
        small = large % small;
        large = tmp;
    };
    large
}
</code></pre>



</details>

<a id="0x1_math128_mul_div"></a>

## Function `mul_div`

Returns a * b / c going through u256 to prevent intermediate overflow


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_mul_div">mul_div</a>(a: u128, b: u128, c: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="math128.md#0x1_math128_mul_div">mul_div</a>(a: u128, b: u128, c: u128): u128 {
    // Inline functions cannot take constants, <b>as</b> then every <b>module</b> using it needs the constant
    <b>assert</b>!(c != 0, std::error::invalid_argument(4));
    (((a <b>as</b> u256) * (b <b>as</b> u256) / (c <b>as</b> u256)) <b>as</b> u128)
}
</code></pre>



</details>

<a id="0x1_math128_clamp"></a>

## Function `clamp`

Return x clamped to the interval [lower, upper].


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_clamp">clamp</a>(x: u128, lower: u128, upper: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_clamp">clamp</a>(x: u128, lower: u128, upper: u128): u128 {
    <b>min</b>(upper, <a href="math128.md#0x1_math128_max">max</a>(lower, x))
}
</code></pre>



</details>

<a id="0x1_math128_pow"></a>

## Function `pow`

Return the value of n raised to power e


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_pow">pow</a>(n: u128, e: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_pow">pow</a>(n: u128, e: u128): u128 {
    <b>if</b> (e == 0) {
        1
    } <b>else</b> {
        <b>let</b> p = 1;
        <b>while</b> (e &gt; 1) {
            <b>if</b> (e % 2 == 1) {
                p = p * n;
            };
            e = e / 2;
            n = n * n;
        };
        p * n
    }
}
</code></pre>



</details>

<a id="0x1_math128_floor_log2"></a>

## Function `floor_log2`

Returns floor(log2(x))


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_floor_log2">floor_log2</a>(x: u128): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_floor_log2">floor_log2</a>(x: u128): u8 {
    <b>let</b> res = 0;
    <b>assert</b>!(x != 0, std::error::invalid_argument(<a href="math128.md#0x1_math128_EINVALID_ARG_FLOOR_LOG2">EINVALID_ARG_FLOOR_LOG2</a>));
    // Effectively the position of the most significant set bit
    <b>let</b> n = 64;
    <b>while</b> (n &gt; 0) {
        <b>if</b> (x &gt;= (1 &lt;&lt; n)) {
            x = x &gt;&gt; n;
            res = res + n;
        };
        n = n &gt;&gt; 1;
    };
    res
}
</code></pre>



</details>

<a id="0x1_math128_log2"></a>

## Function `log2`



<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_log2">log2</a>(x: u128): <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_log2">log2</a>(x: u128): FixedPoint32 {
    <b>let</b> integer_part = <a href="math128.md#0x1_math128_floor_log2">floor_log2</a>(x);
    // Normalize x <b>to</b> [1, 2) in fixed point 32.
    <b>if</b> (x &gt;= 1 &lt;&lt; 32) {
        x = x &gt;&gt; (integer_part - 32);
    } <b>else</b> {
        x = x &lt;&lt; (32 - integer_part);
    };
    <b>let</b> frac = 0;
    <b>let</b> delta = 1 &lt;&lt; 31;
    <b>while</b> (delta != 0) {
        // log x = 1/2 log x^2
        // x in [1, 2)
        x = (x * x) &gt;&gt; 32;
        // x is now in [1, 4)
        // <b>if</b> x in [2, 4) then log x = 1 + log (x / 2)
        <b>if</b> (x &gt;= (2 &lt;&lt; 32)) { frac = frac + delta; x = x &gt;&gt; 1; };
        delta = delta &gt;&gt; 1;
    };
    <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_create_from_raw_value">fixed_point32::create_from_raw_value</a> (((integer_part <b>as</b> u64) &lt;&lt; 32) + frac)
}
</code></pre>



</details>

<a id="0x1_math128_log2_64"></a>

## Function `log2_64`



<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_log2_64">log2_64</a>(x: u128): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_log2_64">log2_64</a>(x: u128): FixedPoint64 {
    <b>let</b> integer_part = <a href="math128.md#0x1_math128_floor_log2">floor_log2</a>(x);
    // Normalize x <b>to</b> [1, 2) in fixed point 63. To ensure x is smaller then 1&lt;&lt;64
    <b>if</b> (x &gt;= 1 &lt;&lt; 63) {
        x = x &gt;&gt; (integer_part - 63);
    } <b>else</b> {
        x = x &lt;&lt; (63 - integer_part);
    };
    <b>let</b> frac = 0;
    <b>let</b> delta = 1 &lt;&lt; 63;
    <b>while</b> (delta != 0) {
        // log x = 1/2 log x^2
        // x in [1, 2)
        x = (x * x) &gt;&gt; 63;
        // x is now in [1, 4)
        // <b>if</b> x in [2, 4) then log x = 1 + log (x / 2)
        <b>if</b> (x &gt;= (2 &lt;&lt; 63)) { frac = frac + delta; x = x &gt;&gt; 1; };
        delta = delta &gt;&gt; 1;
    };
    <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">fixed_point64::create_from_raw_value</a> (((integer_part <b>as</b> u128) &lt;&lt; 64) + frac)
}
</code></pre>



</details>

<a id="0x1_math128_sqrt"></a>

## Function `sqrt`

Returns square root of x, precisely floor(sqrt(x))


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_sqrt">sqrt</a>(x: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_sqrt">sqrt</a>(x: u128): u128 {
    <b>if</b> (x == 0) <b>return</b> 0;
    // Note the plus 1 in the expression. Let n = floor_lg2(x) we have x in [2^n, 2^{n+1}) and thus the answer in
    // the half-open interval [2^(n/2), 2^{(n+1)/2}). For even n we can write this <b>as</b> [2^(n/2), <a href="math128.md#0x1_math128_sqrt">sqrt</a>(2) 2^{n/2})
    // for odd n [2^((n+1)/2)/<a href="math128.md#0x1_math128_sqrt">sqrt</a>(2), 2^((n+1)/2). For even n the left end point is integer for odd the right
    // end point is integer. If we <b>choose</b> <b>as</b> our first approximation the integer end point we have <b>as</b> maximum
    // relative <a href="../../move-stdlib/doc/error.md#0x1_error">error</a> either (<a href="math128.md#0x1_math128_sqrt">sqrt</a>(2) - 1) or (1 - 1/<a href="math128.md#0x1_math128_sqrt">sqrt</a>(2)) both are smaller then 1/2.
    <b>let</b> res = 1 &lt;&lt; ((<a href="math128.md#0x1_math128_floor_log2">floor_log2</a>(x) + 1) &gt;&gt; 1);
    // We <b>use</b> standard newton-rhapson iteration <b>to</b> improve the initial approximation.
    // The <a href="../../move-stdlib/doc/error.md#0x1_error">error</a> term evolves <b>as</b> delta_i+1 = delta_i^2 / 2 (quadratic convergence).
    // It turns out that after 5 iterations the delta is smaller than 2^-64 and thus below the treshold.
    res = (res + x / res) &gt;&gt; 1;
    res = (res + x / res) &gt;&gt; 1;
    res = (res + x / res) &gt;&gt; 1;
    res = (res + x / res) &gt;&gt; 1;
    res = (res + x / res) &gt;&gt; 1;
    <b>min</b>(res, x / res)
}
</code></pre>



</details>

<a id="0x1_math128_ceil_div"></a>

## Function `ceil_div`



<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_ceil_div">ceil_div</a>(x: u128, y: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="math128.md#0x1_math128_ceil_div">ceil_div</a>(x: u128, y: u128): u128 {
    // <a href="math128.md#0x1_math128_ceil_div">ceil_div</a>(x, y) = floor((x + y - 1) / y) = floor((x - 1) / y) + 1
    // (x + y - 1) could spuriously overflow. so we <b>use</b> the later version
    <b>if</b> (x == 0) {
        // Inline functions cannot take constants, <b>as</b> then every <b>module</b> using it needs the constant
        <b>assert</b>!(y != 0, std::error::invalid_argument(4));
        0
    }
    <b>else</b> (x - 1) / y + 1
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_max"></a>

### Function `max`


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_max">max</a>(a: u128, b: u128): u128
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> a &gt;= b ==&gt; result == a;
<b>ensures</b> a &lt; b ==&gt; result == b;
</code></pre>



<a id="@Specification_1_min"></a>

### Function `min`


<pre><code><b>public</b> <b>fun</b> <b>min</b>(a: u128, b: u128): u128
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> a &lt; b ==&gt; result == a;
<b>ensures</b> a &gt;= b ==&gt; result == b;
</code></pre>



<a id="@Specification_1_average"></a>

### Function `average`


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_average">average</a>(a: u128, b: u128): u128
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == (a + b) / 2;
</code></pre>



<a id="@Specification_1_clamp"></a>

### Function `clamp`


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_clamp">clamp</a>(x: u128, lower: u128, upper: u128): u128
</code></pre>




<pre><code><b>requires</b> (lower &lt;= upper);
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> (lower &lt;=x && x &lt;= upper) ==&gt; result == x;
<b>ensures</b> (x &lt; lower) ==&gt; result == lower;
<b>ensures</b> (upper &lt; x) ==&gt; result == upper;
</code></pre>



<a id="@Specification_1_pow"></a>

### Function `pow`


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_pow">pow</a>(n: u128, e: u128): u128
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <a href="math128.md#0x1_math128_spec_pow">spec_pow</a>(n, e) &gt; MAX_U128;
<b>ensures</b> [abstract] result == <a href="math128.md#0x1_math128_spec_pow">spec_pow</a>(n, e);
</code></pre>



<a id="@Specification_1_floor_log2"></a>

### Function `floor_log2`


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_floor_log2">floor_log2</a>(x: u128): u8
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] x == 0;
<b>ensures</b> [abstract] <a href="math128.md#0x1_math128_spec_pow">spec_pow</a>(2, result) &lt;= x;
<b>ensures</b> [abstract] x &lt; <a href="math128.md#0x1_math128_spec_pow">spec_pow</a>(2, result+1);
</code></pre>



<a id="@Specification_1_sqrt"></a>

### Function `sqrt`


<pre><code><b>public</b> <b>fun</b> <a href="math128.md#0x1_math128_sqrt">sqrt</a>(x: u128): u128
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] x &gt; 0 ==&gt; result * result &lt;= x;
<b>ensures</b> [abstract] x &gt; 0 ==&gt; x &lt; (result+1) * (result+1);
</code></pre>




<a id="0x1_math128_spec_pow"></a>


<pre><code><b>fun</b> <a href="math128.md#0x1_math128_spec_pow">spec_pow</a>(n: u128, e: u128): u128 {
   <b>if</b> (e == 0) {
       1
   }
   <b>else</b> {
       n * <a href="math128.md#0x1_math128_spec_pow">spec_pow</a>(n, e-1)
   }
}
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/math64.md
================================================

<a id="0x1_math64"></a>

# Module `0x1::math64`

Standard math utilities missing in the Move Language.


-  [Constants](#@Constants_0)
-  [Function `max`](#0x1_math64_max)
-  [Function `min`](#0x1_math64_min)
-  [Function `average`](#0x1_math64_average)
-  [Function `gcd`](#0x1_math64_gcd)
-  [Function `mul_div`](#0x1_math64_mul_div)
-  [Function `clamp`](#0x1_math64_clamp)
-  [Function `pow`](#0x1_math64_pow)
-  [Function `floor_log2`](#0x1_math64_floor_log2)
-  [Function `log2`](#0x1_math64_log2)
-  [Function `sqrt`](#0x1_math64_sqrt)
-  [Function `ceil_div`](#0x1_math64_ceil_div)
-  [Specification](#@Specification_1)
    -  [Function `max`](#@Specification_1_max)
    -  [Function `min`](#@Specification_1_min)
    -  [Function `average`](#@Specification_1_average)
    -  [Function `clamp`](#@Specification_1_clamp)
    -  [Function `pow`](#@Specification_1_pow)
    -  [Function `floor_log2`](#@Specification_1_floor_log2)
    -  [Function `sqrt`](#@Specification_1_sqrt)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32">0x1::fixed_point32</a>;
</code></pre>



<a id="@Constants_0"></a>

## Constants


<a id="0x1_math64_EINVALID_ARG_FLOOR_LOG2"></a>

Cannot log2 the value 0


<pre><code><b>const</b> <a href="math64.md#0x1_math64_EINVALID_ARG_FLOOR_LOG2">EINVALID_ARG_FLOOR_LOG2</a>: u64 = 1;
</code></pre>



<a id="0x1_math64_max"></a>

## Function `max`

Return the largest of two numbers.


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_max">max</a>(a: u64, b: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_max">max</a>(a: u64, b: u64): u64 {
    <b>if</b> (a &gt;= b) a <b>else</b> b
}
</code></pre>



</details>

<a id="0x1_math64_min"></a>

## Function `min`

Return the smallest of two numbers.


<pre><code><b>public</b> <b>fun</b> <b>min</b>(a: u64, b: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <b>min</b>(a: u64, b: u64): u64 {
    <b>if</b> (a &lt; b) a <b>else</b> b
}
</code></pre>



</details>

<a id="0x1_math64_average"></a>

## Function `average`

Return the average of two.


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_average">average</a>(a: u64, b: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_average">average</a>(a: u64, b: u64): u64 {
    <b>if</b> (a &lt; b) {
        a + (b - a) / 2
    } <b>else</b> {
        b + (a - b) / 2
    }
}
</code></pre>



</details>

<a id="0x1_math64_gcd"></a>

## Function `gcd`

Return greatest common divisor of <code>a</code> & <code>b</code>, via the Euclidean algorithm.


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_gcd">gcd</a>(a: u64, b: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="math64.md#0x1_math64_gcd">gcd</a>(a: u64, b: u64): u64 {
    <b>let</b> (large, small) = <b>if</b> (a &gt; b) (a, b) <b>else</b> (b, a);
    <b>while</b> (small != 0) {
        <b>let</b> tmp = small;
        small = large % small;
        large = tmp;
    };
    large
}
</code></pre>



</details>

<a id="0x1_math64_mul_div"></a>

## Function `mul_div`

Returns a * b / c going through u128 to prevent intermediate overflow


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_mul_div">mul_div</a>(a: u64, b: u64, c: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="math64.md#0x1_math64_mul_div">mul_div</a>(a: u64, b: u64, c: u64): u64 {
    // Inline functions cannot take constants, <b>as</b> then every <b>module</b> using it needs the constant
    <b>assert</b>!(c != 0, std::error::invalid_argument(4));
    (((a <b>as</b> u128) * (b <b>as</b> u128) / (c <b>as</b> u128)) <b>as</b> u64)
}
</code></pre>



</details>

<a id="0x1_math64_clamp"></a>

## Function `clamp`

Return x clamped to the interval [lower, upper].


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_clamp">clamp</a>(x: u64, lower: u64, upper: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_clamp">clamp</a>(x: u64, lower: u64, upper: u64): u64 {
    <b>min</b>(upper, <a href="math64.md#0x1_math64_max">max</a>(lower, x))
}
</code></pre>



</details>

<a id="0x1_math64_pow"></a>

## Function `pow`

Return the value of n raised to power e


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_pow">pow</a>(n: u64, e: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_pow">pow</a>(n: u64, e: u64): u64 {
    <b>if</b> (e == 0) {
        1
    } <b>else</b> {
        <b>let</b> p = 1;
        <b>while</b> (e &gt; 1) {
            <b>if</b> (e % 2 == 1) {
                p = p * n;
            };
            e = e / 2;
            n = n * n;
        };
        p * n
    }
}
</code></pre>



</details>

<a id="0x1_math64_floor_log2"></a>

## Function `floor_log2`

Returns floor(lg2(x))


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_floor_log2">floor_log2</a>(x: u64): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_floor_log2">floor_log2</a>(x: u64): u8 {
    <b>let</b> res = 0;
    <b>assert</b>!(x != 0, std::error::invalid_argument(<a href="math64.md#0x1_math64_EINVALID_ARG_FLOOR_LOG2">EINVALID_ARG_FLOOR_LOG2</a>));
    // Effectively the position of the most significant set bit
    <b>let</b> n = 32;
    <b>while</b> (n &gt; 0) {
        <b>if</b> (x &gt;= (1 &lt;&lt; n)) {
            x = x &gt;&gt; n;
            res = res + n;
        };
        n = n &gt;&gt; 1;
    };
    res
}
</code></pre>



</details>

<a id="0x1_math64_log2"></a>

## Function `log2`



<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_log2">log2</a>(x: u64): <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_log2">log2</a>(x: u64): FixedPoint32 {
    <b>let</b> integer_part = <a href="math64.md#0x1_math64_floor_log2">floor_log2</a>(x);
    // Normalize x <b>to</b> [1, 2) in fixed point 32.
    <b>let</b> y = (<b>if</b> (x &gt;= 1 &lt;&lt; 32) {
        x &gt;&gt; (integer_part - 32)
    } <b>else</b> {
        x &lt;&lt; (32 - integer_part)
    } <b>as</b> u128);
    <b>let</b> frac = 0;
    <b>let</b> delta = 1 &lt;&lt; 31;
    <b>while</b> (delta != 0) {
        // log x = 1/2 log x^2
        // x in [1, 2)
        y = (y * y) &gt;&gt; 32;
        // x is now in [1, 4)
        // <b>if</b> x in [2, 4) then log x = 1 + log (x / 2)
        <b>if</b> (y &gt;= (2 &lt;&lt; 32)) { frac = frac + delta; y = y &gt;&gt; 1; };
        delta = delta &gt;&gt; 1;
    };
    <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_create_from_raw_value">fixed_point32::create_from_raw_value</a> (((integer_part <b>as</b> u64) &lt;&lt; 32) + frac)
}
</code></pre>



</details>

<a id="0x1_math64_sqrt"></a>

## Function `sqrt`

Returns square root of x, precisely floor(sqrt(x))


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_sqrt">sqrt</a>(x: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_sqrt">sqrt</a>(x: u64): u64 {
    <b>if</b> (x == 0) <b>return</b> 0;
    // Note the plus 1 in the expression. Let n = floor_lg2(x) we have x in [2^n, 2^(n+1)&gt; and thus the answer in
    // the half-open interval [2^(n/2), 2^((n+1)/2)&gt;. For even n we can write this <b>as</b> [2^(n/2), <a href="math64.md#0x1_math64_sqrt">sqrt</a>(2) 2^(n/2)&gt;
    // for odd n [2^((n+1)/2)/<a href="math64.md#0x1_math64_sqrt">sqrt</a>(2), 2^((n+1)/2&gt;. For even n the left end point is integer for odd the right
    // end point is integer. If we <b>choose</b> <b>as</b> our first approximation the integer end point we have <b>as</b> maximum
    // relative <a href="../../move-stdlib/doc/error.md#0x1_error">error</a> either (<a href="math64.md#0x1_math64_sqrt">sqrt</a>(2) - 1) or (1 - 1/<a href="math64.md#0x1_math64_sqrt">sqrt</a>(2)) both are smaller then 1/2.
    <b>let</b> res = 1 &lt;&lt; ((<a href="math64.md#0x1_math64_floor_log2">floor_log2</a>(x) + 1) &gt;&gt; 1);
    // We <b>use</b> standard newton-rhapson iteration <b>to</b> improve the initial approximation.
    // The <a href="../../move-stdlib/doc/error.md#0x1_error">error</a> term evolves <b>as</b> delta_i+1 = delta_i^2 / 2 (quadratic convergence).
    // It turns out that after 4 iterations the delta is smaller than 2^-32 and thus below the treshold.
    res = (res + x / res) &gt;&gt; 1;
    res = (res + x / res) &gt;&gt; 1;
    res = (res + x / res) &gt;&gt; 1;
    res = (res + x / res) &gt;&gt; 1;
    <b>min</b>(res, x / res)
}
</code></pre>



</details>

<a id="0x1_math64_ceil_div"></a>

## Function `ceil_div`



<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_ceil_div">ceil_div</a>(x: u64, y: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="math64.md#0x1_math64_ceil_div">ceil_div</a>(x: u64, y: u64): u64 {
    // <a href="math64.md#0x1_math64_ceil_div">ceil_div</a>(x, y) = floor((x + y - 1) / y) = floor((x - 1) / y) + 1
    // (x + y - 1) could spuriously overflow. so we <b>use</b> the later version
    <b>if</b> (x == 0) {
        // Inline functions cannot take constants, <b>as</b> then every <b>module</b> using it needs the constant
        <b>assert</b>!(y != 0, std::error::invalid_argument(4));
        0
    }
    <b>else</b> (x - 1) / y + 1
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_max"></a>

### Function `max`


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_max">max</a>(a: u64, b: u64): u64
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> a &gt;= b ==&gt; result == a;
<b>ensures</b> a &lt; b ==&gt; result == b;
</code></pre>



<a id="@Specification_1_min"></a>

### Function `min`


<pre><code><b>public</b> <b>fun</b> <b>min</b>(a: u64, b: u64): u64
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> a &lt; b ==&gt; result == a;
<b>ensures</b> a &gt;= b ==&gt; result == b;
</code></pre>



<a id="@Specification_1_average"></a>

### Function `average`


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_average">average</a>(a: u64, b: u64): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == (a + b) / 2;
</code></pre>



<a id="@Specification_1_clamp"></a>

### Function `clamp`


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_clamp">clamp</a>(x: u64, lower: u64, upper: u64): u64
</code></pre>




<pre><code><b>requires</b> (lower &lt;= upper);
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> (lower &lt;=x && x &lt;= upper) ==&gt; result == x;
<b>ensures</b> (x &lt; lower) ==&gt; result == lower;
<b>ensures</b> (upper &lt; x) ==&gt; result == upper;
</code></pre>



<a id="@Specification_1_pow"></a>

### Function `pow`


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_pow">pow</a>(n: u64, e: u64): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <a href="math64.md#0x1_math64_spec_pow">spec_pow</a>(n, e) &gt; MAX_U64;
<b>ensures</b> [abstract] result == <a href="math64.md#0x1_math64_spec_pow">spec_pow</a>(n, e);
</code></pre>



<a id="@Specification_1_floor_log2"></a>

### Function `floor_log2`


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_floor_log2">floor_log2</a>(x: u64): u8
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] x == 0;
<b>ensures</b> [abstract] <a href="math64.md#0x1_math64_spec_pow">spec_pow</a>(2, result) &lt;= x;
<b>ensures</b> [abstract] x &lt; <a href="math64.md#0x1_math64_spec_pow">spec_pow</a>(2, result+1);
</code></pre>



<a id="@Specification_1_sqrt"></a>

### Function `sqrt`


<pre><code><b>public</b> <b>fun</b> <a href="math64.md#0x1_math64_sqrt">sqrt</a>(x: u64): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] x &gt; 0 ==&gt; result * result &lt;= x;
<b>ensures</b> [abstract] x &gt; 0 ==&gt; x &lt; (result+1) * (result+1);
</code></pre>




<a id="0x1_math64_spec_pow"></a>


<pre><code><b>fun</b> <a href="math64.md#0x1_math64_spec_pow">spec_pow</a>(n: u64, e: u64): u64 {
   <b>if</b> (e == 0) {
       1
   }
   <b>else</b> {
       n * <a href="math64.md#0x1_math64_spec_pow">spec_pow</a>(n, e-1)
   }
}
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/math_fixed.md
================================================

<a id="0x1_math_fixed"></a>

# Module `0x1::math_fixed`

Standard math utilities missing in the Move Language.


-  [Constants](#@Constants_0)
-  [Function `sqrt`](#0x1_math_fixed_sqrt)
-  [Function `exp`](#0x1_math_fixed_exp)
-  [Function `log2_plus_32`](#0x1_math_fixed_log2_plus_32)
-  [Function `ln_plus_32ln2`](#0x1_math_fixed_ln_plus_32ln2)
-  [Function `pow`](#0x1_math_fixed_pow)
-  [Function `mul_div`](#0x1_math_fixed_mul_div)
-  [Function `exp_raw`](#0x1_math_fixed_exp_raw)
-  [Function `pow_raw`](#0x1_math_fixed_pow_raw)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32">0x1::fixed_point32</a>;
<b>use</b> <a href="math128.md#0x1_math128">0x1::math128</a>;
</code></pre>



<a id="@Constants_0"></a>

## Constants


<a id="0x1_math_fixed_EOVERFLOW_EXP"></a>

Abort code on overflow


<pre><code><b>const</b> <a href="math_fixed.md#0x1_math_fixed_EOVERFLOW_EXP">EOVERFLOW_EXP</a>: u64 = 1;
</code></pre>



<a id="0x1_math_fixed_LN2"></a>

Natural log 2 in 32 bit fixed point


<pre><code><b>const</b> <a href="math_fixed.md#0x1_math_fixed_LN2">LN2</a>: u128 = 2977044472;
</code></pre>



<a id="0x1_math_fixed_LN2_X_32"></a>



<pre><code><b>const</b> <a href="math_fixed.md#0x1_math_fixed_LN2_X_32">LN2_X_32</a>: u64 = 95265423104;
</code></pre>



<a id="0x1_math_fixed_sqrt"></a>

## Function `sqrt`

Square root of fixed point number


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_sqrt">sqrt</a>(x: <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_sqrt">sqrt</a>(x: FixedPoint32): FixedPoint32 {
    <b>let</b> y = (<a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(x) <b>as</b> u128);
    <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_create_from_raw_value">fixed_point32::create_from_raw_value</a>((<a href="math128.md#0x1_math128_sqrt">math128::sqrt</a>(y &lt;&lt; 32) <b>as</b> u64))
}
</code></pre>



</details>

<a id="0x1_math_fixed_exp"></a>

## Function `exp`

Exponent function with a precission of 9 digits.


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_exp">exp</a>(x: <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_exp">exp</a>(x: FixedPoint32): FixedPoint32 {
    <b>let</b> raw_value = (<a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(x) <b>as</b> u128);
    <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_create_from_raw_value">fixed_point32::create_from_raw_value</a>((<a href="math_fixed.md#0x1_math_fixed_exp_raw">exp_raw</a>(raw_value) <b>as</b> u64))
}
</code></pre>



</details>

<a id="0x1_math_fixed_log2_plus_32"></a>

## Function `log2_plus_32`

Because log2 is negative for values < 1 we instead return log2(x) + 32 which
is positive for all values of x.


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_log2_plus_32">log2_plus_32</a>(x: <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_log2_plus_32">log2_plus_32</a>(x: FixedPoint32): FixedPoint32 {
    <b>let</b> raw_value = (<a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(x) <b>as</b> u128);
    <a href="math128.md#0x1_math128_log2">math128::log2</a>(raw_value)
}
</code></pre>



</details>

<a id="0x1_math_fixed_ln_plus_32ln2"></a>

## Function `ln_plus_32ln2`



<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_ln_plus_32ln2">ln_plus_32ln2</a>(x: <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_ln_plus_32ln2">ln_plus_32ln2</a>(x: FixedPoint32): FixedPoint32 {
    <b>let</b> raw_value = (<a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(x) <b>as</b> u128);
    <b>let</b> x = (<a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(<a href="math128.md#0x1_math128_log2">math128::log2</a>(raw_value)) <b>as</b> u128);
    <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_create_from_raw_value">fixed_point32::create_from_raw_value</a>((x * <a href="math_fixed.md#0x1_math_fixed_LN2">LN2</a> &gt;&gt; 32 <b>as</b> u64))
}
</code></pre>



</details>

<a id="0x1_math_fixed_pow"></a>

## Function `pow`

Integer power of a fixed point number


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_pow">pow</a>(x: <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>, n: u64): <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_pow">pow</a>(x: FixedPoint32, n: u64): FixedPoint32 {
    <b>let</b> raw_value = (<a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(x) <b>as</b> u128);
    <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_create_from_raw_value">fixed_point32::create_from_raw_value</a>((<a href="math_fixed.md#0x1_math_fixed_pow_raw">pow_raw</a>(raw_value, (n <b>as</b> u128)) <b>as</b> u64))
}
</code></pre>



</details>

<a id="0x1_math_fixed_mul_div"></a>

## Function `mul_div`

Specialized function for x * y / z that omits intermediate shifting


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_mul_div">mul_div</a>(x: <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>, y: <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>, z: <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed.md#0x1_math_fixed_mul_div">mul_div</a>(x: FixedPoint32, y: FixedPoint32, z: FixedPoint32): FixedPoint32 {
    <b>let</b> a = <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(x);
    <b>let</b> b = <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(y);
    <b>let</b> c = <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_get_raw_value">fixed_point32::get_raw_value</a>(z);
    <a href="../../move-stdlib/doc/fixed_point32.md#0x1_fixed_point32_create_from_raw_value">fixed_point32::create_from_raw_value</a> (<a href="math64.md#0x1_math64_mul_div">math64::mul_div</a>(a, b, c))
}
</code></pre>



</details>

<a id="0x1_math_fixed_exp_raw"></a>

## Function `exp_raw`



<pre><code><b>fun</b> <a href="math_fixed.md#0x1_math_fixed_exp_raw">exp_raw</a>(x: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="math_fixed.md#0x1_math_fixed_exp_raw">exp_raw</a>(x: u128): u128 {
    // <a href="math_fixed.md#0x1_math_fixed_exp">exp</a>(x / 2^32) = 2^(x / (2^32 * ln(2))) = 2^(floor(x / (2^32 * ln(2))) + frac(x / (2^32 * ln(2))))
    <b>let</b> shift_long = x / <a href="math_fixed.md#0x1_math_fixed_LN2">LN2</a>;
    <b>assert</b>!(shift_long &lt;= 31, std::error::invalid_state(<a href="math_fixed.md#0x1_math_fixed_EOVERFLOW_EXP">EOVERFLOW_EXP</a>));
    <b>let</b> shift = (shift_long <b>as</b> u8);
    <b>let</b> remainder = x % <a href="math_fixed.md#0x1_math_fixed_LN2">LN2</a>;
    // At this point we want <b>to</b> calculate 2^(remainder / ln2) &lt;&lt; shift
    // ln2 = 595528 * 4999 which means
    <b>let</b> bigfactor = 595528;
    <b>let</b> exponent = remainder / bigfactor;
    <b>let</b> x = remainder % bigfactor;
    // 2^(remainder / ln2) = (2^(1/4999))^exponent * <a href="math_fixed.md#0x1_math_fixed_exp">exp</a>(x / 2^32)
    <b>let</b> roottwo = 4295562865;  // fixed point representation of 2^(1/4999)
    // This <b>has</b> an <a href="../../move-stdlib/doc/error.md#0x1_error">error</a> of 5000 / 4 10^9 roughly 6 digits of precission
    <b>let</b> power = <a href="math_fixed.md#0x1_math_fixed_pow_raw">pow_raw</a>(roottwo, exponent);
    <b>let</b> eps_correction = 1241009291;
    power = power + ((power * eps_correction * exponent) &gt;&gt; 64);
    // x is fixed point number smaller than 595528/2^32 &lt; 0.00014 so we need only 2 tayler steps
    // <b>to</b> get the 6 digits of precission
    <b>let</b> taylor1 = (power * x) &gt;&gt; (32 - shift);
    <b>let</b> taylor2 = (taylor1 * x) &gt;&gt; 32;
    <b>let</b> taylor3 = (taylor2 * x) &gt;&gt; 32;
    (power &lt;&lt; shift) + taylor1 + taylor2 / 2 + taylor3 / 6
}
</code></pre>



</details>

<a id="0x1_math_fixed_pow_raw"></a>

## Function `pow_raw`



<pre><code><b>fun</b> <a href="math_fixed.md#0x1_math_fixed_pow_raw">pow_raw</a>(x: u128, n: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="math_fixed.md#0x1_math_fixed_pow_raw">pow_raw</a>(x: u128, n: u128): u128 {
    <b>let</b> res: u256 = 1 &lt;&lt; 64;
    x = x &lt;&lt; 32;
    <b>while</b> (n != 0) {
        <b>if</b> (n & 1 != 0) {
            res = (res * (x <b>as</b> u256)) &gt;&gt; 64;
        };
        n = n &gt;&gt; 1;
        x = ((((x <b>as</b> u256) * (x <b>as</b> u256)) &gt;&gt; 64) <b>as</b> u128);
    };
    ((res &gt;&gt; 32) <b>as</b> u128)
}
</code></pre>



</details>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/math_fixed64.md
================================================

<a id="0x1_math_fixed64"></a>

# Module `0x1::math_fixed64`

Standard math utilities missing in the Move Language.


-  [Constants](#@Constants_0)
-  [Function `sqrt`](#0x1_math_fixed64_sqrt)
-  [Function `exp`](#0x1_math_fixed64_exp)
-  [Function `log2_plus_64`](#0x1_math_fixed64_log2_plus_64)
-  [Function `ln_plus_32ln2`](#0x1_math_fixed64_ln_plus_32ln2)
-  [Function `pow`](#0x1_math_fixed64_pow)
-  [Function `mul_div`](#0x1_math_fixed64_mul_div)
-  [Function `exp_raw`](#0x1_math_fixed64_exp_raw)
-  [Function `pow_raw`](#0x1_math_fixed64_pow_raw)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="fixed_point64.md#0x1_fixed_point64">0x1::fixed_point64</a>;
<b>use</b> <a href="math128.md#0x1_math128">0x1::math128</a>;
</code></pre>



<a id="@Constants_0"></a>

## Constants


<a id="0x1_math_fixed64_EOVERFLOW_EXP"></a>

Abort code on overflow


<pre><code><b>const</b> <a href="math_fixed64.md#0x1_math_fixed64_EOVERFLOW_EXP">EOVERFLOW_EXP</a>: u64 = 1;
</code></pre>



<a id="0x1_math_fixed64_LN2"></a>

Natural log 2 in 32 bit fixed point


<pre><code><b>const</b> <a href="math_fixed64.md#0x1_math_fixed64_LN2">LN2</a>: u256 = 12786308645202655660;
</code></pre>



<a id="0x1_math_fixed64_sqrt"></a>

## Function `sqrt`

Square root of fixed point number


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_sqrt">sqrt</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_sqrt">sqrt</a>(x: FixedPoint64): FixedPoint64 {
    <b>let</b> y = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(x);
    <b>let</b> z = (<a href="math128.md#0x1_math128_sqrt">math128::sqrt</a>(y) &lt;&lt; 32 <b>as</b> u256);
    z = (z + ((y <b>as</b> u256) &lt;&lt; 64) / z) &gt;&gt; 1;
    <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">fixed_point64::create_from_raw_value</a>((z <b>as</b> u128))
}
</code></pre>



</details>

<a id="0x1_math_fixed64_exp"></a>

## Function `exp`

Exponent function with a precission of 9 digits.


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_exp">exp</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_exp">exp</a>(x: FixedPoint64): FixedPoint64 {
    <b>let</b> raw_value = (<a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(x) <b>as</b> u256);
    <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">fixed_point64::create_from_raw_value</a>((<a href="math_fixed64.md#0x1_math_fixed64_exp_raw">exp_raw</a>(raw_value) <b>as</b> u128))
}
</code></pre>



</details>

<a id="0x1_math_fixed64_log2_plus_64"></a>

## Function `log2_plus_64`

Because log2 is negative for values < 1 we instead return log2(x) + 64 which
is positive for all values of x.


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_log2_plus_64">log2_plus_64</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_log2_plus_64">log2_plus_64</a>(x: FixedPoint64): FixedPoint64 {
    <b>let</b> raw_value = (<a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(x) <b>as</b> u128);
    <a href="math128.md#0x1_math128_log2_64">math128::log2_64</a>(raw_value)
}
</code></pre>



</details>

<a id="0x1_math_fixed64_ln_plus_32ln2"></a>

## Function `ln_plus_32ln2`



<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_ln_plus_32ln2">ln_plus_32ln2</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_ln_plus_32ln2">ln_plus_32ln2</a>(x: FixedPoint64): FixedPoint64 {
    <b>let</b> raw_value = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(x);
    <b>let</b> x = (<a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(<a href="math128.md#0x1_math128_log2_64">math128::log2_64</a>(raw_value)) <b>as</b> u256);
    <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">fixed_point64::create_from_raw_value</a>(((x * <a href="math_fixed64.md#0x1_math_fixed64_LN2">LN2</a>) &gt;&gt; 64 <b>as</b> u128))
}
</code></pre>



</details>

<a id="0x1_math_fixed64_pow"></a>

## Function `pow`

Integer power of a fixed point number


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_pow">pow</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, n: u64): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_pow">pow</a>(x: FixedPoint64, n: u64): FixedPoint64 {
    <b>let</b> raw_value = (<a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(x) <b>as</b> u256);
    <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">fixed_point64::create_from_raw_value</a>((<a href="math_fixed64.md#0x1_math_fixed64_pow_raw">pow_raw</a>(raw_value, (n <b>as</b> u128)) <b>as</b> u128))
}
</code></pre>



</details>

<a id="0x1_math_fixed64_mul_div"></a>

## Function `mul_div`

Specialized function for x * y / z that omits intermediate shifting


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_mul_div">mul_div</a>(x: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, y: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>, z: <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>): <a href="fixed_point64.md#0x1_fixed_point64_FixedPoint64">fixed_point64::FixedPoint64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_mul_div">mul_div</a>(x: FixedPoint64, y: FixedPoint64, z: FixedPoint64): FixedPoint64 {
    <b>let</b> a = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(x);
    <b>let</b> b = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(y);
    <b>let</b> c = <a href="fixed_point64.md#0x1_fixed_point64_get_raw_value">fixed_point64::get_raw_value</a>(z);
    <a href="fixed_point64.md#0x1_fixed_point64_create_from_raw_value">fixed_point64::create_from_raw_value</a> (<a href="math128.md#0x1_math128_mul_div">math128::mul_div</a>(a, b, c))
}
</code></pre>



</details>

<a id="0x1_math_fixed64_exp_raw"></a>

## Function `exp_raw`



<pre><code><b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_exp_raw">exp_raw</a>(x: u256): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_exp_raw">exp_raw</a>(x: u256): u256 {
    // <a href="math_fixed64.md#0x1_math_fixed64_exp">exp</a>(x / 2^64) = 2^(x / (2^64 * ln(2))) = 2^(floor(x / (2^64 * ln(2))) + frac(x / (2^64 * ln(2))))
    <b>let</b> shift_long = x / <a href="math_fixed64.md#0x1_math_fixed64_LN2">LN2</a>;
    <b>assert</b>!(shift_long &lt;= 63, std::error::invalid_state(<a href="math_fixed64.md#0x1_math_fixed64_EOVERFLOW_EXP">EOVERFLOW_EXP</a>));
    <b>let</b> shift = (shift_long <b>as</b> u8);
    <b>let</b> remainder = x % <a href="math_fixed64.md#0x1_math_fixed64_LN2">LN2</a>;
    // At this point we want <b>to</b> calculate 2^(remainder / ln2) &lt;&lt; shift
    // ln2 = 580 * 22045359733108027
    <b>let</b> bigfactor = 22045359733108027;
    <b>let</b> exponent = remainder / bigfactor;
    <b>let</b> x = remainder % bigfactor;
    // 2^(remainder / ln2) = (2^(1/580))^exponent * <a href="math_fixed64.md#0x1_math_fixed64_exp">exp</a>(x / 2^64)
    <b>let</b> roottwo = 18468802611690918839;  // fixed point representation of 2^(1/580)
    // 2^(1/580) = roottwo(1 - eps), so the number we seek is roottwo^exponent (1 - eps * exponent)
    <b>let</b> power = <a href="math_fixed64.md#0x1_math_fixed64_pow_raw">pow_raw</a>(roottwo, (exponent <b>as</b> u128));
    <b>let</b> eps_correction = 219071715585908898;
    power = power - ((power * eps_correction * exponent) &gt;&gt; 128);
    // x is fixed point number smaller than bigfactor/2^64 &lt; 0.0011 so we need only 5 tayler steps
    // <b>to</b> get the 15 digits of precission
    <b>let</b> taylor1 = (power * x) &gt;&gt; (64 - shift);
    <b>let</b> taylor2 = (taylor1 * x) &gt;&gt; 64;
    <b>let</b> taylor3 = (taylor2 * x) &gt;&gt; 64;
    <b>let</b> taylor4 = (taylor3 * x) &gt;&gt; 64;
    <b>let</b> taylor5 = (taylor4 * x) &gt;&gt; 64;
    <b>let</b> taylor6 = (taylor5 * x) &gt;&gt; 64;
    (power &lt;&lt; shift) + taylor1 + taylor2 / 2 + taylor3 / 6 + taylor4 / 24 + taylor5 / 120 + taylor6 / 720
}
</code></pre>



</details>

<a id="0x1_math_fixed64_pow_raw"></a>

## Function `pow_raw`



<pre><code><b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_pow_raw">pow_raw</a>(x: u256, n: u128): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="math_fixed64.md#0x1_math_fixed64_pow_raw">pow_raw</a>(x: u256, n: u128): u256 {
    <b>let</b> res: u256 = 1 &lt;&lt; 64;
    <b>while</b> (n != 0) {
        <b>if</b> (n & 1 != 0) {
            res = (res * x) &gt;&gt; 64;
        };
        n = n &gt;&gt; 1;
        x = (x * x) &gt;&gt; 64;
    };
    res
}
</code></pre>



</details>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/overview.md
================================================

<a id="@Supra_Standard_Library_0"></a>

# Supra Standard Library


This is the reference documentation of the Supra standard library.


<a id="@Index_1"></a>

## Index


-  [`0x1::any`](any.md#0x1_any)
-  [`0x1::aptos_hash`](hash.md#0x1_aptos_hash)
-  [`0x1::big_vector`](big_vector.md#0x1_big_vector)
-  [`0x1::bls12381`](bls12381.md#0x1_bls12381)
-  [`0x1::bls12381_algebra`](bls12381_algebra.md#0x1_bls12381_algebra)
-  [`0x1::bn254_algebra`](bn254_algebra.md#0x1_bn254_algebra)
-  [`0x1::capability`](capability.md#0x1_capability)
-  [`0x1::comparator`](comparator.md#0x1_comparator)
-  [`0x1::copyable_any`](copyable_any.md#0x1_copyable_any)
-  [`0x1::crypto_algebra`](crypto_algebra.md#0x1_crypto_algebra)
-  [`0x1::debug`](debug.md#0x1_debug)
-  [`0x1::ed25519`](ed25519.md#0x1_ed25519)
-  [`0x1::fixed_point64`](fixed_point64.md#0x1_fixed_point64)
-  [`0x1::from_bcs`](from_bcs.md#0x1_from_bcs)
-  [`0x1::math128`](math128.md#0x1_math128)
-  [`0x1::math64`](math64.md#0x1_math64)
-  [`0x1::math_fixed`](math_fixed.md#0x1_math_fixed)
-  [`0x1::math_fixed64`](math_fixed64.md#0x1_math_fixed64)
-  [`0x1::multi_ed25519`](multi_ed25519.md#0x1_multi_ed25519)
-  [`0x1::pool_u64`](pool_u64.md#0x1_pool_u64)
-  [`0x1::pool_u64_unbound`](pool_u64_unbound.md#0x1_pool_u64_unbound)
-  [`0x1::ristretto255`](ristretto255.md#0x1_ristretto255)
-  [`0x1::ristretto255_bulletproofs`](ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs)
-  [`0x1::ristretto255_elgamal`](ristretto255_elgamal.md#0x1_ristretto255_elgamal)
-  [`0x1::ristretto255_pedersen`](ristretto255_pedersen.md#0x1_ristretto255_pedersen)
-  [`0x1::secp256k1`](secp256k1.md#0x1_secp256k1)
-  [`0x1::simple_map`](simple_map.md#0x1_simple_map)
-  [`0x1::smart_table`](smart_table.md#0x1_smart_table)
-  [`0x1::smart_vector`](smart_vector.md#0x1_smart_vector)
-  [`0x1::string_utils`](string_utils.md#0x1_string_utils)
-  [`0x1::table`](table.md#0x1_table)
-  [`0x1::table_with_length`](table_with_length.md#0x1_table_with_length)
-  [`0x1::type_info`](type_info.md#0x1_type_info)


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/pool_u64.md
================================================

<a id="0x1_pool_u64"></a>

# Module `0x1::pool_u64`


Simple module for tracking and calculating shares of a pool of coins. The shares are worth more as the total coins in
the pool increases. New shareholder can buy more shares or redeem their existing shares.

Example flow:
1. Pool start outs empty.
2. Shareholder A buys in with 1000 coins. A will receive 1000 shares in the pool. Pool now has 1000 total coins and
1000 total shares.
3. Pool appreciates in value from rewards and now has 2000 coins. A's 1000 shares are now worth 2000 coins.
4. Shareholder B now buys in with 1000 coins. Since before the buy in, each existing share is worth 2 coins, B will
receive 500 shares in exchange for 1000 coins. Pool now has 1500 shares and 3000 coins.
5. Pool appreciates in value from rewards and now has 6000 coins.
6. A redeems 500 shares. Each share is worth 6000 / 1500 = 4. A receives 2000 coins. Pool has 4000 coins and 1000
shares left.


-  [Struct `Pool`](#0x1_pool_u64_Pool)
-  [Constants](#@Constants_0)
-  [Function `new`](#0x1_pool_u64_new)
-  [Function `create`](#0x1_pool_u64_create)
-  [Function `create_with_scaling_factor`](#0x1_pool_u64_create_with_scaling_factor)
-  [Function `destroy_empty`](#0x1_pool_u64_destroy_empty)
-  [Function `total_coins`](#0x1_pool_u64_total_coins)
-  [Function `total_shares`](#0x1_pool_u64_total_shares)
-  [Function `contains`](#0x1_pool_u64_contains)
-  [Function `shares`](#0x1_pool_u64_shares)
-  [Function `balance`](#0x1_pool_u64_balance)
-  [Function `shareholders`](#0x1_pool_u64_shareholders)
-  [Function `shareholders_count`](#0x1_pool_u64_shareholders_count)
-  [Function `update_total_coins`](#0x1_pool_u64_update_total_coins)
-  [Function `buy_in`](#0x1_pool_u64_buy_in)
-  [Function `add_shares`](#0x1_pool_u64_add_shares)
-  [Function `redeem_shares`](#0x1_pool_u64_redeem_shares)
-  [Function `transfer_shares`](#0x1_pool_u64_transfer_shares)
-  [Function `deduct_shares`](#0x1_pool_u64_deduct_shares)
-  [Function `amount_to_shares`](#0x1_pool_u64_amount_to_shares)
-  [Function `amount_to_shares_with_total_coins`](#0x1_pool_u64_amount_to_shares_with_total_coins)
-  [Function `shares_to_amount`](#0x1_pool_u64_shares_to_amount)
-  [Function `shares_to_amount_with_total_coins`](#0x1_pool_u64_shares_to_amount_with_total_coins)
-  [Function `multiply_then_divide`](#0x1_pool_u64_multiply_then_divide)
-  [Function `to_u128`](#0x1_pool_u64_to_u128)
-  [Specification](#@Specification_1)
    -  [Struct `Pool`](#@Specification_1_Pool)
    -  [Function `contains`](#@Specification_1_contains)
    -  [Function `shares`](#@Specification_1_shares)
    -  [Function `balance`](#@Specification_1_balance)
    -  [Function `buy_in`](#@Specification_1_buy_in)
    -  [Function `add_shares`](#@Specification_1_add_shares)
    -  [Function `redeem_shares`](#@Specification_1_redeem_shares)
    -  [Function `transfer_shares`](#@Specification_1_transfer_shares)
    -  [Function `deduct_shares`](#@Specification_1_deduct_shares)
    -  [Function `amount_to_shares_with_total_coins`](#@Specification_1_amount_to_shares_with_total_coins)
    -  [Function `shares_to_amount_with_total_coins`](#@Specification_1_shares_to_amount_with_total_coins)
    -  [Function `multiply_then_divide`](#@Specification_1_multiply_then_divide)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="simple_map.md#0x1_simple_map">0x1::simple_map</a>;
<b>use</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">0x1::vector</a>;
</code></pre>



<a id="0x1_pool_u64_Pool"></a>

## Struct `Pool`



<pre><code><b>struct</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a> <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>shareholders_limit: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>total_coins: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>total_shares: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>shares: <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;<b>address</b>, u64&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>shareholders: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;<b>address</b>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>scaling_factor: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_pool_u64_MAX_U64"></a>



<pre><code><b>const</b> <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>: u64 = 18446744073709551615;
</code></pre>



<a id="0x1_pool_u64_EINSUFFICIENT_SHARES"></a>

Cannot redeem more shares than the shareholder has in the pool.


<pre><code><b>const</b> <a href="pool_u64.md#0x1_pool_u64_EINSUFFICIENT_SHARES">EINSUFFICIENT_SHARES</a>: u64 = 4;
</code></pre>



<a id="0x1_pool_u64_EPOOL_IS_NOT_EMPTY"></a>

Cannot destroy non-empty pool.


<pre><code><b>const</b> <a href="pool_u64.md#0x1_pool_u64_EPOOL_IS_NOT_EMPTY">EPOOL_IS_NOT_EMPTY</a>: u64 = 3;
</code></pre>



<a id="0x1_pool_u64_EPOOL_TOTAL_COINS_OVERFLOW"></a>

Pool's total coins cannot exceed u64.max.


<pre><code><b>const</b> <a href="pool_u64.md#0x1_pool_u64_EPOOL_TOTAL_COINS_OVERFLOW">EPOOL_TOTAL_COINS_OVERFLOW</a>: u64 = 6;
</code></pre>



<a id="0x1_pool_u64_EPOOL_TOTAL_SHARES_OVERFLOW"></a>

Pool's total shares cannot exceed u64.max.


<pre><code><b>const</b> <a href="pool_u64.md#0x1_pool_u64_EPOOL_TOTAL_SHARES_OVERFLOW">EPOOL_TOTAL_SHARES_OVERFLOW</a>: u64 = 7;
</code></pre>



<a id="0x1_pool_u64_ESHAREHOLDER_NOT_FOUND"></a>

Shareholder not present in pool.


<pre><code><b>const</b> <a href="pool_u64.md#0x1_pool_u64_ESHAREHOLDER_NOT_FOUND">ESHAREHOLDER_NOT_FOUND</a>: u64 = 1;
</code></pre>



<a id="0x1_pool_u64_ESHAREHOLDER_SHARES_OVERFLOW"></a>

Shareholder cannot have more than u64.max shares.


<pre><code><b>const</b> <a href="pool_u64.md#0x1_pool_u64_ESHAREHOLDER_SHARES_OVERFLOW">ESHAREHOLDER_SHARES_OVERFLOW</a>: u64 = 5;
</code></pre>



<a id="0x1_pool_u64_ETOO_MANY_SHAREHOLDERS"></a>

There are too many shareholders in the pool.


<pre><code><b>const</b> <a href="pool_u64.md#0x1_pool_u64_ETOO_MANY_SHAREHOLDERS">ETOO_MANY_SHAREHOLDERS</a>: u64 = 2;
</code></pre>



<a id="0x1_pool_u64_new"></a>

## Function `new`

Create a new pool.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_new">new</a>(shareholders_limit: u64): <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_new">new</a>(shareholders_limit: u64): <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a> {
    // Default <b>to</b> a scaling factor of 1 (effectively no scaling).
    <a href="pool_u64.md#0x1_pool_u64_create_with_scaling_factor">create_with_scaling_factor</a>(shareholders_limit, 1)
}
</code></pre>



</details>

<a id="0x1_pool_u64_create"></a>

## Function `create`

Deprecated. Use <code>new</code> instead.
Create a new pool.


<pre><code>#[deprecated]
<b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_create">create</a>(shareholders_limit: u64): <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_create">create</a>(shareholders_limit: u64): <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a> {
    <a href="pool_u64.md#0x1_pool_u64_new">new</a>(shareholders_limit)
}
</code></pre>



</details>

<a id="0x1_pool_u64_create_with_scaling_factor"></a>

## Function `create_with_scaling_factor`

Create a new pool with custom <code>scaling_factor</code>.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_create_with_scaling_factor">create_with_scaling_factor</a>(shareholders_limit: u64, scaling_factor: u64): <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_create_with_scaling_factor">create_with_scaling_factor</a>(shareholders_limit: u64, scaling_factor: u64): <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a> {
    <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a> {
        shareholders_limit,
        total_coins: 0,
        total_shares: 0,
        shares: <a href="simple_map.md#0x1_simple_map_create">simple_map::create</a>&lt;<b>address</b>, u64&gt;(),
        shareholders: <a href="../../move-stdlib/doc/vector.md#0x1_vector_empty">vector::empty</a>&lt;<b>address</b>&gt;(),
        scaling_factor,
    }
}
</code></pre>



</details>

<a id="0x1_pool_u64_destroy_empty"></a>

## Function `destroy_empty`

Destroy an empty pool. This will fail if the pool has any balance of coins.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_destroy_empty">destroy_empty</a>(pool: <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_destroy_empty">destroy_empty</a>(pool: <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>) {
    <b>assert</b>!(pool.total_coins == 0, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_state">error::invalid_state</a>(<a href="pool_u64.md#0x1_pool_u64_EPOOL_IS_NOT_EMPTY">EPOOL_IS_NOT_EMPTY</a>));
    <b>let</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a> {
        shareholders_limit: _,
        total_coins: _,
        total_shares: _,
        shares: _,
        shareholders: _,
        scaling_factor: _,
    } = pool;
}
</code></pre>



</details>

<a id="0x1_pool_u64_total_coins"></a>

## Function `total_coins`

Return <code>pool</code>'s total balance of coins.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_total_coins">total_coins</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_total_coins">total_coins</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>): u64 {
    pool.total_coins
}
</code></pre>



</details>

<a id="0x1_pool_u64_total_shares"></a>

## Function `total_shares`

Return the total number of shares across all shareholders in <code>pool</code>.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_total_shares">total_shares</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_total_shares">total_shares</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>): u64 {
    pool.total_shares
}
</code></pre>



</details>

<a id="0x1_pool_u64_contains"></a>

## Function `contains`

Return true if <code>shareholder</code> is in <code>pool</code>.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_contains">contains</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_contains">contains</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>): bool {
    <a href="simple_map.md#0x1_simple_map_contains_key">simple_map::contains_key</a>(&pool.shares, &shareholder)
}
</code></pre>



</details>

<a id="0x1_pool_u64_shares"></a>

## Function `shares`

Return the number of shares of <code>stakeholder</code> in <code>pool</code>.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shares">shares</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shares">shares</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>): u64 {
    <b>if</b> (<a href="pool_u64.md#0x1_pool_u64_contains">contains</a>(pool, shareholder)) {
        *<a href="simple_map.md#0x1_simple_map_borrow">simple_map::borrow</a>(&pool.shares, &shareholder)
    } <b>else</b> {
        0
    }
}
</code></pre>



</details>

<a id="0x1_pool_u64_balance"></a>

## Function `balance`

Return the balance in coins of <code>shareholder</code> in <code>pool.</code>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_balance">balance</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_balance">balance</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>): u64 {
    <b>let</b> num_shares = <a href="pool_u64.md#0x1_pool_u64_shares">shares</a>(pool, shareholder);
    <a href="pool_u64.md#0x1_pool_u64_shares_to_amount">shares_to_amount</a>(pool, num_shares)
}
</code></pre>



</details>

<a id="0x1_pool_u64_shareholders"></a>

## Function `shareholders`

Return the list of shareholders in <code>pool</code>.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shareholders">shareholders</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;<b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shareholders">shareholders</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;<b>address</b>&gt; {
    pool.shareholders
}
</code></pre>



</details>

<a id="0x1_pool_u64_shareholders_count"></a>

## Function `shareholders_count`

Return the number of shareholders in <code>pool</code>.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shareholders_count">shareholders_count</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shareholders_count">shareholders_count</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>): u64 {
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&pool.shareholders)
}
</code></pre>



</details>

<a id="0x1_pool_u64_update_total_coins"></a>

## Function `update_total_coins`

Update <code>pool</code>'s total balance of coins.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_update_total_coins">update_total_coins</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, new_total_coins: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_update_total_coins">update_total_coins</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, new_total_coins: u64) {
    pool.total_coins = new_total_coins;
}
</code></pre>



</details>

<a id="0x1_pool_u64_buy_in"></a>

## Function `buy_in`

Allow an existing or new shareholder to add their coins to the pool in exchange for new shares.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_buy_in">buy_in</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>, coins_amount: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_buy_in">buy_in</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>, coins_amount: u64): u64 {
    <b>if</b> (coins_amount == 0) <b>return</b> 0;

    <b>let</b> new_shares = <a href="pool_u64.md#0x1_pool_u64_amount_to_shares">amount_to_shares</a>(pool, coins_amount);
    <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a> - pool.total_coins &gt;= coins_amount, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_EPOOL_TOTAL_COINS_OVERFLOW">EPOOL_TOTAL_COINS_OVERFLOW</a>));
    <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a> - pool.total_shares &gt;= new_shares, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_EPOOL_TOTAL_COINS_OVERFLOW">EPOOL_TOTAL_COINS_OVERFLOW</a>));

    pool.total_coins = pool.total_coins + coins_amount;
    pool.total_shares = pool.total_shares + new_shares;
    <a href="pool_u64.md#0x1_pool_u64_add_shares">add_shares</a>(pool, shareholder, new_shares);
    new_shares
}
</code></pre>



</details>

<a id="0x1_pool_u64_add_shares"></a>

## Function `add_shares`

Add the number of shares directly for <code>shareholder</code> in <code>pool</code>.
This would dilute other shareholders if the pool's balance of coins didn't change.


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_add_shares">add_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>, new_shares: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_add_shares">add_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>, new_shares: u64): u64 {
    <b>if</b> (<a href="pool_u64.md#0x1_pool_u64_contains">contains</a>(pool, shareholder)) {
        <b>let</b> existing_shares = <a href="simple_map.md#0x1_simple_map_borrow_mut">simple_map::borrow_mut</a>(&<b>mut</b> pool.shares, &shareholder);
        <b>let</b> current_shares = *existing_shares;
        <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a> - current_shares &gt;= new_shares, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_ESHAREHOLDER_SHARES_OVERFLOW">ESHAREHOLDER_SHARES_OVERFLOW</a>));

        *existing_shares = current_shares + new_shares;
        *existing_shares
    } <b>else</b> <b>if</b> (new_shares &gt; 0) {
        <b>assert</b>!(
            <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&pool.shareholders) &lt; pool.shareholders_limit,
            <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_state">error::invalid_state</a>(<a href="pool_u64.md#0x1_pool_u64_ETOO_MANY_SHAREHOLDERS">ETOO_MANY_SHAREHOLDERS</a>),
        );

        <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> pool.shareholders, shareholder);
        <a href="simple_map.md#0x1_simple_map_add">simple_map::add</a>(&<b>mut</b> pool.shares, shareholder, new_shares);
        new_shares
    } <b>else</b> {
        new_shares
    }
}
</code></pre>



</details>

<a id="0x1_pool_u64_redeem_shares"></a>

## Function `redeem_shares`

Allow <code>shareholder</code> to redeem their shares in <code>pool</code> for coins.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_redeem_shares">redeem_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>, shares_to_redeem: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_redeem_shares">redeem_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>, shares_to_redeem: u64): u64 {
    <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_contains">contains</a>(pool, shareholder), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_ESHAREHOLDER_NOT_FOUND">ESHAREHOLDER_NOT_FOUND</a>));
    <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_shares">shares</a>(pool, shareholder) &gt;= shares_to_redeem, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_EINSUFFICIENT_SHARES">EINSUFFICIENT_SHARES</a>));

    <b>if</b> (shares_to_redeem == 0) <b>return</b> 0;

    <b>let</b> redeemed_coins = <a href="pool_u64.md#0x1_pool_u64_shares_to_amount">shares_to_amount</a>(pool, shares_to_redeem);
    pool.total_coins = pool.total_coins - redeemed_coins;
    pool.total_shares = pool.total_shares - shares_to_redeem;
    <a href="pool_u64.md#0x1_pool_u64_deduct_shares">deduct_shares</a>(pool, shareholder, shares_to_redeem);

    redeemed_coins
}
</code></pre>



</details>

<a id="0x1_pool_u64_transfer_shares"></a>

## Function `transfer_shares`

Transfer shares from <code>shareholder_1</code> to <code>shareholder_2</code>.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_transfer_shares">transfer_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder_1: <b>address</b>, shareholder_2: <b>address</b>, shares_to_transfer: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_transfer_shares">transfer_shares</a>(
    pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>,
    shareholder_1: <b>address</b>,
    shareholder_2: <b>address</b>,
    shares_to_transfer: u64,
) {
    <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_contains">contains</a>(pool, shareholder_1), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_ESHAREHOLDER_NOT_FOUND">ESHAREHOLDER_NOT_FOUND</a>));
    <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_shares">shares</a>(pool, shareholder_1) &gt;= shares_to_transfer, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_EINSUFFICIENT_SHARES">EINSUFFICIENT_SHARES</a>));
    <b>if</b> (shares_to_transfer == 0) <b>return</b>;

    <a href="pool_u64.md#0x1_pool_u64_deduct_shares">deduct_shares</a>(pool, shareholder_1, shares_to_transfer);
    <a href="pool_u64.md#0x1_pool_u64_add_shares">add_shares</a>(pool, shareholder_2, shares_to_transfer);
}
</code></pre>



</details>

<a id="0x1_pool_u64_deduct_shares"></a>

## Function `deduct_shares`

Directly deduct <code>shareholder</code>'s number of shares in <code>pool</code> and return the number of remaining shares.


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_deduct_shares">deduct_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>, num_shares: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_deduct_shares">deduct_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>, num_shares: u64): u64 {
    <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_contains">contains</a>(pool, shareholder), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_ESHAREHOLDER_NOT_FOUND">ESHAREHOLDER_NOT_FOUND</a>));
    <b>assert</b>!(<a href="pool_u64.md#0x1_pool_u64_shares">shares</a>(pool, shareholder) &gt;= num_shares, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="pool_u64.md#0x1_pool_u64_EINSUFFICIENT_SHARES">EINSUFFICIENT_SHARES</a>));

    <b>let</b> existing_shares = <a href="simple_map.md#0x1_simple_map_borrow_mut">simple_map::borrow_mut</a>(&<b>mut</b> pool.shares, &shareholder);
    *existing_shares = *existing_shares - num_shares;

    // Remove the shareholder completely <b>if</b> they have no shares left.
    <b>let</b> remaining_shares = *existing_shares;
    <b>if</b> (remaining_shares == 0) {
        <b>let</b> (_, shareholder_index) = <a href="../../move-stdlib/doc/vector.md#0x1_vector_index_of">vector::index_of</a>(&pool.shareholders, &shareholder);
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_remove">vector::remove</a>(&<b>mut</b> pool.shareholders, shareholder_index);
        <a href="simple_map.md#0x1_simple_map_remove">simple_map::remove</a>(&<b>mut</b> pool.shares, &shareholder);
    };

    remaining_shares
}
</code></pre>



</details>

<a id="0x1_pool_u64_amount_to_shares"></a>

## Function `amount_to_shares`

Return the number of new shares <code>coins_amount</code> can buy in <code>pool</code>.
<code>amount</code> needs to big enough to avoid rounding number.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_amount_to_shares">amount_to_shares</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, coins_amount: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_amount_to_shares">amount_to_shares</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, coins_amount: u64): u64 {
    <a href="pool_u64.md#0x1_pool_u64_amount_to_shares_with_total_coins">amount_to_shares_with_total_coins</a>(pool, coins_amount, pool.total_coins)
}
</code></pre>



</details>

<a id="0x1_pool_u64_amount_to_shares_with_total_coins"></a>

## Function `amount_to_shares_with_total_coins`

Return the number of new shares <code>coins_amount</code> can buy in <code>pool</code> with a custom total coins number.
<code>amount</code> needs to big enough to avoid rounding number.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_amount_to_shares_with_total_coins">amount_to_shares_with_total_coins</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, coins_amount: u64, total_coins: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_amount_to_shares_with_total_coins">amount_to_shares_with_total_coins</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, coins_amount: u64, total_coins: u64): u64 {
    // No shares yet so amount is worth the same number of shares.
    <b>if</b> (pool.total_coins == 0 || pool.total_shares == 0) {
        // Multiply by scaling factor <b>to</b> minimize rounding errors during <b>internal</b> calculations for buy ins/redeems.
        // This can overflow but scaling factor is expected <b>to</b> be chosen carefully so this would not overflow.
        coins_amount * pool.scaling_factor
    } <b>else</b> {
        // Shares price = total_coins / total existing shares.
        // New number of shares = new_amount / shares_price = new_amount * existing_shares / total_amount.
        // We rearrange the calc and do multiplication first <b>to</b> avoid rounding errors.
        <a href="pool_u64.md#0x1_pool_u64_multiply_then_divide">multiply_then_divide</a>(pool, coins_amount, pool.total_shares, total_coins)
    }
}
</code></pre>



</details>

<a id="0x1_pool_u64_shares_to_amount"></a>

## Function `shares_to_amount`

Return the number of coins <code>shares</code> are worth in <code>pool</code>.
<code>shares</code> needs to big enough to avoid rounding number.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shares_to_amount">shares_to_amount</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shares: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shares_to_amount">shares_to_amount</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shares: u64): u64 {
    <a href="pool_u64.md#0x1_pool_u64_shares_to_amount_with_total_coins">shares_to_amount_with_total_coins</a>(pool, shares, pool.total_coins)
}
</code></pre>



</details>

<a id="0x1_pool_u64_shares_to_amount_with_total_coins"></a>

## Function `shares_to_amount_with_total_coins`

Return the number of coins <code>shares</code> are worth in <code>pool</code> with a custom total coins number.
<code>shares</code> needs to big enough to avoid rounding number.


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shares_to_amount_with_total_coins">shares_to_amount_with_total_coins</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shares: u64, total_coins: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shares_to_amount_with_total_coins">shares_to_amount_with_total_coins</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shares: u64, total_coins: u64): u64 {
    // No shares or coins yet so shares are worthless.
    <b>if</b> (pool.total_coins == 0 || pool.total_shares == 0) {
        0
    } <b>else</b> {
        // Shares price = total_coins / total existing shares.
        // Shares worth = shares * shares price = shares * total_coins / total existing shares.
        // We rearrange the calc and do multiplication first <b>to</b> avoid rounding errors.
        <a href="pool_u64.md#0x1_pool_u64_multiply_then_divide">multiply_then_divide</a>(pool, shares, total_coins, pool.total_shares)
    }
}
</code></pre>



</details>

<a id="0x1_pool_u64_multiply_then_divide"></a>

## Function `multiply_then_divide`



<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_multiply_then_divide">multiply_then_divide</a>(_pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, x: u64, y: u64, z: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_multiply_then_divide">multiply_then_divide</a>(_pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, x: u64, y: u64, z: u64): u64 {
    <b>let</b> result = (<a href="pool_u64.md#0x1_pool_u64_to_u128">to_u128</a>(x) * <a href="pool_u64.md#0x1_pool_u64_to_u128">to_u128</a>(y)) / <a href="pool_u64.md#0x1_pool_u64_to_u128">to_u128</a>(z);
    (result <b>as</b> u64)
}
</code></pre>



</details>

<a id="0x1_pool_u64_to_u128"></a>

## Function `to_u128`



<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_to_u128">to_u128</a>(num: u64): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_to_u128">to_u128</a>(num: u64): u128 {
    (num <b>as</b> u128)
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification



<pre><code><b>pragma</b> verify = <b>false</b>;
</code></pre>



<a id="@Specification_1_Pool"></a>

### Struct `Pool`


<pre><code><b>struct</b> <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a> <b>has</b> store
</code></pre>



<dl>
<dt>
<code>shareholders_limit: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>total_coins: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>total_shares: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>shares: <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;<b>address</b>, u64&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>shareholders: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;<b>address</b>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>scaling_factor: u64</code>
</dt>
<dd>

</dd>
</dl>



<pre><code><b>invariant</b> <b>forall</b> addr: <b>address</b>:
    (<a href="simple_map.md#0x1_simple_map_spec_contains_key">simple_map::spec_contains_key</a>(shares, addr) == <a href="../../move-stdlib/doc/vector.md#0x1_vector_spec_contains">vector::spec_contains</a>(shareholders, addr));
<b>invariant</b> <b>forall</b> i in 0..len(shareholders), j in 0..len(shareholders):
    shareholders[i] == shareholders[j] ==&gt; i == j;
</code></pre>




<a id="0x1_pool_u64_spec_contains"></a>


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_spec_contains">spec_contains</a>(pool: <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>): bool {
   <a href="simple_map.md#0x1_simple_map_spec_contains_key">simple_map::spec_contains_key</a>(pool.shares, shareholder)
}
</code></pre>



<a id="@Specification_1_contains"></a>

### Function `contains`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_contains">contains</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>): bool
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="pool_u64.md#0x1_pool_u64_spec_contains">spec_contains</a>(pool, shareholder);
</code></pre>




<a id="0x1_pool_u64_spec_shares"></a>


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_spec_shares">spec_shares</a>(pool: <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shareholder: <b>address</b>): u64 {
   <b>if</b> (<a href="simple_map.md#0x1_simple_map_spec_contains_key">simple_map::spec_contains_key</a>(pool.shares, shareholder)) {
       <a href="simple_map.md#0x1_simple_map_spec_get">simple_map::spec_get</a>(pool.shares, shareholder)
   }
   <b>else</b> {
       0
   }
}
</code></pre>



<a id="@Specification_1_shares"></a>

### Function `shares`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shares">shares</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>): u64
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="pool_u64.md#0x1_pool_u64_spec_shares">spec_shares</a>(pool, shareholder);
</code></pre>



<a id="@Specification_1_balance"></a>

### Function `balance`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_balance">balance</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>): u64
</code></pre>




<pre><code><b>let</b> shares = <a href="pool_u64.md#0x1_pool_u64_spec_shares">spec_shares</a>(pool, shareholder);
<b>let</b> total_coins = pool.total_coins;
<b>aborts_if</b> pool.total_coins &gt; 0 && pool.total_shares &gt; 0 && (shares * total_coins) / pool.total_shares &gt; <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>;
<b>ensures</b> result == <a href="pool_u64.md#0x1_pool_u64_spec_shares_to_amount_with_total_coins">spec_shares_to_amount_with_total_coins</a>(pool, shares, total_coins);
</code></pre>



<a id="@Specification_1_buy_in"></a>

### Function `buy_in`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_buy_in">buy_in</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>, coins_amount: u64): u64
</code></pre>




<pre><code><b>let</b> new_shares = <a href="pool_u64.md#0x1_pool_u64_spec_amount_to_shares_with_total_coins">spec_amount_to_shares_with_total_coins</a>(pool, coins_amount, pool.total_coins);
<b>aborts_if</b> pool.total_coins + coins_amount &gt; <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>;
<b>aborts_if</b> pool.total_shares + new_shares &gt; <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>;
<b>include</b> coins_amount &gt; 0 ==&gt; <a href="pool_u64.md#0x1_pool_u64_AddSharesAbortsIf">AddSharesAbortsIf</a> { new_shares: new_shares };
<b>include</b> coins_amount &gt; 0 ==&gt; <a href="pool_u64.md#0x1_pool_u64_AddSharesEnsures">AddSharesEnsures</a> { new_shares: new_shares };
<b>ensures</b> pool.total_coins == <b>old</b>(pool.total_coins) + coins_amount;
<b>ensures</b> pool.total_shares == <b>old</b>(pool.total_shares) + new_shares;
<b>ensures</b> result == new_shares;
</code></pre>



<a id="@Specification_1_add_shares"></a>

### Function `add_shares`


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_add_shares">add_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>, new_shares: u64): u64
</code></pre>




<pre><code><b>include</b> <a href="pool_u64.md#0x1_pool_u64_AddSharesAbortsIf">AddSharesAbortsIf</a>;
<b>include</b> <a href="pool_u64.md#0x1_pool_u64_AddSharesEnsures">AddSharesEnsures</a>;
<b>let</b> key_exists = <a href="simple_map.md#0x1_simple_map_spec_contains_key">simple_map::spec_contains_key</a>(pool.shares, shareholder);
<b>ensures</b> result == <b>if</b> (key_exists) { <a href="simple_map.md#0x1_simple_map_spec_get">simple_map::spec_get</a>(pool.shares, shareholder) }
<b>else</b> { new_shares };
</code></pre>




<a id="0x1_pool_u64_AddSharesAbortsIf"></a>


<pre><code><b>schema</b> <a href="pool_u64.md#0x1_pool_u64_AddSharesAbortsIf">AddSharesAbortsIf</a> {
    pool: <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>;
    shareholder: <b>address</b>;
    new_shares: u64;
    <b>let</b> key_exists = <a href="simple_map.md#0x1_simple_map_spec_contains_key">simple_map::spec_contains_key</a>(pool.shares, shareholder);
    <b>let</b> current_shares = <a href="simple_map.md#0x1_simple_map_spec_get">simple_map::spec_get</a>(pool.shares, shareholder);
    <b>aborts_if</b> key_exists && current_shares + new_shares &gt; <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>;
    <b>aborts_if</b> !key_exists && new_shares &gt; 0 && len(pool.shareholders) &gt;= pool.shareholders_limit;
}
</code></pre>




<a id="0x1_pool_u64_AddSharesEnsures"></a>


<pre><code><b>schema</b> <a href="pool_u64.md#0x1_pool_u64_AddSharesEnsures">AddSharesEnsures</a> {
    pool: <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>;
    shareholder: <b>address</b>;
    new_shares: u64;
    <b>let</b> key_exists = <a href="simple_map.md#0x1_simple_map_spec_contains_key">simple_map::spec_contains_key</a>(pool.shares, shareholder);
    <b>let</b> current_shares = <a href="simple_map.md#0x1_simple_map_spec_get">simple_map::spec_get</a>(pool.shares, shareholder);
    <b>ensures</b> key_exists ==&gt;
        pool.shares == <a href="simple_map.md#0x1_simple_map_spec_set">simple_map::spec_set</a>(<b>old</b>(pool.shares), shareholder, current_shares + new_shares);
    <b>ensures</b> (!key_exists && new_shares &gt; 0) ==&gt;
        pool.shares == <a href="simple_map.md#0x1_simple_map_spec_set">simple_map::spec_set</a>(<b>old</b>(pool.shares), shareholder, new_shares);
    <b>ensures</b> (!key_exists && new_shares &gt; 0) ==&gt;
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_eq_push_back">vector::eq_push_back</a>(pool.shareholders, <b>old</b>(pool.shareholders), shareholder);
}
</code></pre>




<a id="0x1_pool_u64_spec_amount_to_shares_with_total_coins"></a>


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_spec_amount_to_shares_with_total_coins">spec_amount_to_shares_with_total_coins</a>(pool: <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, coins_amount: u64, total_coins: u64): u64 {
   <b>if</b> (pool.total_coins == 0 || pool.total_shares == 0) {
       coins_amount * pool.scaling_factor
   }
   <b>else</b> {
       (coins_amount * pool.total_shares) / total_coins
   }
}
</code></pre>



<a id="@Specification_1_redeem_shares"></a>

### Function `redeem_shares`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_redeem_shares">redeem_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>, shares_to_redeem: u64): u64
</code></pre>




<pre><code><b>let</b> redeemed_coins = <a href="pool_u64.md#0x1_pool_u64_spec_shares_to_amount_with_total_coins">spec_shares_to_amount_with_total_coins</a>(pool, shares_to_redeem, pool.total_coins);
<b>aborts_if</b> !<a href="pool_u64.md#0x1_pool_u64_spec_contains">spec_contains</a>(pool, shareholder);
<b>aborts_if</b> <a href="pool_u64.md#0x1_pool_u64_spec_shares">spec_shares</a>(pool, shareholder) &lt; shares_to_redeem;
<b>aborts_if</b> pool.<a href="pool_u64.md#0x1_pool_u64_total_coins">total_coins</a> &lt; redeemed_coins;
<b>aborts_if</b> pool.<a href="pool_u64.md#0x1_pool_u64_total_shares">total_shares</a> &lt; shares_to_redeem;
<b>ensures</b> pool.total_coins == <b>old</b>(pool.total_coins) - redeemed_coins;
<b>ensures</b> pool.total_shares == <b>old</b>(pool.total_shares) - shares_to_redeem;
<b>include</b> shares_to_redeem &gt; 0 ==&gt; <a href="pool_u64.md#0x1_pool_u64_DeductSharesEnsures">DeductSharesEnsures</a> { num_shares: shares_to_redeem };
<b>ensures</b> result == redeemed_coins;
</code></pre>



<a id="@Specification_1_transfer_shares"></a>

### Function `transfer_shares`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_transfer_shares">transfer_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder_1: <b>address</b>, shareholder_2: <b>address</b>, shares_to_transfer: u64)
</code></pre>




<pre><code><b>pragma</b> aborts_if_is_partial;
<b>aborts_if</b> !<a href="pool_u64.md#0x1_pool_u64_spec_contains">spec_contains</a>(pool, shareholder_1);
<b>aborts_if</b> <a href="pool_u64.md#0x1_pool_u64_spec_shares">spec_shares</a>(pool, shareholder_1) &lt; shares_to_transfer;
</code></pre>



<a id="@Specification_1_deduct_shares"></a>

### Function `deduct_shares`


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_deduct_shares">deduct_shares</a>(pool: &<b>mut</b> <a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shareholder: <b>address</b>, num_shares: u64): u64
</code></pre>




<pre><code><b>aborts_if</b> !<a href="pool_u64.md#0x1_pool_u64_spec_contains">spec_contains</a>(pool, shareholder);
<b>aborts_if</b> <a href="pool_u64.md#0x1_pool_u64_spec_shares">spec_shares</a>(pool, shareholder) &lt; num_shares;
<b>include</b> <a href="pool_u64.md#0x1_pool_u64_DeductSharesEnsures">DeductSharesEnsures</a>;
<b>let</b> remaining_shares = <a href="simple_map.md#0x1_simple_map_spec_get">simple_map::spec_get</a>(pool.shares, shareholder) - num_shares;
<b>ensures</b> remaining_shares &gt; 0 ==&gt; result == <a href="simple_map.md#0x1_simple_map_spec_get">simple_map::spec_get</a>(pool.shares, shareholder);
<b>ensures</b> remaining_shares == 0 ==&gt; result == 0;
</code></pre>




<a id="0x1_pool_u64_DeductSharesEnsures"></a>


<pre><code><b>schema</b> <a href="pool_u64.md#0x1_pool_u64_DeductSharesEnsures">DeductSharesEnsures</a> {
    pool: <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>;
    shareholder: <b>address</b>;
    num_shares: u64;
    <b>let</b> remaining_shares = <a href="simple_map.md#0x1_simple_map_spec_get">simple_map::spec_get</a>(pool.shares, shareholder) - num_shares;
    <b>ensures</b> remaining_shares &gt; 0 ==&gt; <a href="simple_map.md#0x1_simple_map_spec_get">simple_map::spec_get</a>(pool.shares, shareholder) == remaining_shares;
    <b>ensures</b> remaining_shares == 0 ==&gt; !<a href="simple_map.md#0x1_simple_map_spec_contains_key">simple_map::spec_contains_key</a>(pool.shares, shareholder);
    <b>ensures</b> remaining_shares == 0 ==&gt; !<a href="../../move-stdlib/doc/vector.md#0x1_vector_spec_contains">vector::spec_contains</a>(pool.shareholders, shareholder);
}
</code></pre>



<a id="@Specification_1_amount_to_shares_with_total_coins"></a>

### Function `amount_to_shares_with_total_coins`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_amount_to_shares_with_total_coins">amount_to_shares_with_total_coins</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, coins_amount: u64, total_coins: u64): u64
</code></pre>




<pre><code><b>aborts_if</b> pool.total_coins &gt; 0 && pool.total_shares &gt; 0
    && (coins_amount * pool.total_shares) / total_coins &gt; <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>;
<b>aborts_if</b> (pool.total_coins == 0 || pool.total_shares == 0)
    && coins_amount * pool.scaling_factor &gt; <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>;
<b>aborts_if</b> pool.total_coins &gt; 0 && pool.total_shares &gt; 0 && total_coins == 0;
<b>ensures</b> result == <a href="pool_u64.md#0x1_pool_u64_spec_amount_to_shares_with_total_coins">spec_amount_to_shares_with_total_coins</a>(pool, coins_amount, total_coins);
</code></pre>



<a id="@Specification_1_shares_to_amount_with_total_coins"></a>

### Function `shares_to_amount_with_total_coins`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_shares_to_amount_with_total_coins">shares_to_amount_with_total_coins</a>(pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, shares: u64, total_coins: u64): u64
</code></pre>




<pre><code><b>aborts_if</b> pool.total_coins &gt; 0 && pool.total_shares &gt; 0
    && (shares * total_coins) / pool.total_shares &gt; <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>;
<b>ensures</b> result == <a href="pool_u64.md#0x1_pool_u64_spec_shares_to_amount_with_total_coins">spec_shares_to_amount_with_total_coins</a>(pool, shares, total_coins);
</code></pre>




<a id="0x1_pool_u64_spec_shares_to_amount_with_total_coins"></a>


<pre><code><b>fun</b> <a href="pool_u64.md#0x1_pool_u64_spec_shares_to_amount_with_total_coins">spec_shares_to_amount_with_total_coins</a>(pool: <a href="pool_u64.md#0x1_pool_u64_Pool">Pool</a>, shares: u64, total_coins: u64): u64 {
   <b>if</b> (pool.total_coins == 0 || pool.total_shares == 0) {
       0
   }
   <b>else</b> {
       (shares * total_coins) / pool.total_shares
   }
}
</code></pre>



<a id="@Specification_1_multiply_then_divide"></a>

### Function `multiply_then_divide`


<pre><code><b>public</b> <b>fun</b> <a href="pool_u64.md#0x1_pool_u64_multiply_then_divide">multiply_then_divide</a>(_pool: &<a href="pool_u64.md#0x1_pool_u64_Pool">pool_u64::Pool</a>, x: u64, y: u64, z: u64): u64
</code></pre>




<pre><code><b>aborts_if</b> z == 0;
<b>aborts_if</b> (x * y) / z &gt; <a href="pool_u64.md#0x1_pool_u64_MAX_U64">MAX_U64</a>;
<b>ensures</b> result == (x * y) / z;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/ristretto255_bulletproofs.md
================================================

<a id="0x1_ristretto255_bulletproofs"></a>

# Module `0x1::ristretto255_bulletproofs`

This module implements a Bulletproof range proof verifier on the Ristretto255 curve.

A Bulletproof-based zero-knowledge range proof is a proof that a Pedersen commitment
$c = v G + r H$ commits to an $n$-bit value $v$ (i.e., $v \in [0, 2^n)$). Currently, this module only supports
$n \in \{8, 16, 32, 64\}$ for the number of bits.


-  [Struct `RangeProof`](#0x1_ristretto255_bulletproofs_RangeProof)
-  [Constants](#@Constants_0)
-  [Function `get_max_range_bits`](#0x1_ristretto255_bulletproofs_get_max_range_bits)
-  [Function `range_proof_from_bytes`](#0x1_ristretto255_bulletproofs_range_proof_from_bytes)
-  [Function `range_proof_to_bytes`](#0x1_ristretto255_bulletproofs_range_proof_to_bytes)
-  [Function `verify_range_proof_pedersen`](#0x1_ristretto255_bulletproofs_verify_range_proof_pedersen)
-  [Function `verify_range_proof`](#0x1_ristretto255_bulletproofs_verify_range_proof)
-  [Function `verify_range_proof_internal`](#0x1_ristretto255_bulletproofs_verify_range_proof_internal)
-  [Specification](#@Specification_1)
    -  [Function `verify_range_proof_internal`](#@Specification_1_verify_range_proof_internal)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/features.md#0x1_features">0x1::features</a>;
<b>use</b> <a href="ristretto255.md#0x1_ristretto255">0x1::ristretto255</a>;
<b>use</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen">0x1::ristretto255_pedersen</a>;
</code></pre>



<a id="0x1_ristretto255_bulletproofs_RangeProof"></a>

## Struct `RangeProof`

Represents a zero-knowledge range proof that a value committed inside a Pedersen commitment lies in
<code>[0, 2^{<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_MAX_RANGE_BITS">MAX_RANGE_BITS</a>})</code>.


<pre><code><b>struct</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">RangeProof</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_ristretto255_bulletproofs_E_NATIVE_FUN_NOT_AVAILABLE"></a>

The native functions have not been rolled out yet.


<pre><code><b>const</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>: u64 = 4;
</code></pre>



<a id="0x1_ristretto255_bulletproofs_E_DESERIALIZE_RANGE_PROOF"></a>

There was an error deserializing the range proof.


<pre><code><b>const</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_E_DESERIALIZE_RANGE_PROOF">E_DESERIALIZE_RANGE_PROOF</a>: u64 = 1;
</code></pre>



<a id="0x1_ristretto255_bulletproofs_E_RANGE_NOT_SUPPORTED"></a>

The range proof system only supports proving ranges of type $[0, 2^b)$ where $b \in \{8, 16, 32, 64\}$.


<pre><code><b>const</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_E_RANGE_NOT_SUPPORTED">E_RANGE_NOT_SUPPORTED</a>: u64 = 3;
</code></pre>



<a id="0x1_ristretto255_bulletproofs_E_VALUE_OUTSIDE_RANGE"></a>

The committed value given to the prover is too large.


<pre><code><b>const</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_E_VALUE_OUTSIDE_RANGE">E_VALUE_OUTSIDE_RANGE</a>: u64 = 2;
</code></pre>



<a id="0x1_ristretto255_bulletproofs_MAX_RANGE_BITS"></a>

The maximum range supported by the Bulletproofs library is $[0, 2^{64})$.


<pre><code><b>const</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_MAX_RANGE_BITS">MAX_RANGE_BITS</a>: u64 = 64;
</code></pre>



<a id="0x1_ristretto255_bulletproofs_get_max_range_bits"></a>

## Function `get_max_range_bits`

Returns the maximum # of bits that the range proof system can verify proofs for.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_get_max_range_bits">get_max_range_bits</a>(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_get_max_range_bits">get_max_range_bits</a>(): u64 {
    <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_MAX_RANGE_BITS">MAX_RANGE_BITS</a>
}
</code></pre>



</details>

<a id="0x1_ristretto255_bulletproofs_range_proof_from_bytes"></a>

## Function `range_proof_from_bytes`

Deserializes a range proof from a sequence of bytes. The serialization format is the same as the format in
the zkcrypto's <code>bulletproofs</code> library (https://docs.rs/bulletproofs/4.0.0/bulletproofs/struct.RangeProof.html#method.from_bytes).


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_range_proof_from_bytes">range_proof_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">ristretto255_bulletproofs::RangeProof</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_range_proof_from_bytes">range_proof_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">RangeProof</a> {
    <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">RangeProof</a> {
        bytes
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_bulletproofs_range_proof_to_bytes"></a>

## Function `range_proof_to_bytes`

Returns the byte-representation of a range proof.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_range_proof_to_bytes">range_proof_to_bytes</a>(proof: &<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">ristretto255_bulletproofs::RangeProof</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_range_proof_to_bytes">range_proof_to_bytes</a>(proof: &<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">RangeProof</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    proof.bytes
}
</code></pre>



</details>

<a id="0x1_ristretto255_bulletproofs_verify_range_proof_pedersen"></a>

## Function `verify_range_proof_pedersen`

Verifies a zero-knowledge range proof that the value <code>v</code> committed in <code>com</code> (under the default Bulletproofs
commitment key; see <code>pedersen::new_commitment_for_bulletproof</code>) satisfies $v \in [0, 2^b)$. Only works
for $b \in \{8, 16, 32, 64\}$. Additionally, checks that the prover used <code>dst</code> as the domain-separation
tag (DST).

WARNING: The DST check is VERY important for security as it prevents proofs computed for one application
(a.k.a., a _domain_) with <code>dst_1</code> from verifying in a different application with <code>dst_2 != dst_1</code>.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof_pedersen">verify_range_proof_pedersen</a>(com: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>, proof: &<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">ristretto255_bulletproofs::RangeProof</a>, num_bits: u64, dst: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof_pedersen">verify_range_proof_pedersen</a>(com: &pedersen::Commitment, proof: &<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">RangeProof</a>, num_bits: u64, dst: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool {
    <b>assert</b>!(<a href="../../move-stdlib/doc/features.md#0x1_features_bulletproofs_enabled">features::bulletproofs_enabled</a>(), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_state">error::invalid_state</a>(<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>));

    <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof_internal">verify_range_proof_internal</a>(
        <a href="ristretto255.md#0x1_ristretto255_point_to_bytes">ristretto255::point_to_bytes</a>(&pedersen::commitment_as_compressed_point(com)),
        &<a href="ristretto255.md#0x1_ristretto255_basepoint">ristretto255::basepoint</a>(), &<a href="ristretto255.md#0x1_ristretto255_hash_to_point_base">ristretto255::hash_to_point_base</a>(),
        proof.bytes,
        num_bits,
        dst
    )
}
</code></pre>



</details>

<a id="0x1_ristretto255_bulletproofs_verify_range_proof"></a>

## Function `verify_range_proof`

Verifies a zero-knowledge range proof that the value <code>v</code> committed in <code>com</code> (as v * val_base + r * rand_base,
for some randomness <code>r</code>) satisfies <code>v</code> in <code>[0, 2^num_bits)</code>. Only works for <code>num_bits</code> in <code>{8, 16, 32, 64}</code>.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof">verify_range_proof</a>(com: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, val_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, rand_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, proof: &<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">ristretto255_bulletproofs::RangeProof</a>, num_bits: u64, dst: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof">verify_range_proof</a>(
    com: &RistrettoPoint,
    val_base: &RistrettoPoint, rand_base: &RistrettoPoint,
    proof: &<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_RangeProof">RangeProof</a>, num_bits: u64, dst: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
{
    <b>assert</b>!(<a href="../../move-stdlib/doc/features.md#0x1_features_bulletproofs_enabled">features::bulletproofs_enabled</a>(), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_state">error::invalid_state</a>(<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>));

    <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof_internal">verify_range_proof_internal</a>(
        <a href="ristretto255.md#0x1_ristretto255_point_to_bytes">ristretto255::point_to_bytes</a>(&<a href="ristretto255.md#0x1_ristretto255_point_compress">ristretto255::point_compress</a>(com)),
        val_base, rand_base,
        proof.bytes, num_bits, dst
    )
}
</code></pre>



</details>

<a id="0x1_ristretto255_bulletproofs_verify_range_proof_internal"></a>

## Function `verify_range_proof_internal`

Aborts with <code><a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_E_DESERIALIZE_RANGE_PROOF">E_DESERIALIZE_RANGE_PROOF</a>)</code> if <code>proof</code> is not a valid serialization of a
range proof.
Aborts with <code><a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_E_RANGE_NOT_SUPPORTED">E_RANGE_NOT_SUPPORTED</a>)</code> if an unsupported <code>num_bits</code> is provided.


<pre><code><b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof_internal">verify_range_proof_internal</a>(com: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, val_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, rand_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, proof: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, num_bits: u64, dst: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof_internal">verify_range_proof_internal</a>(
    com: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;,
    val_base: &RistrettoPoint,
    rand_base: &RistrettoPoint,
    proof: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;,
    num_bits: u64,
    dst: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_verify_range_proof_internal"></a>

### Function `verify_range_proof_internal`


<pre><code><b>fun</b> <a href="ristretto255_bulletproofs.md#0x1_ristretto255_bulletproofs_verify_range_proof_internal">verify_range_proof_internal</a>(com: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, val_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, rand_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, proof: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, num_bits: u64, dst: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/ristretto255_elgamal.md
================================================

<a id="0x1_ristretto255_elgamal"></a>

# Module `0x1::ristretto255_elgamal`

This module implements an ElGamal encryption API, over the Ristretto255 curve, that can be used with the
Bulletproofs module.

An ElGamal *ciphertext* is an encryption of a value <code>v</code> under a basepoint <code>G</code> and public key <code>Y = sk * G</code>, where <code>sk</code>
is the corresponding secret key, is <code>(v * G + r * Y, r * G)</code>, for a random scalar <code>r</code>.

Note that we place the value <code>v</code> "in the exponent" of <code>G</code> so that ciphertexts are additively homomorphic: i.e., so
that <code>Enc_Y(v, r) + Enc_Y(v', r') = Enc_Y(v + v', r + r')</code> where <code>v, v'</code> are plaintext messages, <code>Y</code> is a public key and <code>r, r'</code>
are the randomness of the ciphertexts.


-  [Struct `Ciphertext`](#0x1_ristretto255_elgamal_Ciphertext)
-  [Struct `CompressedCiphertext`](#0x1_ristretto255_elgamal_CompressedCiphertext)
-  [Struct `CompressedPubkey`](#0x1_ristretto255_elgamal_CompressedPubkey)
-  [Function `new_pubkey_from_bytes`](#0x1_ristretto255_elgamal_new_pubkey_from_bytes)
-  [Function `pubkey_to_bytes`](#0x1_ristretto255_elgamal_pubkey_to_bytes)
-  [Function `pubkey_to_point`](#0x1_ristretto255_elgamal_pubkey_to_point)
-  [Function `pubkey_to_compressed_point`](#0x1_ristretto255_elgamal_pubkey_to_compressed_point)
-  [Function `new_ciphertext_from_bytes`](#0x1_ristretto255_elgamal_new_ciphertext_from_bytes)
-  [Function `new_ciphertext_no_randomness`](#0x1_ristretto255_elgamal_new_ciphertext_no_randomness)
-  [Function `ciphertext_from_points`](#0x1_ristretto255_elgamal_ciphertext_from_points)
-  [Function `ciphertext_from_compressed_points`](#0x1_ristretto255_elgamal_ciphertext_from_compressed_points)
-  [Function `ciphertext_to_bytes`](#0x1_ristretto255_elgamal_ciphertext_to_bytes)
-  [Function `ciphertext_into_points`](#0x1_ristretto255_elgamal_ciphertext_into_points)
-  [Function `ciphertext_as_points`](#0x1_ristretto255_elgamal_ciphertext_as_points)
-  [Function `compress_ciphertext`](#0x1_ristretto255_elgamal_compress_ciphertext)
-  [Function `decompress_ciphertext`](#0x1_ristretto255_elgamal_decompress_ciphertext)
-  [Function `ciphertext_add`](#0x1_ristretto255_elgamal_ciphertext_add)
-  [Function `ciphertext_add_assign`](#0x1_ristretto255_elgamal_ciphertext_add_assign)
-  [Function `ciphertext_sub`](#0x1_ristretto255_elgamal_ciphertext_sub)
-  [Function `ciphertext_sub_assign`](#0x1_ristretto255_elgamal_ciphertext_sub_assign)
-  [Function `ciphertext_clone`](#0x1_ristretto255_elgamal_ciphertext_clone)
-  [Function `ciphertext_equals`](#0x1_ristretto255_elgamal_ciphertext_equals)
-  [Function `get_value_component`](#0x1_ristretto255_elgamal_get_value_component)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/option.md#0x1_option">0x1::option</a>;
<b>use</b> <a href="ristretto255.md#0x1_ristretto255">0x1::ristretto255</a>;
<b>use</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">0x1::vector</a>;
</code></pre>



<a id="0x1_ristretto255_elgamal_Ciphertext"></a>

## Struct `Ciphertext`

An ElGamal ciphertext.


<pre><code><b>struct</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>left: <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a></code>
</dt>
<dd>

</dd>
<dt>
<code>right: <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a></code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ristretto255_elgamal_CompressedCiphertext"></a>

## Struct `CompressedCiphertext`

A compressed ElGamal ciphertext.


<pre><code><b>struct</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">CompressedCiphertext</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>left: <a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a></code>
</dt>
<dd>

</dd>
<dt>
<code>right: <a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a></code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ristretto255_elgamal_CompressedPubkey"></a>

## Struct `CompressedPubkey`

An ElGamal public key.


<pre><code><b>struct</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">CompressedPubkey</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>point: <a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a></code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_ristretto255_elgamal_new_pubkey_from_bytes"></a>

## Function `new_pubkey_from_bytes`

Creates a new public key from a serialized Ristretto255 point.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_new_pubkey_from_bytes">new_pubkey_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">ristretto255_elgamal::CompressedPubkey</a>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_new_pubkey_from_bytes">new_pubkey_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): Option&lt;<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">CompressedPubkey</a>&gt; {
    <b>let</b> point = <a href="ristretto255.md#0x1_ristretto255_new_compressed_point_from_bytes">ristretto255::new_compressed_point_from_bytes</a>(bytes);
    <b>if</b> (std::option::is_some(&<b>mut</b> point)) {
        <b>let</b> pk = <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">CompressedPubkey</a> {
            point: std::option::extract(&<b>mut</b> point)
        };
        std::option::some(pk)
    } <b>else</b> {
        std::option::none&lt;<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">CompressedPubkey</a>&gt;()
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_pubkey_to_bytes"></a>

## Function `pubkey_to_bytes`

Given an ElGamal public key <code>pubkey</code>, returns the byte representation of that public key.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_pubkey_to_bytes">pubkey_to_bytes</a>(pubkey: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">ristretto255_elgamal::CompressedPubkey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_pubkey_to_bytes">pubkey_to_bytes</a>(pubkey: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">CompressedPubkey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <a href="ristretto255.md#0x1_ristretto255_compressed_point_to_bytes">ristretto255::compressed_point_to_bytes</a>(pubkey.point)
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_pubkey_to_point"></a>

## Function `pubkey_to_point`

Given a public key <code>pubkey</code>, returns the underlying <code>RistrettoPoint</code> representing that key.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_pubkey_to_point">pubkey_to_point</a>(pubkey: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">ristretto255_elgamal::CompressedPubkey</a>): <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_pubkey_to_point">pubkey_to_point</a>(pubkey: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">CompressedPubkey</a>): RistrettoPoint {
    <a href="ristretto255.md#0x1_ristretto255_point_decompress">ristretto255::point_decompress</a>(&pubkey.point)
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_pubkey_to_compressed_point"></a>

## Function `pubkey_to_compressed_point`

Given a public key, returns the underlying <code>CompressedRistretto</code> point representing that key.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_pubkey_to_compressed_point">pubkey_to_compressed_point</a>(pubkey: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">ristretto255_elgamal::CompressedPubkey</a>): <a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_pubkey_to_compressed_point">pubkey_to_compressed_point</a>(pubkey: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedPubkey">CompressedPubkey</a>): CompressedRistretto {
    pubkey.point
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_new_ciphertext_from_bytes"></a>

## Function `new_ciphertext_from_bytes`

Creates a new ciphertext from two serialized Ristretto255 points: the first 32 bytes store <code>r * G</code> while the
next 32 bytes store <code>v * G + r * Y</code>, where <code>Y</code> is the public key.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_new_ciphertext_from_bytes">new_ciphertext_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_new_ciphertext_from_bytes">new_ciphertext_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): Option&lt;<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>&gt; {
    <b>if</b>(<a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&bytes) != 64) {
        <b>return</b> std::option::none&lt;<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>&gt;()
    };

    <b>let</b> bytes_right = <a href="../../move-stdlib/doc/vector.md#0x1_vector_trim">vector::trim</a>(&<b>mut</b> bytes, 32);

    <b>let</b> left_point = <a href="ristretto255.md#0x1_ristretto255_new_point_from_bytes">ristretto255::new_point_from_bytes</a>(bytes);
    <b>let</b> right_point = <a href="ristretto255.md#0x1_ristretto255_new_point_from_bytes">ristretto255::new_point_from_bytes</a>(bytes_right);

    <b>if</b> (std::option::is_some&lt;RistrettoPoint&gt;(&<b>mut</b> left_point) && std::option::is_some&lt;RistrettoPoint&gt;(&<b>mut</b> right_point)) {
        std::option::some&lt;<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>&gt;(<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
            left: std::option::extract&lt;RistrettoPoint&gt;(&<b>mut</b> left_point),
            right: std::option::extract&lt;RistrettoPoint&gt;(&<b>mut</b> right_point)
        })
    } <b>else</b> {
        std::option::none&lt;<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>&gt;()
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_new_ciphertext_no_randomness"></a>

## Function `new_ciphertext_no_randomness`

Creates a new ciphertext <code>(val * G + 0 * Y, 0 * G) = (val * G, 0 * G)</code> where <code>G</code> is the Ristretto255 basepoint
and the randomness is set to zero.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_new_ciphertext_no_randomness">new_ciphertext_no_randomness</a>(val: &<a href="ristretto255.md#0x1_ristretto255_Scalar">ristretto255::Scalar</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_new_ciphertext_no_randomness">new_ciphertext_no_randomness</a>(val: &Scalar): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
    <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
        left: <a href="ristretto255.md#0x1_ristretto255_basepoint_mul">ristretto255::basepoint_mul</a>(val),
        right: <a href="ristretto255.md#0x1_ristretto255_point_identity">ristretto255::point_identity</a>(),
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_from_points"></a>

## Function `ciphertext_from_points`

Moves a pair of Ristretto points into an ElGamal ciphertext.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_from_points">ciphertext_from_points</a>(left: <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, right: <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_from_points">ciphertext_from_points</a>(left: RistrettoPoint, right: RistrettoPoint): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
    <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
        left,
        right,
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_from_compressed_points"></a>

## Function `ciphertext_from_compressed_points`

Moves a pair of <code>CompressedRistretto</code> points into an ElGamal ciphertext.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_from_compressed_points">ciphertext_from_compressed_points</a>(left: <a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a>, right: <a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">ristretto255_elgamal::CompressedCiphertext</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_from_compressed_points">ciphertext_from_compressed_points</a>(left: CompressedRistretto, right: CompressedRistretto): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">CompressedCiphertext</a> {
    <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">CompressedCiphertext</a> {
        left,
        right,
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_to_bytes"></a>

## Function `ciphertext_to_bytes`

Given a ciphertext <code>ct</code>, serializes that ciphertext into bytes.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_to_bytes">ciphertext_to_bytes</a>(ct: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_to_bytes">ciphertext_to_bytes</a>(ct: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <b>let</b> bytes_left = <a href="ristretto255.md#0x1_ristretto255_point_to_bytes">ristretto255::point_to_bytes</a>(&<a href="ristretto255.md#0x1_ristretto255_point_compress">ristretto255::point_compress</a>(&ct.left));
    <b>let</b> bytes_right = <a href="ristretto255.md#0x1_ristretto255_point_to_bytes">ristretto255::point_to_bytes</a>(&<a href="ristretto255.md#0x1_ristretto255_point_compress">ristretto255::point_compress</a>(&ct.right));
    <b>let</b> bytes = <a href="../../move-stdlib/doc/vector.md#0x1_vector_empty">vector::empty</a>&lt;u8&gt;();
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_append">vector::append</a>&lt;u8&gt;(&<b>mut</b> bytes, bytes_left);
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_append">vector::append</a>&lt;u8&gt;(&<b>mut</b> bytes, bytes_right);
    bytes
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_into_points"></a>

## Function `ciphertext_into_points`

Moves the ciphertext into a pair of <code>RistrettoPoint</code>'s.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_into_points">ciphertext_into_points</a>(c: <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): (<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_into_points">ciphertext_into_points</a>(c: <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): (RistrettoPoint, RistrettoPoint) {
    <b>let</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> { left, right } = c;
    (left, right)
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_as_points"></a>

## Function `ciphertext_as_points`

Returns the pair of <code>RistrettoPoint</code>'s representing the ciphertext.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_as_points">ciphertext_as_points</a>(c: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): (&<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_as_points">ciphertext_as_points</a>(c: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): (&RistrettoPoint, &RistrettoPoint) {
    (&c.left, &c.right)
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_compress_ciphertext"></a>

## Function `compress_ciphertext`

Creates a new compressed ciphertext from a decompressed ciphertext.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_compress_ciphertext">compress_ciphertext</a>(ct: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">ristretto255_elgamal::CompressedCiphertext</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_compress_ciphertext">compress_ciphertext</a>(ct: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">CompressedCiphertext</a> {
    <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">CompressedCiphertext</a> {
        left: point_compress(&ct.left),
        right: point_compress(&ct.right),
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_decompress_ciphertext"></a>

## Function `decompress_ciphertext`

Creates a new decompressed ciphertext from a compressed ciphertext.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_decompress_ciphertext">decompress_ciphertext</a>(ct: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">ristretto255_elgamal::CompressedCiphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_decompress_ciphertext">decompress_ciphertext</a>(ct: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_CompressedCiphertext">CompressedCiphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
    <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
        left: <a href="ristretto255.md#0x1_ristretto255_point_decompress">ristretto255::point_decompress</a>(&ct.left),
        right: <a href="ristretto255.md#0x1_ristretto255_point_decompress">ristretto255::point_decompress</a>(&ct.right),
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_add"></a>

## Function `ciphertext_add`

Homomorphically combines two ciphertexts <code>lhs</code> and <code>rhs</code> as <code>lhs + rhs</code>.
Useful for re-randomizing the ciphertext or updating the committed value.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_add">ciphertext_add</a>(lhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_add">ciphertext_add</a>(lhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
    <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
        left: <a href="ristretto255.md#0x1_ristretto255_point_add">ristretto255::point_add</a>(&lhs.left, &rhs.left),
        right: <a href="ristretto255.md#0x1_ristretto255_point_add">ristretto255::point_add</a>(&lhs.right, &rhs.right),
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_add_assign"></a>

## Function `ciphertext_add_assign`

Like <code>ciphertext_add</code> but assigns <code>lhs = lhs + rhs</code>.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_add_assign">ciphertext_add_assign</a>(lhs: &<b>mut</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_add_assign">ciphertext_add_assign</a>(lhs: &<b>mut</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>) {
    <a href="ristretto255.md#0x1_ristretto255_point_add_assign">ristretto255::point_add_assign</a>(&<b>mut</b> lhs.left, &rhs.left);
    <a href="ristretto255.md#0x1_ristretto255_point_add_assign">ristretto255::point_add_assign</a>(&<b>mut</b> lhs.right, &rhs.right);
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_sub"></a>

## Function `ciphertext_sub`

Homomorphically combines two ciphertexts <code>lhs</code> and <code>rhs</code> as <code>lhs - rhs</code>.
Useful for re-randomizing the ciphertext or updating the committed value.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_sub">ciphertext_sub</a>(lhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_sub">ciphertext_sub</a>(lhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
    <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
        left: <a href="ristretto255.md#0x1_ristretto255_point_sub">ristretto255::point_sub</a>(&lhs.left, &rhs.left),
        right: <a href="ristretto255.md#0x1_ristretto255_point_sub">ristretto255::point_sub</a>(&lhs.right, &rhs.right),
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_sub_assign"></a>

## Function `ciphertext_sub_assign`

Like <code>ciphertext_add</code> but assigns <code>lhs = lhs - rhs</code>.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_sub_assign">ciphertext_sub_assign</a>(lhs: &<b>mut</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_sub_assign">ciphertext_sub_assign</a>(lhs: &<b>mut</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>) {
    <a href="ristretto255.md#0x1_ristretto255_point_sub_assign">ristretto255::point_sub_assign</a>(&<b>mut</b> lhs.left, &rhs.left);
    <a href="ristretto255.md#0x1_ristretto255_point_sub_assign">ristretto255::point_sub_assign</a>(&<b>mut</b> lhs.right, &rhs.right);
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_clone"></a>

## Function `ciphertext_clone`

Creates a copy of this ciphertext.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_clone">ciphertext_clone</a>(c: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_clone">ciphertext_clone</a>(c: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
    <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a> {
        left: <a href="ristretto255.md#0x1_ristretto255_point_clone">ristretto255::point_clone</a>(&c.left),
        right: <a href="ristretto255.md#0x1_ristretto255_point_clone">ristretto255::point_clone</a>(&c.right),
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_ciphertext_equals"></a>

## Function `ciphertext_equals`

Returns true if the two ciphertexts are identical: i.e., same value and same randomness.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_equals">ciphertext_equals</a>(lhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_ciphertext_equals">ciphertext_equals</a>(lhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>, rhs: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): bool {
    <a href="ristretto255.md#0x1_ristretto255_point_equals">ristretto255::point_equals</a>(&lhs.left, &rhs.left) &&
    <a href="ristretto255.md#0x1_ristretto255_point_equals">ristretto255::point_equals</a>(&lhs.right, &rhs.right)
}
</code></pre>



</details>

<a id="0x1_ristretto255_elgamal_get_value_component"></a>

## Function `get_value_component`

Returns the <code>RistrettoPoint</code> in the ciphertext which contains the encrypted value in the exponent.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_get_value_component">get_value_component</a>(ct: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">ristretto255_elgamal::Ciphertext</a>): &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_get_value_component">get_value_component</a>(ct: &<a href="ristretto255_elgamal.md#0x1_ristretto255_elgamal_Ciphertext">Ciphertext</a>): &RistrettoPoint {
    &ct.left
}
</code></pre>



</details>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/ristretto255_pedersen.md
================================================

<a id="0x1_ristretto255_pedersen"></a>

# Module `0x1::ristretto255_pedersen`

This module implements a Pedersen commitment API, over the Ristretto255 curve, that can be used with the
Bulletproofs module.

A Pedersen commitment to a value <code>v</code> under _commitment key_ <code>(g, h)</code> is <code>v * g + r * h</code>, for a random scalar <code>r</code>.


-  [Struct `Commitment`](#0x1_ristretto255_pedersen_Commitment)
-  [Constants](#@Constants_0)
-  [Function `new_commitment_from_bytes`](#0x1_ristretto255_pedersen_new_commitment_from_bytes)
-  [Function `commitment_to_bytes`](#0x1_ristretto255_pedersen_commitment_to_bytes)
-  [Function `commitment_from_point`](#0x1_ristretto255_pedersen_commitment_from_point)
-  [Function `commitment_from_compressed`](#0x1_ristretto255_pedersen_commitment_from_compressed)
-  [Function `new_commitment`](#0x1_ristretto255_pedersen_new_commitment)
-  [Function `new_commitment_with_basepoint`](#0x1_ristretto255_pedersen_new_commitment_with_basepoint)
-  [Function `new_commitment_for_bulletproof`](#0x1_ristretto255_pedersen_new_commitment_for_bulletproof)
-  [Function `commitment_add`](#0x1_ristretto255_pedersen_commitment_add)
-  [Function `commitment_add_assign`](#0x1_ristretto255_pedersen_commitment_add_assign)
-  [Function `commitment_sub`](#0x1_ristretto255_pedersen_commitment_sub)
-  [Function `commitment_sub_assign`](#0x1_ristretto255_pedersen_commitment_sub_assign)
-  [Function `commitment_clone`](#0x1_ristretto255_pedersen_commitment_clone)
-  [Function `commitment_equals`](#0x1_ristretto255_pedersen_commitment_equals)
-  [Function `commitment_as_point`](#0x1_ristretto255_pedersen_commitment_as_point)
-  [Function `commitment_as_compressed_point`](#0x1_ristretto255_pedersen_commitment_as_compressed_point)
-  [Function `commitment_into_point`](#0x1_ristretto255_pedersen_commitment_into_point)
-  [Function `commitment_into_compressed_point`](#0x1_ristretto255_pedersen_commitment_into_compressed_point)
-  [Function `randomness_base_for_bulletproof`](#0x1_ristretto255_pedersen_randomness_base_for_bulletproof)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/option.md#0x1_option">0x1::option</a>;
<b>use</b> <a href="ristretto255.md#0x1_ristretto255">0x1::ristretto255</a>;
</code></pre>



<a id="0x1_ristretto255_pedersen_Commitment"></a>

## Struct `Commitment`

A Pedersen commitment to some value with some randomness.


<pre><code><b>struct</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>point: <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a></code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_ristretto255_pedersen_BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE"></a>

The default Pedersen randomness base <code>h</code> used in our underlying Bulletproofs library.
This is obtained by hashing the compressed Ristretto255 basepoint using SHA3-512 (not SHA2-512).


<pre><code><b>const</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE">BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE</a>: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; = [140, 146, 64, 180, 86, 169, 230, 220, 101, 195, 119, 161, 4, 141, 116, 95, 148, 160, 140, 219, 127, 68, 203, 205, 123, 70, 243, 64, 72, 135, 17, 52];
</code></pre>



<a id="0x1_ristretto255_pedersen_new_commitment_from_bytes"></a>

## Function `new_commitment_from_bytes`

Creates a new public key from a serialized Ristretto255 point.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_new_commitment_from_bytes">new_commitment_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_new_commitment_from_bytes">new_commitment_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): Option&lt;<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>&gt; {
    <b>let</b> point = <a href="ristretto255.md#0x1_ristretto255_new_point_from_bytes">ristretto255::new_point_from_bytes</a>(bytes);
    <b>if</b> (std::option::is_some(&<b>mut</b> point)) {
        <b>let</b> comm = <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
            point: std::option::extract(&<b>mut</b> point)
        };
        std::option::some(comm)
    } <b>else</b> {
        std::option::none&lt;<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>&gt;()
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_to_bytes"></a>

## Function `commitment_to_bytes`

Returns a commitment as a serialized byte array


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_to_bytes">commitment_to_bytes</a>(comm: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_to_bytes">commitment_to_bytes</a>(comm: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <a href="ristretto255.md#0x1_ristretto255_point_to_bytes">ristretto255::point_to_bytes</a>(&<a href="ristretto255.md#0x1_ristretto255_point_compress">ristretto255::point_compress</a>(&comm.point))
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_from_point"></a>

## Function `commitment_from_point`

Moves a Ristretto point into a Pedersen commitment.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_from_point">commitment_from_point</a>(point: <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_from_point">commitment_from_point</a>(point: RistrettoPoint): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
    <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
        point
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_from_compressed"></a>

## Function `commitment_from_compressed`

Deserializes a commitment from a compressed Ristretto point.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_from_compressed">commitment_from_compressed</a>(point: &<a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_from_compressed">commitment_from_compressed</a>(point: &CompressedRistretto): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
    <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
        point: <a href="ristretto255.md#0x1_ristretto255_point_decompress">ristretto255::point_decompress</a>(point)
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_new_commitment"></a>

## Function `new_commitment`

Returns a commitment <code>v * val_base + r * rand_base</code> where <code>(val_base, rand_base)</code> is the commitment key.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_new_commitment">new_commitment</a>(v: &<a href="ristretto255.md#0x1_ristretto255_Scalar">ristretto255::Scalar</a>, val_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>, r: &<a href="ristretto255.md#0x1_ristretto255_Scalar">ristretto255::Scalar</a>, rand_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_new_commitment">new_commitment</a>(v: &Scalar, val_base: &RistrettoPoint, r: &Scalar, rand_base: &RistrettoPoint): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
    <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
        point: <a href="ristretto255.md#0x1_ristretto255_double_scalar_mul">ristretto255::double_scalar_mul</a>(v, val_base, r, rand_base)
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_new_commitment_with_basepoint"></a>

## Function `new_commitment_with_basepoint`

Returns a commitment <code>v * G + r * rand_base</code> where <code>G</code> is the Ristretto255 basepoint.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_new_commitment_with_basepoint">new_commitment_with_basepoint</a>(v: &<a href="ristretto255.md#0x1_ristretto255_Scalar">ristretto255::Scalar</a>, r: &<a href="ristretto255.md#0x1_ristretto255_Scalar">ristretto255::Scalar</a>, rand_base: &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_new_commitment_with_basepoint">new_commitment_with_basepoint</a>(v: &Scalar, r: &Scalar, rand_base: &RistrettoPoint): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
    <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
        point: <a href="ristretto255.md#0x1_ristretto255_basepoint_double_mul">ristretto255::basepoint_double_mul</a>(r, rand_base, v)
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_new_commitment_for_bulletproof"></a>

## Function `new_commitment_for_bulletproof`

Returns a commitment <code>v * G + r * H</code> where <code>G</code> is the Ristretto255 basepoint and <code>H</code> is the default randomness
base used in the Bulletproofs library (i.e., <code><a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE">BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE</a></code>).


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_new_commitment_for_bulletproof">new_commitment_for_bulletproof</a>(v: &<a href="ristretto255.md#0x1_ristretto255_Scalar">ristretto255::Scalar</a>, r: &<a href="ristretto255.md#0x1_ristretto255_Scalar">ristretto255::Scalar</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_new_commitment_for_bulletproof">new_commitment_for_bulletproof</a>(v: &Scalar, r: &Scalar): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
    <b>let</b> rand_base = <a href="ristretto255.md#0x1_ristretto255_new_point_from_bytes">ristretto255::new_point_from_bytes</a>(<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE">BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE</a>);
    <b>let</b> rand_base = std::option::extract(&<b>mut</b> rand_base);

    <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
        point: <a href="ristretto255.md#0x1_ristretto255_basepoint_double_mul">ristretto255::basepoint_double_mul</a>(r, &rand_base, v)
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_add"></a>

## Function `commitment_add`

Homomorphically combines two commitments <code>lhs</code> and <code>rhs</code> as <code>lhs + rhs</code>.
Useful for re-randomizing the commitment or updating the committed value.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_add">commitment_add</a>(lhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_add">commitment_add</a>(lhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
    <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
        point: <a href="ristretto255.md#0x1_ristretto255_point_add">ristretto255::point_add</a>(&lhs.point, &rhs.point)
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_add_assign"></a>

## Function `commitment_add_assign`

Like <code>commitment_add</code> but assigns <code>lhs = lhs + rhs</code>.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_add_assign">commitment_add_assign</a>(lhs: &<b>mut</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_add_assign">commitment_add_assign</a>(lhs: &<b>mut</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>) {
    <a href="ristretto255.md#0x1_ristretto255_point_add_assign">ristretto255::point_add_assign</a>(&<b>mut</b> lhs.point, &rhs.point);
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_sub"></a>

## Function `commitment_sub`

Homomorphically combines two commitments <code>lhs</code> and <code>rhs</code> as <code>lhs - rhs</code>.
Useful for re-randomizing the commitment or updating the committed value.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_sub">commitment_sub</a>(lhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_sub">commitment_sub</a>(lhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
    <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
        point: <a href="ristretto255.md#0x1_ristretto255_point_sub">ristretto255::point_sub</a>(&lhs.point, &rhs.point)
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_sub_assign"></a>

## Function `commitment_sub_assign`

Like <code>commitment_add</code> but assigns <code>lhs = lhs - rhs</code>.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_sub_assign">commitment_sub_assign</a>(lhs: &<b>mut</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_sub_assign">commitment_sub_assign</a>(lhs: &<b>mut</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>) {
    <a href="ristretto255.md#0x1_ristretto255_point_sub_assign">ristretto255::point_sub_assign</a>(&<b>mut</b> lhs.point, &rhs.point);
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_clone"></a>

## Function `commitment_clone`

Creates a copy of this commitment.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_clone">commitment_clone</a>(c: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_clone">commitment_clone</a>(c: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
    <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> {
        point: <a href="ristretto255.md#0x1_ristretto255_point_clone">ristretto255::point_clone</a>(&c.point)
    }
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_equals"></a>

## Function `commitment_equals`

Returns true if the two commitments are identical: i.e., same value and same randomness.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_equals">commitment_equals</a>(lhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_equals">commitment_equals</a>(lhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>, rhs: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): bool {
    <a href="ristretto255.md#0x1_ristretto255_point_equals">ristretto255::point_equals</a>(&lhs.point, &rhs.point)
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_as_point"></a>

## Function `commitment_as_point`

Returns the underlying elliptic curve point representing the commitment as an in-memory <code>RistrettoPoint</code>.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_as_point">commitment_as_point</a>(c: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): &<a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_as_point">commitment_as_point</a>(c: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): &RistrettoPoint {
    &c.point
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_as_compressed_point"></a>

## Function `commitment_as_compressed_point`

Returns the Pedersen commitment as a <code>CompressedRistretto</code> point.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_as_compressed_point">commitment_as_compressed_point</a>(c: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): <a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_as_compressed_point">commitment_as_compressed_point</a>(c: &<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): CompressedRistretto {
    point_compress(&c.point)
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_into_point"></a>

## Function `commitment_into_point`

Moves the Commitment into a CompressedRistretto point.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_into_point">commitment_into_point</a>(c: <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_into_point">commitment_into_point</a>(c: <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): RistrettoPoint {
    <b>let</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a> { point } = c;
    point
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_commitment_into_compressed_point"></a>

## Function `commitment_into_compressed_point`

Moves the Commitment into a <code>CompressedRistretto</code> point.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_into_compressed_point">commitment_into_compressed_point</a>(c: <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">ristretto255_pedersen::Commitment</a>): <a href="ristretto255.md#0x1_ristretto255_CompressedRistretto">ristretto255::CompressedRistretto</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_commitment_into_compressed_point">commitment_into_compressed_point</a>(c: <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_Commitment">Commitment</a>): CompressedRistretto {
    point_compress(&c.point)
}
</code></pre>



</details>

<a id="0x1_ristretto255_pedersen_randomness_base_for_bulletproof"></a>

## Function `randomness_base_for_bulletproof`

Returns the randomness base compatible with the Bulletproofs module.

Recal that a Bulletproof range proof attests, in zero-knowledge, that a value <code>v</code> inside a Pedersen commitment
<code>v * g + r * h</code> is sufficiently "small" (e.g., is 32-bits wide). Here, <code>h</code> is referred to as the
"randomness base" of the commitment scheme.

Bulletproof has a default choice for <code>g</code> and <code>h</code> and this function returns the default <code>h</code> as used in the
Bulletproofs Move module.


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_randomness_base_for_bulletproof">randomness_base_for_bulletproof</a>(): <a href="ristretto255.md#0x1_ristretto255_RistrettoPoint">ristretto255::RistrettoPoint</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_randomness_base_for_bulletproof">randomness_base_for_bulletproof</a>(): RistrettoPoint {
    std::option::extract(&<b>mut</b> <a href="ristretto255.md#0x1_ristretto255_new_point_from_bytes">ristretto255::new_point_from_bytes</a>(<a href="ristretto255_pedersen.md#0x1_ristretto255_pedersen_BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE">BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE</a>))
}
</code></pre>



</details>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/secp256k1.md
================================================

<a id="0x1_secp256k1"></a>

# Module `0x1::secp256k1`

This module implements ECDSA signatures based on the prime-order secp256k1 ellptic curve (i.e., cofactor is 1).


-  [Struct `ECDSARawPublicKey`](#0x1_secp256k1_ECDSARawPublicKey)
-  [Struct `ECDSASignature`](#0x1_secp256k1_ECDSASignature)
-  [Constants](#@Constants_0)
-  [Function `ecdsa_signature_from_bytes`](#0x1_secp256k1_ecdsa_signature_from_bytes)
-  [Function `ecdsa_raw_public_key_from_64_bytes`](#0x1_secp256k1_ecdsa_raw_public_key_from_64_bytes)
-  [Function `ecdsa_raw_public_key_to_bytes`](#0x1_secp256k1_ecdsa_raw_public_key_to_bytes)
-  [Function `ecdsa_signature_to_bytes`](#0x1_secp256k1_ecdsa_signature_to_bytes)
-  [Function `ecdsa_recover`](#0x1_secp256k1_ecdsa_recover)
-  [Function `ecdsa_recover_internal`](#0x1_secp256k1_ecdsa_recover_internal)
-  [Specification](#@Specification_1)
    -  [Function `ecdsa_signature_from_bytes`](#@Specification_1_ecdsa_signature_from_bytes)
    -  [Function `ecdsa_raw_public_key_from_64_bytes`](#@Specification_1_ecdsa_raw_public_key_from_64_bytes)
    -  [Function `ecdsa_raw_public_key_to_bytes`](#@Specification_1_ecdsa_raw_public_key_to_bytes)
    -  [Function `ecdsa_signature_to_bytes`](#@Specification_1_ecdsa_signature_to_bytes)
    -  [Function `ecdsa_recover`](#@Specification_1_ecdsa_recover)
    -  [Function `ecdsa_recover_internal`](#@Specification_1_ecdsa_recover_internal)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/option.md#0x1_option">0x1::option</a>;
</code></pre>



<a id="0x1_secp256k1_ECDSARawPublicKey"></a>

## Struct `ECDSARawPublicKey`

A 64-byte ECDSA public key.


<pre><code><b>struct</b> <a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">ECDSARawPublicKey</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_secp256k1_ECDSASignature"></a>

## Struct `ECDSASignature`

A 64-byte ECDSA signature.


<pre><code><b>struct</b> <a href="secp256k1.md#0x1_secp256k1_ECDSASignature">ECDSASignature</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_secp256k1_SIGNATURE_NUM_BYTES"></a>

The size of a secp256k1-based ECDSA signature, in bytes.


<pre><code><b>const</b> <a href="secp256k1.md#0x1_secp256k1_SIGNATURE_NUM_BYTES">SIGNATURE_NUM_BYTES</a>: u64 = 64;
</code></pre>



<a id="0x1_secp256k1_E_DESERIALIZE"></a>

An error occurred while deserializing, for example due to wrong input size.


<pre><code><b>const</b> <a href="secp256k1.md#0x1_secp256k1_E_DESERIALIZE">E_DESERIALIZE</a>: u64 = 1;
</code></pre>



<a id="0x1_secp256k1_RAW_PUBLIC_KEY_NUM_BYTES"></a>

The size of a secp256k1-based ECDSA public key, in bytes.


<pre><code><b>const</b> <a href="secp256k1.md#0x1_secp256k1_RAW_PUBLIC_KEY_NUM_BYTES">RAW_PUBLIC_KEY_NUM_BYTES</a>: u64 = 64;
</code></pre>



<a id="0x1_secp256k1_ecdsa_signature_from_bytes"></a>

## Function `ecdsa_signature_from_bytes`

Constructs an ECDSASignature struct from the given 64 bytes.


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_signature_from_bytes">ecdsa_signature_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="secp256k1.md#0x1_secp256k1_ECDSASignature">secp256k1::ECDSASignature</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_signature_from_bytes">ecdsa_signature_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="secp256k1.md#0x1_secp256k1_ECDSASignature">ECDSASignature</a> {
    <b>assert</b>!(std::vector::length(&bytes) == <a href="secp256k1.md#0x1_secp256k1_SIGNATURE_NUM_BYTES">SIGNATURE_NUM_BYTES</a>, std::error::invalid_argument(<a href="secp256k1.md#0x1_secp256k1_E_DESERIALIZE">E_DESERIALIZE</a>));
    <a href="secp256k1.md#0x1_secp256k1_ECDSASignature">ECDSASignature</a> { bytes }
}
</code></pre>



</details>

<a id="0x1_secp256k1_ecdsa_raw_public_key_from_64_bytes"></a>

## Function `ecdsa_raw_public_key_from_64_bytes`

Constructs an ECDSARawPublicKey struct, given a 64-byte raw representation.


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_raw_public_key_from_64_bytes">ecdsa_raw_public_key_from_64_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">secp256k1::ECDSARawPublicKey</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_raw_public_key_from_64_bytes">ecdsa_raw_public_key_from_64_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">ECDSARawPublicKey</a> {
    <b>assert</b>!(std::vector::length(&bytes) == <a href="secp256k1.md#0x1_secp256k1_RAW_PUBLIC_KEY_NUM_BYTES">RAW_PUBLIC_KEY_NUM_BYTES</a>, std::error::invalid_argument(<a href="secp256k1.md#0x1_secp256k1_E_DESERIALIZE">E_DESERIALIZE</a>));
    <a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">ECDSARawPublicKey</a> { bytes }
}
</code></pre>



</details>

<a id="0x1_secp256k1_ecdsa_raw_public_key_to_bytes"></a>

## Function `ecdsa_raw_public_key_to_bytes`

Serializes an ECDSARawPublicKey struct to 64-bytes.


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_raw_public_key_to_bytes">ecdsa_raw_public_key_to_bytes</a>(pk: &<a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">secp256k1::ECDSARawPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_raw_public_key_to_bytes">ecdsa_raw_public_key_to_bytes</a>(pk: &<a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">ECDSARawPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    pk.bytes
}
</code></pre>



</details>

<a id="0x1_secp256k1_ecdsa_signature_to_bytes"></a>

## Function `ecdsa_signature_to_bytes`

Serializes an ECDSASignature struct to 64-bytes.


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_signature_to_bytes">ecdsa_signature_to_bytes</a>(sig: &<a href="secp256k1.md#0x1_secp256k1_ECDSASignature">secp256k1::ECDSASignature</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_signature_to_bytes">ecdsa_signature_to_bytes</a>(sig: &<a href="secp256k1.md#0x1_secp256k1_ECDSASignature">ECDSASignature</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    sig.bytes
}
</code></pre>



</details>

<a id="0x1_secp256k1_ecdsa_recover"></a>

## Function `ecdsa_recover`

Recovers the signer's raw (64-byte) public key from a secp256k1 ECDSA <code>signature</code> given the <code>recovery_id</code> and the signed
<code>message</code> (32 byte digest).

Note that an invalid signature, or a signature from a different message, will result in the recovery of an
incorrect public key. This recovery algorithm can only be used to check validity of a signature if the signer's
public key (or its hash) is known beforehand.


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover">ecdsa_recover</a>(message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, recovery_id: u8, signature: &<a href="secp256k1.md#0x1_secp256k1_ECDSASignature">secp256k1::ECDSASignature</a>): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;<a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">secp256k1::ECDSARawPublicKey</a>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover">ecdsa_recover</a>(
    message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;,
    recovery_id: u8,
    signature: &<a href="secp256k1.md#0x1_secp256k1_ECDSASignature">ECDSASignature</a>,
): Option&lt;<a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">ECDSARawPublicKey</a>&gt; {
    <b>let</b> (pk, success) = <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover_internal">ecdsa_recover_internal</a>(message, recovery_id, signature.bytes);
    <b>if</b> (success) {
        std::option::some(<a href="secp256k1.md#0x1_secp256k1_ecdsa_raw_public_key_from_64_bytes">ecdsa_raw_public_key_from_64_bytes</a>(pk))
    } <b>else</b> {
        std::option::none&lt;<a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">ECDSARawPublicKey</a>&gt;()
    }
}
</code></pre>



</details>

<a id="0x1_secp256k1_ecdsa_recover_internal"></a>

## Function `ecdsa_recover_internal`

Returns <code>(public_key, <b>true</b>)</code> if <code>signature</code> verifies on <code>message</code> under the recovered <code>public_key</code>
and returns <code>([], <b>false</b>)</code> otherwise.


<pre><code><b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover_internal">ecdsa_recover_internal</a>(message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, recovery_id: u8, signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): (<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, bool)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover_internal">ecdsa_recover_internal</a>(
    message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;,
    recovery_id: u8,
    signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
): (<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, bool);
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_ecdsa_signature_from_bytes"></a>

### Function `ecdsa_signature_from_bytes`


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_signature_from_bytes">ecdsa_signature_from_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="secp256k1.md#0x1_secp256k1_ECDSASignature">secp256k1::ECDSASignature</a>
</code></pre>




<pre><code><b>aborts_if</b> len(bytes) != <a href="secp256k1.md#0x1_secp256k1_SIGNATURE_NUM_BYTES">SIGNATURE_NUM_BYTES</a>;
<b>ensures</b> result == <a href="secp256k1.md#0x1_secp256k1_ECDSASignature">ECDSASignature</a> { bytes };
</code></pre>



<a id="@Specification_1_ecdsa_raw_public_key_from_64_bytes"></a>

### Function `ecdsa_raw_public_key_from_64_bytes`


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_raw_public_key_from_64_bytes">ecdsa_raw_public_key_from_64_bytes</a>(bytes: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">secp256k1::ECDSARawPublicKey</a>
</code></pre>




<pre><code><b>aborts_if</b> len(bytes) != <a href="secp256k1.md#0x1_secp256k1_RAW_PUBLIC_KEY_NUM_BYTES">RAW_PUBLIC_KEY_NUM_BYTES</a>;
<b>ensures</b> result == <a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">ECDSARawPublicKey</a> { bytes };
</code></pre>



<a id="@Specification_1_ecdsa_raw_public_key_to_bytes"></a>

### Function `ecdsa_raw_public_key_to_bytes`


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_raw_public_key_to_bytes">ecdsa_raw_public_key_to_bytes</a>(pk: &<a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">secp256k1::ECDSARawPublicKey</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == pk.bytes;
</code></pre>



<a id="@Specification_1_ecdsa_signature_to_bytes"></a>

### Function `ecdsa_signature_to_bytes`


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_signature_to_bytes">ecdsa_signature_to_bytes</a>(sig: &<a href="secp256k1.md#0x1_secp256k1_ECDSASignature">secp256k1::ECDSASignature</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == sig.bytes;
</code></pre>



<a id="@Specification_1_ecdsa_recover"></a>

### Function `ecdsa_recover`


<pre><code><b>public</b> <b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover">ecdsa_recover</a>(message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, recovery_id: u8, signature: &<a href="secp256k1.md#0x1_secp256k1_ECDSASignature">secp256k1::ECDSASignature</a>): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;<a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">secp256k1::ECDSARawPublicKey</a>&gt;
</code></pre>




<pre><code><b>aborts_if</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover_internal_abort_condition">ecdsa_recover_internal_abort_condition</a>(message, recovery_id, signature.bytes);
<b>let</b> pk = <a href="secp256k1.md#0x1_secp256k1_spec_ecdsa_recover_internal_result_1">spec_ecdsa_recover_internal_result_1</a>(message, recovery_id, signature.bytes);
<b>let</b> success = <a href="secp256k1.md#0x1_secp256k1_spec_ecdsa_recover_internal_result_2">spec_ecdsa_recover_internal_result_2</a>(message, recovery_id, signature.bytes);
<b>ensures</b> success ==&gt; result == std::option::spec_some(<a href="secp256k1.md#0x1_secp256k1_ecdsa_raw_public_key_from_64_bytes">ecdsa_raw_public_key_from_64_bytes</a>(pk));
<b>ensures</b> !success ==&gt; result == std::option::spec_none&lt;<a href="secp256k1.md#0x1_secp256k1_ECDSARawPublicKey">ECDSARawPublicKey</a>&gt;();
</code></pre>



<a id="@Specification_1_ecdsa_recover_internal"></a>

### Function `ecdsa_recover_internal`


<pre><code><b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover_internal">ecdsa_recover_internal</a>(message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, recovery_id: u8, signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): (<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, bool)
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover_internal_abort_condition">ecdsa_recover_internal_abort_condition</a>(message, recovery_id, signature);
<b>ensures</b> result_1 == <a href="secp256k1.md#0x1_secp256k1_spec_ecdsa_recover_internal_result_1">spec_ecdsa_recover_internal_result_1</a>(message, recovery_id, signature);
<b>ensures</b> result_2 == <a href="secp256k1.md#0x1_secp256k1_spec_ecdsa_recover_internal_result_2">spec_ecdsa_recover_internal_result_2</a>(message, recovery_id, signature);
<b>ensures</b> len(result_1) == <b>if</b> (result_2) { <a href="secp256k1.md#0x1_secp256k1_RAW_PUBLIC_KEY_NUM_BYTES">RAW_PUBLIC_KEY_NUM_BYTES</a> } <b>else</b> { 0 };
</code></pre>




<a id="0x1_secp256k1_ecdsa_recover_internal_abort_condition"></a>


<pre><code><b>fun</b> <a href="secp256k1.md#0x1_secp256k1_ecdsa_recover_internal_abort_condition">ecdsa_recover_internal_abort_condition</a>(message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, recovery_id: u8, signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool;
</code></pre>




<a id="0x1_secp256k1_spec_ecdsa_recover_internal_result_1"></a>


<pre><code><b>fun</b> <a href="secp256k1.md#0x1_secp256k1_spec_ecdsa_recover_internal_result_1">spec_ecdsa_recover_internal_result_1</a>(message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, recovery_id: u8, signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>




<a id="0x1_secp256k1_spec_ecdsa_recover_internal_result_2"></a>


<pre><code><b>fun</b> <a href="secp256k1.md#0x1_secp256k1_spec_ecdsa_recover_internal_result_2">spec_ecdsa_recover_internal_result_2</a>(message: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, recovery_id: u8, signature: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/simple_map.md
================================================

<a id="0x1_simple_map"></a>

# Module `0x1::simple_map`

This module provides a solution for unsorted maps, that is it has the properties that
1) Keys point to Values
2) Each Key must be unique
3) A Key can be found within O(N) time
4) The keys are unsorted.
5) Adds and removals take O(N) time


-  [Struct `SimpleMap`](#0x1_simple_map_SimpleMap)
-  [Struct `Element`](#0x1_simple_map_Element)
-  [Constants](#@Constants_0)
-  [Function `length`](#0x1_simple_map_length)
-  [Function `new`](#0x1_simple_map_new)
-  [Function `new_from`](#0x1_simple_map_new_from)
-  [Function `create`](#0x1_simple_map_create)
-  [Function `borrow`](#0x1_simple_map_borrow)
-  [Function `borrow_mut`](#0x1_simple_map_borrow_mut)
-  [Function `contains_key`](#0x1_simple_map_contains_key)
-  [Function `destroy_empty`](#0x1_simple_map_destroy_empty)
-  [Function `add`](#0x1_simple_map_add)
-  [Function `add_all`](#0x1_simple_map_add_all)
-  [Function `upsert`](#0x1_simple_map_upsert)
-  [Function `keys`](#0x1_simple_map_keys)
-  [Function `values`](#0x1_simple_map_values)
-  [Function `to_vec_pair`](#0x1_simple_map_to_vec_pair)
-  [Function `destroy`](#0x1_simple_map_destroy)
-  [Function `remove`](#0x1_simple_map_remove)
-  [Function `find`](#0x1_simple_map_find)
-  [Specification](#@Specification_1)
    -  [Struct `SimpleMap`](#@Specification_1_SimpleMap)
    -  [Function `length`](#@Specification_1_length)
    -  [Function `new`](#@Specification_1_new)
    -  [Function `new_from`](#@Specification_1_new_from)
    -  [Function `create`](#@Specification_1_create)
    -  [Function `borrow`](#@Specification_1_borrow)
    -  [Function `borrow_mut`](#@Specification_1_borrow_mut)
    -  [Function `contains_key`](#@Specification_1_contains_key)
    -  [Function `destroy_empty`](#@Specification_1_destroy_empty)
    -  [Function `add`](#@Specification_1_add)
    -  [Function `add_all`](#@Specification_1_add_all)
    -  [Function `upsert`](#@Specification_1_upsert)
    -  [Function `keys`](#@Specification_1_keys)
    -  [Function `values`](#@Specification_1_values)
    -  [Function `to_vec_pair`](#@Specification_1_to_vec_pair)
    -  [Function `remove`](#@Specification_1_remove)
    -  [Function `find`](#@Specification_1_find)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/option.md#0x1_option">0x1::option</a>;
<b>use</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector">0x1::vector</a>;
</code></pre>



<a id="0x1_simple_map_SimpleMap"></a>

## Struct `SimpleMap`



<pre><code><b>struct</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>data: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;<a href="simple_map.md#0x1_simple_map_Element">simple_map::Element</a>&lt;Key, Value&gt;&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_simple_map_Element"></a>

## Struct `Element`



<pre><code><b>struct</b> <a href="simple_map.md#0x1_simple_map_Element">Element</a>&lt;Key, Value&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>key: Key</code>
</dt>
<dd>

</dd>
<dt>
<code>value: Value</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_simple_map_EKEY_ALREADY_EXISTS"></a>

Map key already exists


<pre><code><b>const</b> <a href="simple_map.md#0x1_simple_map_EKEY_ALREADY_EXISTS">EKEY_ALREADY_EXISTS</a>: u64 = 1;
</code></pre>



<a id="0x1_simple_map_EKEY_NOT_FOUND"></a>

Map key is not found


<pre><code><b>const</b> <a href="simple_map.md#0x1_simple_map_EKEY_NOT_FOUND">EKEY_NOT_FOUND</a>: u64 = 2;
</code></pre>



<a id="0x1_simple_map_length"></a>

## Function `length`



<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_length">length</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_length">length</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;): u64 {
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&map.data)
}
</code></pre>



</details>

<a id="0x1_simple_map_new"></a>

## Function `new`

Create an empty SimpleMap.


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_new">new</a>&lt;Key: store, Value: store&gt;(): <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_new">new</a>&lt;Key: store, Value: store&gt;(): <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt; {
    <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a> {
        data: <a href="../../move-stdlib/doc/vector.md#0x1_vector_empty">vector::empty</a>(),
    }
}
</code></pre>



</details>

<a id="0x1_simple_map_new_from"></a>

## Function `new_from`

Create a SimpleMap from a vector of keys and values. The keys must be unique.


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_new_from">new_from</a>&lt;Key: store, Value: store&gt;(keys: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;, values: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;): <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_new_from">new_from</a>&lt;Key: store, Value: store&gt;(
    keys: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;,
    values: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;,
): <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt; {
    <b>let</b> map = <a href="simple_map.md#0x1_simple_map_new">new</a>();
    <a href="simple_map.md#0x1_simple_map_add_all">add_all</a>(&<b>mut</b> map, keys, values);
    map
}
</code></pre>



</details>

<a id="0x1_simple_map_create"></a>

## Function `create`

Create an empty SimpleMap.
This function is deprecated, use <code>new</code> instead.


<pre><code>#[deprecated]
<b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_create">create</a>&lt;Key: store, Value: store&gt;(): <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_create">create</a>&lt;Key: store, Value: store&gt;(): <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt; {
    <a href="simple_map.md#0x1_simple_map_new">new</a>()
}
</code></pre>



</details>

<a id="0x1_simple_map_borrow"></a>

## Function `borrow`



<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_borrow">borrow</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): &Value
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_borrow">borrow</a>&lt;Key: store, Value: store&gt;(
    map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    key: &Key,
): &Value {
    <b>let</b> maybe_idx = <a href="simple_map.md#0x1_simple_map_find">find</a>(map, key);
    <b>assert</b>!(<a href="../../move-stdlib/doc/option.md#0x1_option_is_some">option::is_some</a>(&maybe_idx), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="simple_map.md#0x1_simple_map_EKEY_NOT_FOUND">EKEY_NOT_FOUND</a>));
    <b>let</b> idx = <a href="../../move-stdlib/doc/option.md#0x1_option_extract">option::extract</a>(&<b>mut</b> maybe_idx);
    &<a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(&map.data, idx).value
}
</code></pre>



</details>

<a id="0x1_simple_map_borrow_mut"></a>

## Function `borrow_mut`



<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_borrow_mut">borrow_mut</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): &<b>mut</b> Value
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_borrow_mut">borrow_mut</a>&lt;Key: store, Value: store&gt;(
    map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    key: &Key,
): &<b>mut</b> Value {
    <b>let</b> maybe_idx = <a href="simple_map.md#0x1_simple_map_find">find</a>(map, key);
    <b>assert</b>!(<a href="../../move-stdlib/doc/option.md#0x1_option_is_some">option::is_some</a>(&maybe_idx), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="simple_map.md#0x1_simple_map_EKEY_NOT_FOUND">EKEY_NOT_FOUND</a>));
    <b>let</b> idx = <a href="../../move-stdlib/doc/option.md#0x1_option_extract">option::extract</a>(&<b>mut</b> maybe_idx);
    &<b>mut</b> <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow_mut">vector::borrow_mut</a>(&<b>mut</b> map.data, idx).value
}
</code></pre>



</details>

<a id="0x1_simple_map_contains_key"></a>

## Function `contains_key`



<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_contains_key">contains_key</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_contains_key">contains_key</a>&lt;Key: store, Value: store&gt;(
    map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    key: &Key,
): bool {
    <b>let</b> maybe_idx = <a href="simple_map.md#0x1_simple_map_find">find</a>(map, key);
    <a href="../../move-stdlib/doc/option.md#0x1_option_is_some">option::is_some</a>(&maybe_idx)
}
</code></pre>



</details>

<a id="0x1_simple_map_destroy_empty"></a>

## Function `destroy_empty`



<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_destroy_empty">destroy_empty</a>&lt;Key: store, Value: store&gt;(map: <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_destroy_empty">destroy_empty</a>&lt;Key: store, Value: store&gt;(map: <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;) {
    <b>let</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a> { data } = map;
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_destroy_empty">vector::destroy_empty</a>(data);
}
</code></pre>



</details>

<a id="0x1_simple_map_add"></a>

## Function `add`

Add a key/value pair to the map. The key must not already exist.


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_add">add</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: Key, value: Value)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_add">add</a>&lt;Key: store, Value: store&gt;(
    map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    key: Key,
    value: Value,
) {
    <b>let</b> maybe_idx = <a href="simple_map.md#0x1_simple_map_find">find</a>(map, &key);
    <b>assert</b>!(<a href="../../move-stdlib/doc/option.md#0x1_option_is_none">option::is_none</a>(&maybe_idx), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="simple_map.md#0x1_simple_map_EKEY_ALREADY_EXISTS">EKEY_ALREADY_EXISTS</a>));

    <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> map.data, <a href="simple_map.md#0x1_simple_map_Element">Element</a> { key, value });
}
</code></pre>



</details>

<a id="0x1_simple_map_add_all"></a>

## Function `add_all`

Add multiple key/value pairs to the map. The keys must not already exist.


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_add_all">add_all</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, keys: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;, values: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_add_all">add_all</a>&lt;Key: store, Value: store&gt;(
    map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    keys: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;,
    values: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;,
) {
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_zip">vector::zip</a>(keys, values, |key, value| {
        <a href="simple_map.md#0x1_simple_map_add">add</a>(map, key, value);
    });
}
</code></pre>



</details>

<a id="0x1_simple_map_upsert"></a>

## Function `upsert`

Insert key/value pair or update an existing key to a new value


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_upsert">upsert</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: Key, value: Value): (<a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;Key&gt;, <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;Value&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_upsert">upsert</a>&lt;Key: store, Value: store&gt;(
    map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    key: Key,
    value: Value
): (std::option::Option&lt;Key&gt;, std::option::Option&lt;Value&gt;) {
    <b>let</b> data = &<b>mut</b> map.data;
    <b>let</b> len = <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(data);
    <b>let</b> i = 0;
    <b>while</b> (i &lt; len) {
        <b>let</b> element = <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(data, i);
        <b>if</b> (&element.key == &key) {
            <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(data, <a href="simple_map.md#0x1_simple_map_Element">Element</a> { key, value });
            <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap">vector::swap</a>(data, i, len);
            <b>let</b> <a href="simple_map.md#0x1_simple_map_Element">Element</a> { key, value } = <a href="../../move-stdlib/doc/vector.md#0x1_vector_pop_back">vector::pop_back</a>(data);
            <b>return</b> (std::option::some(key), std::option::some(value))
        };
        i = i + 1;
    };
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> map.data, <a href="simple_map.md#0x1_simple_map_Element">Element</a> { key, value });
    (std::option::none(), std::option::none())
}
</code></pre>



</details>

<a id="0x1_simple_map_keys"></a>

## Function `keys`

Return all keys in the map. This requires keys to be copyable.


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_keys">keys</a>&lt;Key: <b>copy</b>, Value&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_keys">keys</a>&lt;Key: <b>copy</b>, Value&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt; {
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_map_ref">vector::map_ref</a>(&map.data, |e| {
        <b>let</b> e: &<a href="simple_map.md#0x1_simple_map_Element">Element</a>&lt;Key, Value&gt; = e;
        e.key
    })
}
</code></pre>



</details>

<a id="0x1_simple_map_values"></a>

## Function `values`

Return all values in the map. This requires values to be copyable.


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_values">values</a>&lt;Key, Value: <b>copy</b>&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_values">values</a>&lt;Key, Value: <b>copy</b>&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt; {
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_map_ref">vector::map_ref</a>(&map.data, |e| {
        <b>let</b> e: &<a href="simple_map.md#0x1_simple_map_Element">Element</a>&lt;Key, Value&gt; = e;
        e.value
    })
}
</code></pre>



</details>

<a id="0x1_simple_map_to_vec_pair"></a>

## Function `to_vec_pair`

Transform the map into two vectors with the keys and values respectively
Primarily used to destroy a map


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_to_vec_pair">to_vec_pair</a>&lt;Key: store, Value: store&gt;(map: <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;): (<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;, <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_to_vec_pair">to_vec_pair</a>&lt;Key: store, Value: store&gt;(
    map: <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;): (<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;, <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;) {
    <b>let</b> keys: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt; = <a href="../../move-stdlib/doc/vector.md#0x1_vector_empty">vector::empty</a>();
    <b>let</b> values: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt; = <a href="../../move-stdlib/doc/vector.md#0x1_vector_empty">vector::empty</a>();
    <b>let</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a> { data } = map;
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_for_each">vector::for_each</a>(data, |e| {
        <b>let</b> <a href="simple_map.md#0x1_simple_map_Element">Element</a> { key, value } = e;
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> keys, key);
        <a href="../../move-stdlib/doc/vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> values, value);
    });
    (keys, values)
}
</code></pre>



</details>

<a id="0x1_simple_map_destroy"></a>

## Function `destroy`

For maps that cannot be dropped this is a utility to destroy them
using lambdas to destroy the individual keys and values.


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_destroy">destroy</a>&lt;Key: store, Value: store&gt;(map: <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, dk: |Key|, dv: |Value|)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="simple_map.md#0x1_simple_map_destroy">destroy</a>&lt;Key: store, Value: store&gt;(
    map: <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    dk: |Key|,
    dv: |Value|
) {
    <b>let</b> (keys, values) = <a href="simple_map.md#0x1_simple_map_to_vec_pair">to_vec_pair</a>(map);
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_destroy">vector::destroy</a>(keys, |_k| dk(_k));
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_destroy">vector::destroy</a>(values, |_v| dv(_v));
}
</code></pre>



</details>

<a id="0x1_simple_map_remove"></a>

## Function `remove`

Remove a key/value pair from the map. The key must exist.


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_remove">remove</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): (Key, Value)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_remove">remove</a>&lt;Key: store, Value: store&gt;(
    map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    key: &Key,
): (Key, Value) {
    <b>let</b> maybe_idx = <a href="simple_map.md#0x1_simple_map_find">find</a>(map, key);
    <b>assert</b>!(<a href="../../move-stdlib/doc/option.md#0x1_option_is_some">option::is_some</a>(&maybe_idx), <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="simple_map.md#0x1_simple_map_EKEY_NOT_FOUND">EKEY_NOT_FOUND</a>));
    <b>let</b> placement = <a href="../../move-stdlib/doc/option.md#0x1_option_extract">option::extract</a>(&<b>mut</b> maybe_idx);
    <b>let</b> <a href="simple_map.md#0x1_simple_map_Element">Element</a> { key, value } = <a href="../../move-stdlib/doc/vector.md#0x1_vector_swap_remove">vector::swap_remove</a>(&<b>mut</b> map.data, placement);
    (key, value)
}
</code></pre>



</details>

<a id="0x1_simple_map_find"></a>

## Function `find`



<pre><code><b>fun</b> <a href="simple_map.md#0x1_simple_map_find">find</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="simple_map.md#0x1_simple_map_find">find</a>&lt;Key: store, Value: store&gt;(
    map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt;,
    key: &Key,
): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;u64&gt; {
    <b>let</b> leng = <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&map.data);
    <b>let</b> i = 0;
    <b>while</b> (i &lt; leng) {
        <b>let</b> element = <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(&map.data, i);
        <b>if</b> (&element.key == key) {
            <b>return</b> <a href="../../move-stdlib/doc/option.md#0x1_option_some">option::some</a>(i)
        };
        i = i + 1;
    };
    <a href="../../move-stdlib/doc/option.md#0x1_option_none">option::none</a>&lt;u64&gt;()
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_SimpleMap"></a>

### Struct `SimpleMap`


<pre><code><b>struct</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;Key, Value&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<dl>
<dt>
<code>data: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;<a href="simple_map.md#0x1_simple_map_Element">simple_map::Element</a>&lt;Key, Value&gt;&gt;</code>
</dt>
<dd>

</dd>
</dl>



<pre><code><b>pragma</b> intrinsic = map,
    map_new = create,
    map_len = length,
    map_destroy_empty = destroy_empty,
    map_has_key = contains_key,
    map_add_no_override = add,
    map_del_return_key = remove,
    map_borrow = borrow,
    map_borrow_mut = borrow_mut,
    map_spec_get = spec_get,
    map_spec_set = spec_set,
    map_spec_del = spec_remove,
    map_spec_len = spec_len,
    map_spec_has_key = spec_contains_key;
</code></pre>



<a id="@Specification_1_length"></a>

### Function `length`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_length">length</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;): u64
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_new"></a>

### Function `new`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_new">new</a>&lt;Key: store, Value: store&gt;(): <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;
</code></pre>




<pre><code><b>pragma</b> intrinsic;
<b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] <a href="simple_map.md#0x1_simple_map_spec_len">spec_len</a>(result) == 0;
<b>ensures</b> [abstract] <b>forall</b> k: Key: !<a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>(result, k);
</code></pre>



<a id="@Specification_1_new_from"></a>

### Function `new_from`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_new_from">new_from</a>&lt;Key: store, Value: store&gt;(keys: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;, values: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;): <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;
</code></pre>




<pre><code><b>pragma</b> intrinsic;
<b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] <a href="simple_map.md#0x1_simple_map_spec_len">spec_len</a>(result) == len(keys);
<b>ensures</b> [abstract] <b>forall</b> k: Key: <a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>(result, k) &lt;==&gt; <a href="../../move-stdlib/doc/vector.md#0x1_vector_spec_contains">vector::spec_contains</a>(keys, k);
<b>ensures</b> [abstract] <b>forall</b> i in 0..len(keys):
    <a href="simple_map.md#0x1_simple_map_spec_get">spec_get</a>(result, <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(keys, i)) == <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(values, i);
</code></pre>



<a id="@Specification_1_create"></a>

### Function `create`


<pre><code>#[deprecated]
<b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_create">create</a>&lt;Key: store, Value: store&gt;(): <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_borrow"></a>

### Function `borrow`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_borrow">borrow</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): &Value
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_borrow_mut"></a>

### Function `borrow_mut`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_borrow_mut">borrow_mut</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): &<b>mut</b> Value
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_contains_key"></a>

### Function `contains_key`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_contains_key">contains_key</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): bool
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_destroy_empty"></a>

### Function `destroy_empty`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_destroy_empty">destroy_empty</a>&lt;Key: store, Value: store&gt;(map: <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_add"></a>

### Function `add`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_add">add</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: Key, value: Value)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_add_all"></a>

### Function `add_all`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_add_all">add_all</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, keys: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;, values: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_upsert"></a>

### Function `upsert`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_upsert">upsert</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: Key, value: Value): (<a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;Key&gt;, <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;Value&gt;)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
<b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] !<a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>(<b>old</b>(map), key) ==&gt; <a href="../../move-stdlib/doc/option.md#0x1_option_is_none">option::is_none</a>(result_1);
<b>ensures</b> [abstract] !<a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>(<b>old</b>(map), key) ==&gt; <a href="../../move-stdlib/doc/option.md#0x1_option_is_none">option::is_none</a>(result_2);
<b>ensures</b> [abstract] <a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>(map, key);
<b>ensures</b> [abstract] <a href="simple_map.md#0x1_simple_map_spec_get">spec_get</a>(map, key) == value;
<b>ensures</b> [abstract] <a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>(<b>old</b>(map), key) ==&gt; ((<a href="../../move-stdlib/doc/option.md#0x1_option_is_some">option::is_some</a>(result_1)) && (<a href="../../move-stdlib/doc/option.md#0x1_option_spec_borrow">option::spec_borrow</a>(result_1) == key));
<b>ensures</b> [abstract] <a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>(<b>old</b>(map), key) ==&gt; ((<a href="../../move-stdlib/doc/option.md#0x1_option_is_some">option::is_some</a>(result_2)) && (<a href="../../move-stdlib/doc/option.md#0x1_option_spec_borrow">option::spec_borrow</a>(result_2) == <a href="simple_map.md#0x1_simple_map_spec_get">spec_get</a>(<b>old</b>(map), key)));
</code></pre>




<a id="0x1_simple_map_spec_len"></a>


<pre><code><b>native</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_spec_len">spec_len</a>&lt;K, V&gt;(t: <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;K, V&gt;): num;
</code></pre>




<a id="0x1_simple_map_spec_contains_key"></a>


<pre><code><b>native</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>&lt;K, V&gt;(t: <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;K, V&gt;, k: K): bool;
</code></pre>




<a id="0x1_simple_map_spec_set"></a>


<pre><code><b>native</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_spec_set">spec_set</a>&lt;K, V&gt;(t: <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;K, V&gt;, k: K, v: V): <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;K, V&gt;;
</code></pre>




<a id="0x1_simple_map_spec_remove"></a>


<pre><code><b>native</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_spec_remove">spec_remove</a>&lt;K, V&gt;(t: <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;K, V&gt;, k: K): <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;K, V&gt;;
</code></pre>




<a id="0x1_simple_map_spec_get"></a>


<pre><code><b>native</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_spec_get">spec_get</a>&lt;K, V&gt;(t: <a href="simple_map.md#0x1_simple_map_SimpleMap">SimpleMap</a>&lt;K, V&gt;, k: K): V;
</code></pre>



<a id="@Specification_1_keys"></a>

### Function `keys`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_keys">keys</a>&lt;Key: <b>copy</b>, Value&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;
</code></pre>




<pre><code><b>pragma</b> verify=<b>false</b>;
</code></pre>



<a id="@Specification_1_values"></a>

### Function `values`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_values">values</a>&lt;Key, Value: <b>copy</b>&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;
</code></pre>




<pre><code><b>pragma</b> verify=<b>false</b>;
</code></pre>



<a id="@Specification_1_to_vec_pair"></a>

### Function `to_vec_pair`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_to_vec_pair">to_vec_pair</a>&lt;Key: store, Value: store&gt;(map: <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;): (<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Key&gt;, <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;Value&gt;)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
<b>pragma</b> opaque;
<b>ensures</b> [abstract]
    <b>forall</b> k: Key: <a href="../../move-stdlib/doc/vector.md#0x1_vector_spec_contains">vector::spec_contains</a>(result_1, k) &lt;==&gt;
        <a href="simple_map.md#0x1_simple_map_spec_contains_key">spec_contains_key</a>(map, k);
<b>ensures</b> [abstract] <b>forall</b> i in 0..len(result_1):
    <a href="simple_map.md#0x1_simple_map_spec_get">spec_get</a>(map, <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(result_1, i)) == <a href="../../move-stdlib/doc/vector.md#0x1_vector_borrow">vector::borrow</a>(result_2, i);
</code></pre>



<a id="@Specification_1_remove"></a>

### Function `remove`


<pre><code><b>public</b> <b>fun</b> <a href="simple_map.md#0x1_simple_map_remove">remove</a>&lt;Key: store, Value: store&gt;(map: &<b>mut</b> <a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): (Key, Value)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_find"></a>

### Function `find`


<pre><code><b>fun</b> <a href="simple_map.md#0x1_simple_map_find">find</a>&lt;Key: store, Value: store&gt;(map: &<a href="simple_map.md#0x1_simple_map_SimpleMap">simple_map::SimpleMap</a>&lt;Key, Value&gt;, key: &Key): <a href="../../move-stdlib/doc/option.md#0x1_option_Option">option::Option</a>&lt;u64&gt;
</code></pre>




<pre><code><b>pragma</b> verify=<b>false</b>;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/string_utils.md
================================================

<a id="0x1_string_utils"></a>

# Module `0x1::string_utils`

A module for formatting move values as strings.


-  [Struct `Cons`](#0x1_string_utils_Cons)
-  [Struct `NIL`](#0x1_string_utils_NIL)
-  [Struct `FakeCons`](#0x1_string_utils_FakeCons)
    -  [[test_only]](#@[test_only]_0)
-  [Constants](#@Constants_1)
-  [Function `to_string`](#0x1_string_utils_to_string)
-  [Function `to_string_with_canonical_addresses`](#0x1_string_utils_to_string_with_canonical_addresses)
-  [Function `to_string_with_integer_types`](#0x1_string_utils_to_string_with_integer_types)
-  [Function `debug_string`](#0x1_string_utils_debug_string)
-  [Function `format1`](#0x1_string_utils_format1)
-  [Function `format2`](#0x1_string_utils_format2)
-  [Function `format3`](#0x1_string_utils_format3)
-  [Function `format4`](#0x1_string_utils_format4)
-  [Function `cons`](#0x1_string_utils_cons)
-  [Function `nil`](#0x1_string_utils_nil)
-  [Function `list1`](#0x1_string_utils_list1)
-  [Function `list2`](#0x1_string_utils_list2)
-  [Function `list3`](#0x1_string_utils_list3)
-  [Function `list4`](#0x1_string_utils_list4)
-  [Function `native_format`](#0x1_string_utils_native_format)
-  [Function `native_format_list`](#0x1_string_utils_native_format_list)
-  [Specification](#@Specification_2)
    -  [Function `to_string`](#@Specification_2_to_string)
    -  [Function `to_string_with_canonical_addresses`](#@Specification_2_to_string_with_canonical_addresses)
    -  [Function `to_string_with_integer_types`](#@Specification_2_to_string_with_integer_types)
    -  [Function `debug_string`](#@Specification_2_debug_string)
    -  [Function `format1`](#@Specification_2_format1)
    -  [Function `format2`](#@Specification_2_format2)
    -  [Function `format3`](#@Specification_2_format3)
    -  [Function `format4`](#@Specification_2_format4)
    -  [Function `native_format`](#@Specification_2_native_format)
    -  [Function `native_format_list`](#@Specification_2_native_format_list)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/string.md#0x1_string">0x1::string</a>;
</code></pre>



<a id="0x1_string_utils_Cons"></a>

## Struct `Cons`



<pre><code><b>struct</b> <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T, N&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>car: T</code>
</dt>
<dd>

</dd>
<dt>
<code>cdr: N</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_string_utils_NIL"></a>

## Struct `NIL`



<pre><code><b>struct</b> <a href="string_utils.md#0x1_string_utils_NIL">NIL</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>dummy_field: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_string_utils_FakeCons"></a>

## Struct `FakeCons`


<a id="@[test_only]_0"></a>

### [test_only]



<pre><code><b>struct</b> <a href="string_utils.md#0x1_string_utils_FakeCons">FakeCons</a>&lt;T, N&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>car: T</code>
</dt>
<dd>

</dd>
<dt>
<code>cdr: N</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_1"></a>

## Constants


<a id="0x1_string_utils_EARGS_MISMATCH"></a>

The number of values in the list does not match the number of "{}" in the format string.


<pre><code><b>const</b> <a href="string_utils.md#0x1_string_utils_EARGS_MISMATCH">EARGS_MISMATCH</a>: u64 = 1;
</code></pre>



<a id="0x1_string_utils_EINVALID_FORMAT"></a>

The format string is not valid.


<pre><code><b>const</b> <a href="string_utils.md#0x1_string_utils_EINVALID_FORMAT">EINVALID_FORMAT</a>: u64 = 2;
</code></pre>



<a id="0x1_string_utils_EUNABLE_TO_FORMAT_DELAYED_FIELD"></a>

Formatting is not possible because the value contains delayed fields such as aggregators.


<pre><code><b>const</b> <a href="string_utils.md#0x1_string_utils_EUNABLE_TO_FORMAT_DELAYED_FIELD">EUNABLE_TO_FORMAT_DELAYED_FIELD</a>: u64 = 3;
</code></pre>



<a id="0x1_string_utils_to_string"></a>

## Function `to_string`

Format a move value as a human readable string,
eg. <code><a href="string_utils.md#0x1_string_utils_to_string">to_string</a>(&1u64) == "1"</code>, <code><a href="string_utils.md#0x1_string_utils_to_string">to_string</a>(&<b>false</b>) == "<b>false</b>"</code>, <code><a href="string_utils.md#0x1_string_utils_to_string">to_string</a>(&@0x1) == "@0x1"</code>.
For vectors and structs the format is similar to rust, eg.
<code><a href="string_utils.md#0x1_string_utils_to_string">to_string</a>(&<a href="string_utils.md#0x1_string_utils_cons">cons</a>(1,2)) == "<a href="string_utils.md#0x1_string_utils_Cons">Cons</a> { car: 1, cdr: 2 }"</code> and <code><a href="string_utils.md#0x1_string_utils_to_string">to_string</a>(&<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>[1, 2, 3]) == "[ 1, 2, 3 ]"</code>
For vectors of u8 the output is hex encoded, eg. <code><a href="string_utils.md#0x1_string_utils_to_string">to_string</a>(&<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>[1u8, 2u8, 3u8]) == "0x010203"</code>
For std::string::String the output is the string itself including quotes, eg.
<code><a href="string_utils.md#0x1_string_utils_to_string">to_string</a>(&std::string::utf8(b"My <a href="../../move-stdlib/doc/string.md#0x1_string">string</a>")) == "\"My <a href="../../move-stdlib/doc/string.md#0x1_string">string</a>\""</code>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string">to_string</a>&lt;T&gt;(s: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string">to_string</a>&lt;T&gt;(s: &T): String {
    <a href="string_utils.md#0x1_string_utils_native_format">native_format</a>(s, <b>false</b>, <b>false</b>, <b>true</b>, <b>false</b>)
}
</code></pre>



</details>

<a id="0x1_string_utils_to_string_with_canonical_addresses"></a>

## Function `to_string_with_canonical_addresses`

Format addresses as 64 zero-padded hexadecimals.


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string_with_canonical_addresses">to_string_with_canonical_addresses</a>&lt;T&gt;(s: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string_with_canonical_addresses">to_string_with_canonical_addresses</a>&lt;T&gt;(s: &T): String {
    <a href="string_utils.md#0x1_string_utils_native_format">native_format</a>(s, <b>false</b>, <b>true</b>, <b>true</b>, <b>false</b>)
}
</code></pre>



</details>

<a id="0x1_string_utils_to_string_with_integer_types"></a>

## Function `to_string_with_integer_types`

Format emitting integers with types ie. 6u8 or 128u32.


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string_with_integer_types">to_string_with_integer_types</a>&lt;T&gt;(s: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string_with_integer_types">to_string_with_integer_types</a>&lt;T&gt;(s: &T): String {
    <a href="string_utils.md#0x1_string_utils_native_format">native_format</a>(s, <b>false</b>, <b>true</b>, <b>true</b>, <b>false</b>)
}
</code></pre>



</details>

<a id="0x1_string_utils_debug_string"></a>

## Function `debug_string`

Format vectors and structs with newlines and indentation.


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_debug_string">debug_string</a>&lt;T&gt;(s: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_debug_string">debug_string</a>&lt;T&gt;(s: &T): String {
    <a href="string_utils.md#0x1_string_utils_native_format">native_format</a>(s, <b>true</b>, <b>false</b>, <b>false</b>, <b>false</b>)
}
</code></pre>



</details>

<a id="0x1_string_utils_format1"></a>

## Function `format1`

Formatting with a rust-like format string, eg. <code><a href="string_utils.md#0x1_string_utils_format2">format2</a>(&b"a = {}, b = {}", 1, 2) == "a = 1, b = 2"</code>.


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format1">format1</a>&lt;T0: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format1">format1</a>&lt;T0: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0): String {
    <a href="string_utils.md#0x1_string_utils_native_format_list">native_format_list</a>(fmt, &<a href="string_utils.md#0x1_string_utils_list1">list1</a>(a))
}
</code></pre>



</details>

<a id="0x1_string_utils_format2"></a>

## Function `format2`



<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format2">format2</a>&lt;T0: drop, T1: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format2">format2</a>&lt;T0: drop, T1: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1): String {
    <a href="string_utils.md#0x1_string_utils_native_format_list">native_format_list</a>(fmt, &<a href="string_utils.md#0x1_string_utils_list2">list2</a>(a, b))
}
</code></pre>



</details>

<a id="0x1_string_utils_format3"></a>

## Function `format3`



<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format3">format3</a>&lt;T0: drop, T1: drop, T2: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1, c: T2): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format3">format3</a>&lt;T0: drop, T1: drop, T2: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1, c: T2): String {
    <a href="string_utils.md#0x1_string_utils_native_format_list">native_format_list</a>(fmt, &<a href="string_utils.md#0x1_string_utils_list3">list3</a>(a, b, c))
}
</code></pre>



</details>

<a id="0x1_string_utils_format4"></a>

## Function `format4`



<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format4">format4</a>&lt;T0: drop, T1: drop, T2: drop, T3: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1, c: T2, d: T3): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format4">format4</a>&lt;T0: drop, T1: drop, T2: drop, T3: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1, c: T2, d: T3): String {
    <a href="string_utils.md#0x1_string_utils_native_format_list">native_format_list</a>(fmt, &<a href="string_utils.md#0x1_string_utils_list4">list4</a>(a, b, c, d))
}
</code></pre>



</details>

<a id="0x1_string_utils_cons"></a>

## Function `cons`



<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_cons">cons</a>&lt;T, N&gt;(car: T, cdr: N): <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T, N&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_cons">cons</a>&lt;T, N&gt;(car: T, cdr: N): <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T, N&gt; { <a href="string_utils.md#0x1_string_utils_Cons">Cons</a> { car, cdr } }
</code></pre>



</details>

<a id="0x1_string_utils_nil"></a>

## Function `nil`



<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_nil">nil</a>(): <a href="string_utils.md#0x1_string_utils_NIL">string_utils::NIL</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_nil">nil</a>(): <a href="string_utils.md#0x1_string_utils_NIL">NIL</a> { <a href="string_utils.md#0x1_string_utils_NIL">NIL</a> {} }
</code></pre>



</details>

<a id="0x1_string_utils_list1"></a>

## Function `list1`



<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_list1">list1</a>&lt;T0&gt;(a: T0): <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T0, <a href="string_utils.md#0x1_string_utils_NIL">string_utils::NIL</a>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="string_utils.md#0x1_string_utils_list1">list1</a>&lt;T0&gt;(a: T0): <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T0, <a href="string_utils.md#0x1_string_utils_NIL">NIL</a>&gt; { <a href="string_utils.md#0x1_string_utils_cons">cons</a>(a, <a href="string_utils.md#0x1_string_utils_nil">nil</a>()) }
</code></pre>



</details>

<a id="0x1_string_utils_list2"></a>

## Function `list2`



<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_list2">list2</a>&lt;T0, T1&gt;(a: T0, b: T1): <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T0, <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T1, <a href="string_utils.md#0x1_string_utils_NIL">string_utils::NIL</a>&gt;&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="string_utils.md#0x1_string_utils_list2">list2</a>&lt;T0, T1&gt;(a: T0, b: T1): <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T0, <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T1, <a href="string_utils.md#0x1_string_utils_NIL">NIL</a>&gt;&gt; { <a href="string_utils.md#0x1_string_utils_cons">cons</a>(a, <a href="string_utils.md#0x1_string_utils_list1">list1</a>(b)) }
</code></pre>



</details>

<a id="0x1_string_utils_list3"></a>

## Function `list3`



<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_list3">list3</a>&lt;T0, T1, T2&gt;(a: T0, b: T1, c: T2): <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T0, <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T1, <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T2, <a href="string_utils.md#0x1_string_utils_NIL">string_utils::NIL</a>&gt;&gt;&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="string_utils.md#0x1_string_utils_list3">list3</a>&lt;T0, T1, T2&gt;(a: T0, b: T1, c: T2): <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T0, <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T1, <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T2, <a href="string_utils.md#0x1_string_utils_NIL">NIL</a>&gt;&gt;&gt; { <a href="string_utils.md#0x1_string_utils_cons">cons</a>(a, <a href="string_utils.md#0x1_string_utils_list2">list2</a>(b, c)) }
</code></pre>



</details>

<a id="0x1_string_utils_list4"></a>

## Function `list4`



<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_list4">list4</a>&lt;T0, T1, T2, T3&gt;(a: T0, b: T1, c: T2, d: T3): <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T0, <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T1, <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T2, <a href="string_utils.md#0x1_string_utils_Cons">string_utils::Cons</a>&lt;T3, <a href="string_utils.md#0x1_string_utils_NIL">string_utils::NIL</a>&gt;&gt;&gt;&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="string_utils.md#0x1_string_utils_list4">list4</a>&lt;T0, T1, T2, T3&gt;(a: T0, b: T1, c: T2, d: T3): <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T0, <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T1, <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T2, <a href="string_utils.md#0x1_string_utils_Cons">Cons</a>&lt;T3, <a href="string_utils.md#0x1_string_utils_NIL">NIL</a>&gt;&gt;&gt;&gt; { <a href="string_utils.md#0x1_string_utils_cons">cons</a>(a, <a href="string_utils.md#0x1_string_utils_list3">list3</a>(b, c, d)) }
</code></pre>



</details>

<a id="0x1_string_utils_native_format"></a>

## Function `native_format`



<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_native_format">native_format</a>&lt;T&gt;(s: &T, type_tag: bool, canonicalize: bool, single_line: bool, include_int_types: bool): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_native_format">native_format</a>&lt;T&gt;(s: &T, type_tag: bool, canonicalize: bool, single_line: bool, include_int_types: bool): String;
</code></pre>



</details>

<a id="0x1_string_utils_native_format_list"></a>

## Function `native_format_list`



<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_native_format_list">native_format_list</a>&lt;T&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, val: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_native_format_list">native_format_list</a>&lt;T&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, val: &T): String;
</code></pre>



</details>

<a id="@Specification_2"></a>

## Specification


<a id="@Specification_2_to_string"></a>

### Function `to_string`


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string">to_string</a>&lt;T&gt;(s: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format">spec_native_format</a>(s, <b>false</b>, <b>false</b>, <b>true</b>, <b>false</b>);
</code></pre>



<a id="@Specification_2_to_string_with_canonical_addresses"></a>

### Function `to_string_with_canonical_addresses`


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string_with_canonical_addresses">to_string_with_canonical_addresses</a>&lt;T&gt;(s: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format">spec_native_format</a>(s, <b>false</b>, <b>true</b>, <b>true</b>, <b>false</b>);
</code></pre>



<a id="@Specification_2_to_string_with_integer_types"></a>

### Function `to_string_with_integer_types`


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_to_string_with_integer_types">to_string_with_integer_types</a>&lt;T&gt;(s: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format">spec_native_format</a>(s, <b>false</b>, <b>true</b>, <b>true</b>, <b>false</b>);
</code></pre>



<a id="@Specification_2_debug_string"></a>

### Function `debug_string`


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_debug_string">debug_string</a>&lt;T&gt;(s: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format">spec_native_format</a>(s, <b>true</b>, <b>false</b>, <b>false</b>, <b>false</b>);
</code></pre>



<a id="@Specification_2_format1"></a>

### Function `format1`


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format1">format1</a>&lt;T0: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <a href="string_utils.md#0x1_string_utils_args_mismatch_or_invalid_format">args_mismatch_or_invalid_format</a>(fmt, <a href="string_utils.md#0x1_string_utils_list1">list1</a>(a));
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format_list">spec_native_format_list</a>(fmt, <a href="string_utils.md#0x1_string_utils_list1">list1</a>(a));
</code></pre>



<a id="@Specification_2_format2"></a>

### Function `format2`


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format2">format2</a>&lt;T0: drop, T1: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <a href="string_utils.md#0x1_string_utils_args_mismatch_or_invalid_format">args_mismatch_or_invalid_format</a>(fmt, <a href="string_utils.md#0x1_string_utils_list2">list2</a>(a, b));
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format_list">spec_native_format_list</a>(fmt, <a href="string_utils.md#0x1_string_utils_list2">list2</a>(a, b));
</code></pre>



<a id="@Specification_2_format3"></a>

### Function `format3`


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format3">format3</a>&lt;T0: drop, T1: drop, T2: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1, c: T2): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <a href="string_utils.md#0x1_string_utils_args_mismatch_or_invalid_format">args_mismatch_or_invalid_format</a>(fmt, <a href="string_utils.md#0x1_string_utils_list3">list3</a>(a, b, c));
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format_list">spec_native_format_list</a>(fmt, <a href="string_utils.md#0x1_string_utils_list3">list3</a>(a, b, c));
</code></pre>



<a id="@Specification_2_format4"></a>

### Function `format4`


<pre><code><b>public</b> <b>fun</b> <a href="string_utils.md#0x1_string_utils_format4">format4</a>&lt;T0: drop, T1: drop, T2: drop, T3: drop&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, a: T0, b: T1, c: T2, d: T3): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>aborts_if</b> <a href="string_utils.md#0x1_string_utils_args_mismatch_or_invalid_format">args_mismatch_or_invalid_format</a>(fmt, <a href="string_utils.md#0x1_string_utils_list4">list4</a>(a, b, c, d));
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format_list">spec_native_format_list</a>(fmt, <a href="string_utils.md#0x1_string_utils_list4">list4</a>(a, b, c, d));
</code></pre>



<a id="@Specification_2_native_format"></a>

### Function `native_format`


<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_native_format">native_format</a>&lt;T&gt;(s: &T, type_tag: bool, canonicalize: bool, single_line: bool, include_int_types: bool): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format">spec_native_format</a>(s, type_tag, canonicalize, single_line, include_int_types);
</code></pre>



<a id="@Specification_2_native_format_list"></a>

### Function `native_format_list`


<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_native_format_list">native_format_list</a>&lt;T&gt;(fmt: &<a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, val: &T): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <a href="string_utils.md#0x1_string_utils_args_mismatch_or_invalid_format">args_mismatch_or_invalid_format</a>(fmt, val);
<b>ensures</b> result == <a href="string_utils.md#0x1_string_utils_spec_native_format_list">spec_native_format_list</a>(fmt, val);
</code></pre>




<a id="0x1_string_utils_spec_native_format"></a>


<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_spec_native_format">spec_native_format</a>&lt;T&gt;(s: T, type_tag: bool, canonicalize: bool, single_line: bool, include_int_types: bool): String;
</code></pre>




<a id="0x1_string_utils_spec_native_format_list"></a>


<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_spec_native_format_list">spec_native_format_list</a>&lt;T&gt;(fmt: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, val: T): String;
</code></pre>




<a id="0x1_string_utils_args_mismatch_or_invalid_format"></a>


<pre><code><b>fun</b> <a href="string_utils.md#0x1_string_utils_args_mismatch_or_invalid_format">args_mismatch_or_invalid_format</a>&lt;T&gt;(fmt: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;, val: T): bool;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/table.md
================================================

<a id="0x1_table"></a>

# Module `0x1::table`

Type of large-scale storage tables.
source: https://github.com/move-language/move/blob/1b6b7513dcc1a5c866f178ca5c1e74beb2ce181e/language/extensions/move-table-extension/sources/Table.move#L1

It implements the Table type which supports individual table items to be represented by
separate global state items. The number of items and a unique handle are tracked on the table
struct itself, while the operations are implemented as native functions. No traversal is provided.


-  [Struct `Table`](#0x1_table_Table)
-  [Resource `Box`](#0x1_table_Box)
-  [Function `new`](#0x1_table_new)
-  [Function `add`](#0x1_table_add)
-  [Function `borrow`](#0x1_table_borrow)
-  [Function `borrow_with_default`](#0x1_table_borrow_with_default)
-  [Function `borrow_mut`](#0x1_table_borrow_mut)
-  [Function `borrow_mut_with_default`](#0x1_table_borrow_mut_with_default)
-  [Function `upsert`](#0x1_table_upsert)
-  [Function `remove`](#0x1_table_remove)
-  [Function `contains`](#0x1_table_contains)
-  [Function `destroy`](#0x1_table_destroy)
-  [Function `new_table_handle`](#0x1_table_new_table_handle)
-  [Function `add_box`](#0x1_table_add_box)
-  [Function `borrow_box`](#0x1_table_borrow_box)
-  [Function `borrow_box_mut`](#0x1_table_borrow_box_mut)
-  [Function `contains_box`](#0x1_table_contains_box)
-  [Function `remove_box`](#0x1_table_remove_box)
-  [Function `destroy_empty_box`](#0x1_table_destroy_empty_box)
-  [Function `drop_unchecked_box`](#0x1_table_drop_unchecked_box)
-  [Specification](#@Specification_0)
    -  [Struct `Table`](#@Specification_0_Table)
    -  [Function `new`](#@Specification_0_new)
    -  [Function `add`](#@Specification_0_add)
    -  [Function `borrow`](#@Specification_0_borrow)
    -  [Function `borrow_mut`](#@Specification_0_borrow_mut)
    -  [Function `borrow_mut_with_default`](#@Specification_0_borrow_mut_with_default)
    -  [Function `upsert`](#@Specification_0_upsert)
    -  [Function `remove`](#@Specification_0_remove)
    -  [Function `contains`](#@Specification_0_contains)
    -  [Function `destroy`](#@Specification_0_destroy)


<pre><code></code></pre>



<a id="0x1_table_Table"></a>

## Struct `Table`

Type of tables


<pre><code><b>struct</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K: <b>copy</b>, drop, V&gt; <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>handle: <b>address</b></code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_table_Box"></a>

## Resource `Box`

Wrapper for values. Required for making values appear as resources in the implementation.


<pre><code><b>struct</b> <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt; <b>has</b> drop, store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>val: V</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="0x1_table_new"></a>

## Function `new`

Create a new Table.


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_new">new</a>&lt;K: <b>copy</b>, drop, V: store&gt;(): <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_new">new</a>&lt;K: <b>copy</b> + drop, V: store&gt;(): <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt; {
    <a href="table.md#0x1_table_Table">Table</a> {
        handle: <a href="table.md#0x1_table_new_table_handle">new_table_handle</a>&lt;K, V&gt;(),
    }
}
</code></pre>



</details>

<a id="0x1_table_add"></a>

## Function `add`

Add a new entry to the table. Aborts if an entry for this
key already exists. The entry itself is not stored in the
table, and cannot be discovered from it.


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_add">add</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K, val: V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_add">add</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K, val: V) {
    <a href="table.md#0x1_table_add_box">add_box</a>&lt;K, V, <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;&gt;(<a href="table.md#0x1_table">table</a>, key, <a href="table.md#0x1_table_Box">Box</a> { val })
}
</code></pre>



</details>

<a id="0x1_table_borrow"></a>

## Function `borrow`

Acquire an immutable reference to the value which <code>key</code> maps to.
Aborts if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow">borrow</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): &V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow">borrow</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K): &V {
    &<a href="table.md#0x1_table_borrow_box">borrow_box</a>&lt;K, V, <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;&gt;(<a href="table.md#0x1_table">table</a>, key).val
}
</code></pre>



</details>

<a id="0x1_table_borrow_with_default"></a>

## Function `borrow_with_default`

Acquire an immutable reference to the value which <code>key</code> maps to.
Returns specified default value if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow_with_default">borrow_with_default</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K, default: &V): &V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow_with_default">borrow_with_default</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K, default: &V): &V {
    <b>if</b> (!<a href="table.md#0x1_table_contains">contains</a>(<a href="table.md#0x1_table">table</a>, <b>copy</b> key)) {
        default
    } <b>else</b> {
        <a href="table.md#0x1_table_borrow">borrow</a>(<a href="table.md#0x1_table">table</a>, <b>copy</b> key)
    }
}
</code></pre>



</details>

<a id="0x1_table_borrow_mut"></a>

## Function `borrow_mut`

Acquire a mutable reference to the value which <code>key</code> maps to.
Aborts if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow_mut">borrow_mut</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): &<b>mut</b> V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow_mut">borrow_mut</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K): &<b>mut</b> V {
    &<b>mut</b> <a href="table.md#0x1_table_borrow_box_mut">borrow_box_mut</a>&lt;K, V, <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;&gt;(<a href="table.md#0x1_table">table</a>, key).val
}
</code></pre>



</details>

<a id="0x1_table_borrow_mut_with_default"></a>

## Function `borrow_mut_with_default`

Acquire a mutable reference to the value which <code>key</code> maps to.
Insert the pair (<code>key</code>, <code>default</code>) first if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow_mut_with_default">borrow_mut_with_default</a>&lt;K: <b>copy</b>, drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K, default: V): &<b>mut</b> V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow_mut_with_default">borrow_mut_with_default</a>&lt;K: <b>copy</b> + drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K, default: V): &<b>mut</b> V {
    <b>if</b> (!<a href="table.md#0x1_table_contains">contains</a>(<a href="table.md#0x1_table">table</a>, <b>copy</b> key)) {
        <a href="table.md#0x1_table_add">add</a>(<a href="table.md#0x1_table">table</a>, <b>copy</b> key, default)
    };
    <a href="table.md#0x1_table_borrow_mut">borrow_mut</a>(<a href="table.md#0x1_table">table</a>, key)
}
</code></pre>



</details>

<a id="0x1_table_upsert"></a>

## Function `upsert`

Insert the pair (<code>key</code>, <code>value</code>) if there is no entry for <code>key</code>.
update the value of the entry for <code>key</code> to <code>value</code> otherwise


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_upsert">upsert</a>&lt;K: <b>copy</b>, drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K, value: V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_upsert">upsert</a>&lt;K: <b>copy</b> + drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K, value: V) {
    <b>if</b> (!<a href="table.md#0x1_table_contains">contains</a>(<a href="table.md#0x1_table">table</a>, <b>copy</b> key)) {
        <a href="table.md#0x1_table_add">add</a>(<a href="table.md#0x1_table">table</a>, <b>copy</b> key, value)
    } <b>else</b> {
        <b>let</b> ref = <a href="table.md#0x1_table_borrow_mut">borrow_mut</a>(<a href="table.md#0x1_table">table</a>, key);
        *ref = value;
    };
}
</code></pre>



</details>

<a id="0x1_table_remove"></a>

## Function `remove`

Remove from <code><a href="table.md#0x1_table">table</a></code> and return the value which <code>key</code> maps to.
Aborts if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_remove">remove</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_remove">remove</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K): V {
    <b>let</b> <a href="table.md#0x1_table_Box">Box</a> { val } = <a href="table.md#0x1_table_remove_box">remove_box</a>&lt;K, V, <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;&gt;(<a href="table.md#0x1_table">table</a>, key);
    val
}
</code></pre>



</details>

<a id="0x1_table_contains"></a>

## Function `contains`

Returns true iff <code><a href="table.md#0x1_table">table</a></code> contains an entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_contains">contains</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_contains">contains</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K): bool {
    <a href="table.md#0x1_table_contains_box">contains_box</a>&lt;K, V, <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;&gt;(<a href="table.md#0x1_table">table</a>, key)
}
</code></pre>



</details>

<a id="0x1_table_destroy"></a>

## Function `destroy`



<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="table.md#0x1_table_destroy">destroy</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="table.md#0x1_table_destroy">destroy</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;) {
    <a href="table.md#0x1_table_destroy_empty_box">destroy_empty_box</a>&lt;K, V, <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;&gt;(&<a href="table.md#0x1_table">table</a>);
    <a href="table.md#0x1_table_drop_unchecked_box">drop_unchecked_box</a>&lt;K, V, <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;&gt;(<a href="table.md#0x1_table">table</a>)
}
</code></pre>



</details>

<a id="0x1_table_new_table_handle"></a>

## Function `new_table_handle`



<pre><code><b>fun</b> <a href="table.md#0x1_table_new_table_handle">new_table_handle</a>&lt;K, V&gt;(): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_new_table_handle">new_table_handle</a>&lt;K, V&gt;(): <b>address</b>;
</code></pre>



</details>

<a id="0x1_table_add_box"></a>

## Function `add_box`



<pre><code><b>fun</b> <a href="table.md#0x1_table_add_box">add_box</a>&lt;K: <b>copy</b>, drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K, val: <a href="table.md#0x1_table_Box">table::Box</a>&lt;V&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_add_box">add_box</a>&lt;K: <b>copy</b> + drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K, val: <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;);
</code></pre>



</details>

<a id="0x1_table_borrow_box"></a>

## Function `borrow_box`



<pre><code><b>fun</b> <a href="table.md#0x1_table_borrow_box">borrow_box</a>&lt;K: <b>copy</b>, drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): &<a href="table.md#0x1_table_Box">table::Box</a>&lt;V&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_borrow_box">borrow_box</a>&lt;K: <b>copy</b> + drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K): &<a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;;
</code></pre>



</details>

<a id="0x1_table_borrow_box_mut"></a>

## Function `borrow_box_mut`



<pre><code><b>fun</b> <a href="table.md#0x1_table_borrow_box_mut">borrow_box_mut</a>&lt;K: <b>copy</b>, drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): &<b>mut</b> <a href="table.md#0x1_table_Box">table::Box</a>&lt;V&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_borrow_box_mut">borrow_box_mut</a>&lt;K: <b>copy</b> + drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K): &<b>mut</b> <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;;
</code></pre>



</details>

<a id="0x1_table_contains_box"></a>

## Function `contains_box`



<pre><code><b>fun</b> <a href="table.md#0x1_table_contains_box">contains_box</a>&lt;K: <b>copy</b>, drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_contains_box">contains_box</a>&lt;K: <b>copy</b> + drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K): bool;
</code></pre>



</details>

<a id="0x1_table_remove_box"></a>

## Function `remove_box`



<pre><code><b>fun</b> <a href="table.md#0x1_table_remove_box">remove_box</a>&lt;K: <b>copy</b>, drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): <a href="table.md#0x1_table_Box">table::Box</a>&lt;V&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_remove_box">remove_box</a>&lt;K: <b>copy</b> + drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, key: K): <a href="table.md#0x1_table_Box">Box</a>&lt;V&gt;;
</code></pre>



</details>

<a id="0x1_table_destroy_empty_box"></a>

## Function `destroy_empty_box`



<pre><code><b>fun</b> <a href="table.md#0x1_table_destroy_empty_box">destroy_empty_box</a>&lt;K: <b>copy</b>, drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_destroy_empty_box">destroy_empty_box</a>&lt;K: <b>copy</b> + drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;);
</code></pre>



</details>

<a id="0x1_table_drop_unchecked_box"></a>

## Function `drop_unchecked_box`



<pre><code><b>fun</b> <a href="table.md#0x1_table_drop_unchecked_box">drop_unchecked_box</a>&lt;K: <b>copy</b>, drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_drop_unchecked_box">drop_unchecked_box</a>&lt;K: <b>copy</b> + drop, V, B&gt;(<a href="table.md#0x1_table">table</a>: <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;);
</code></pre>



</details>

<a id="@Specification_0"></a>

## Specification


<a id="@Specification_0_Table"></a>

### Struct `Table`


<pre><code><b>struct</b> <a href="table.md#0x1_table_Table">Table</a>&lt;K: <b>copy</b>, drop, V&gt; <b>has</b> store
</code></pre>



<dl>
<dt>
<code>handle: <b>address</b></code>
</dt>
<dd>

</dd>
</dl>



<pre><code><b>pragma</b> intrinsic = map,
    map_new = new,
    map_destroy_empty = destroy,
    map_has_key = contains,
    map_add_no_override = add,
    map_add_override_if_exists = upsert,
    map_del_must_exist = remove,
    map_borrow = borrow,
    map_borrow_mut = borrow_mut,
    map_borrow_mut_with_default = borrow_mut_with_default,
    map_spec_get = spec_get,
    map_spec_set = spec_set,
    map_spec_del = spec_remove,
    map_spec_has_key = spec_contains;
</code></pre>



<a id="@Specification_0_new"></a>

### Function `new`


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_new">new</a>&lt;K: <b>copy</b>, drop, V: store&gt;(): <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_0_add"></a>

### Function `add`


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_add">add</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K, val: V)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_0_borrow"></a>

### Function `borrow`


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow">borrow</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): &V
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_0_borrow_mut"></a>

### Function `borrow_mut`


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow_mut">borrow_mut</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): &<b>mut</b> V
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_0_borrow_mut_with_default"></a>

### Function `borrow_mut_with_default`


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_borrow_mut_with_default">borrow_mut_with_default</a>&lt;K: <b>copy</b>, drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K, default: V): &<b>mut</b> V
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_0_upsert"></a>

### Function `upsert`


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_upsert">upsert</a>&lt;K: <b>copy</b>, drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K, value: V)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_0_remove"></a>

### Function `remove`


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_remove">remove</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): V
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_0_contains"></a>

### Function `contains`


<pre><code><b>public</b> <b>fun</b> <a href="table.md#0x1_table_contains">contains</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;, key: K): bool
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>




<a id="0x1_table_spec_contains"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_spec_contains">spec_contains</a>&lt;K, V&gt;(t: <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, k: K): bool;
</code></pre>




<a id="0x1_table_spec_remove"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_spec_remove">spec_remove</a>&lt;K, V&gt;(t: <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, k: K): <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;;
</code></pre>




<a id="0x1_table_spec_set"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_spec_set">spec_set</a>&lt;K, V&gt;(t: <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, k: K, v: V): <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;;
</code></pre>




<a id="0x1_table_spec_get"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table.md#0x1_table_spec_get">spec_get</a>&lt;K, V&gt;(t: <a href="table.md#0x1_table_Table">Table</a>&lt;K, V&gt;, k: K): V;
</code></pre>



<a id="@Specification_0_destroy"></a>

### Function `destroy`


<pre><code><b>public</b>(<b>friend</b>) <b>fun</b> <a href="table.md#0x1_table_destroy">destroy</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/table_with_length.md
================================================

<a id="0x1_table_with_length"></a>

# Module `0x1::table_with_length`

Extends Table and provides functions such as length and the ability to be destroyed


-  [Struct `TableWithLength`](#0x1_table_with_length_TableWithLength)
-  [Constants](#@Constants_0)
-  [Function `new`](#0x1_table_with_length_new)
-  [Function `destroy_empty`](#0x1_table_with_length_destroy_empty)
-  [Function `add`](#0x1_table_with_length_add)
-  [Function `borrow`](#0x1_table_with_length_borrow)
-  [Function `borrow_mut`](#0x1_table_with_length_borrow_mut)
-  [Function `length`](#0x1_table_with_length_length)
-  [Function `empty`](#0x1_table_with_length_empty)
-  [Function `borrow_mut_with_default`](#0x1_table_with_length_borrow_mut_with_default)
-  [Function `upsert`](#0x1_table_with_length_upsert)
-  [Function `remove`](#0x1_table_with_length_remove)
-  [Function `contains`](#0x1_table_with_length_contains)
-  [Specification](#@Specification_1)
    -  [Struct `TableWithLength`](#@Specification_1_TableWithLength)
    -  [Function `new`](#@Specification_1_new)
    -  [Function `destroy_empty`](#@Specification_1_destroy_empty)
    -  [Function `add`](#@Specification_1_add)
    -  [Function `borrow`](#@Specification_1_borrow)
    -  [Function `borrow_mut`](#@Specification_1_borrow_mut)
    -  [Function `length`](#@Specification_1_length)
    -  [Function `empty`](#@Specification_1_empty)
    -  [Function `borrow_mut_with_default`](#@Specification_1_borrow_mut_with_default)
    -  [Function `upsert`](#@Specification_1_upsert)
    -  [Function `remove`](#@Specification_1_remove)
    -  [Function `contains`](#@Specification_1_contains)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="table.md#0x1_table">0x1::table</a>;
</code></pre>



<a id="0x1_table_with_length_TableWithLength"></a>

## Struct `TableWithLength`

Type of tables


<pre><code><b>struct</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K: <b>copy</b>, drop, V&gt; <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>inner: <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>length: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_table_with_length_EALREADY_EXISTS"></a>



<pre><code><b>const</b> <a href="table_with_length.md#0x1_table_with_length_EALREADY_EXISTS">EALREADY_EXISTS</a>: u64 = 100;
</code></pre>



<a id="0x1_table_with_length_ENOT_EMPTY"></a>



<pre><code><b>const</b> <a href="table_with_length.md#0x1_table_with_length_ENOT_EMPTY">ENOT_EMPTY</a>: u64 = 102;
</code></pre>



<a id="0x1_table_with_length_ENOT_FOUND"></a>



<pre><code><b>const</b> <a href="table_with_length.md#0x1_table_with_length_ENOT_FOUND">ENOT_FOUND</a>: u64 = 101;
</code></pre>



<a id="0x1_table_with_length_new"></a>

## Function `new`

Create a new Table.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_new">new</a>&lt;K: <b>copy</b>, drop, V: store&gt;(): <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_new">new</a>&lt;K: <b>copy</b> + drop, V: store&gt;(): <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt; {
    <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a> {
        inner: <a href="table.md#0x1_table_new">table::new</a>&lt;K, V&gt;(),
        length: 0,
    }
}
</code></pre>



</details>

<a id="0x1_table_with_length_destroy_empty"></a>

## Function `destroy_empty`

Destroy a table. The table must be empty to succeed.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_destroy_empty">destroy_empty</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_destroy_empty">destroy_empty</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;) {
    <b>assert</b>!(<a href="table.md#0x1_table">table</a>.length == 0, <a href="../../move-stdlib/doc/error.md#0x1_error_invalid_state">error::invalid_state</a>(<a href="table_with_length.md#0x1_table_with_length_ENOT_EMPTY">ENOT_EMPTY</a>));
    <b>let</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a> { inner, length: _ } = <a href="table.md#0x1_table">table</a>;
    <a href="table.md#0x1_table_destroy">table::destroy</a>(inner)
}
</code></pre>



</details>

<a id="0x1_table_with_length_add"></a>

## Function `add`

Add a new entry to the table. Aborts if an entry for this
key already exists. The entry itself is not stored in the
table, and cannot be discovered from it.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_add">add</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K, val: V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_add">add</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, key: K, val: V) {
    <a href="table.md#0x1_table_add">table::add</a>(&<b>mut</b> <a href="table.md#0x1_table">table</a>.inner, key, val);
    <a href="table.md#0x1_table">table</a>.length = <a href="table.md#0x1_table">table</a>.length + 1;
}
</code></pre>



</details>

<a id="0x1_table_with_length_borrow"></a>

## Function `borrow`

Acquire an immutable reference to the value which <code>key</code> maps to.
Aborts if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow">borrow</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K): &V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow">borrow</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, key: K): &V {
    <a href="table.md#0x1_table_borrow">table::borrow</a>(&<a href="table.md#0x1_table">table</a>.inner, key)
}
</code></pre>



</details>

<a id="0x1_table_with_length_borrow_mut"></a>

## Function `borrow_mut`

Acquire a mutable reference to the value which <code>key</code> maps to.
Aborts if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow_mut">borrow_mut</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K): &<b>mut</b> V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow_mut">borrow_mut</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, key: K): &<b>mut</b> V {
    <a href="table.md#0x1_table_borrow_mut">table::borrow_mut</a>(&<b>mut</b> <a href="table.md#0x1_table">table</a>.inner, key)
}
</code></pre>



</details>

<a id="0x1_table_with_length_length"></a>

## Function `length`

Returns the length of the table, i.e. the number of entries.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_length">length</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_length">length</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;): u64 {
    <a href="table.md#0x1_table">table</a>.length
}
</code></pre>



</details>

<a id="0x1_table_with_length_empty"></a>

## Function `empty`

Returns true if this table is empty.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_empty">empty</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_empty">empty</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;): bool {
    <a href="table.md#0x1_table">table</a>.length == 0
}
</code></pre>



</details>

<a id="0x1_table_with_length_borrow_mut_with_default"></a>

## Function `borrow_mut_with_default`

Acquire a mutable reference to the value which <code>key</code> maps to.
Insert the pair (<code>key</code>, <code>default</code>) first if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow_mut_with_default">borrow_mut_with_default</a>&lt;K: <b>copy</b>, drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K, default: V): &<b>mut</b> V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow_mut_with_default">borrow_mut_with_default</a>&lt;K: <b>copy</b> + drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, key: K, default: V): &<b>mut</b> V {
    <b>if</b> (<a href="table.md#0x1_table_contains">table::contains</a>(&<a href="table.md#0x1_table">table</a>.inner, key)) {
        <a href="table.md#0x1_table_borrow_mut">table::borrow_mut</a>(&<b>mut</b> <a href="table.md#0x1_table">table</a>.inner, key)
    } <b>else</b> {
        <a href="table.md#0x1_table_add">table::add</a>(&<b>mut</b> <a href="table.md#0x1_table">table</a>.inner, key, default);
        <a href="table.md#0x1_table">table</a>.length = <a href="table.md#0x1_table">table</a>.length + 1;
        <a href="table.md#0x1_table_borrow_mut">table::borrow_mut</a>(&<b>mut</b> <a href="table.md#0x1_table">table</a>.inner, key)
    }
}
</code></pre>



</details>

<a id="0x1_table_with_length_upsert"></a>

## Function `upsert`

Insert the pair (<code>key</code>, <code>value</code>) if there is no entry for <code>key</code>.
update the value of the entry for <code>key</code> to <code>value</code> otherwise


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_upsert">upsert</a>&lt;K: <b>copy</b>, drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K, value: V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_upsert">upsert</a>&lt;K: <b>copy</b> + drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, key: K, value: V) {
    <b>if</b> (!<a href="table.md#0x1_table_contains">table::contains</a>(&<a href="table.md#0x1_table">table</a>.inner, key)) {
        <a href="table_with_length.md#0x1_table_with_length_add">add</a>(<a href="table.md#0x1_table">table</a>, <b>copy</b> key, value)
    } <b>else</b> {
        <b>let</b> ref = <a href="table.md#0x1_table_borrow_mut">table::borrow_mut</a>(&<b>mut</b> <a href="table.md#0x1_table">table</a>.inner, key);
        *ref = value;
    };
}
</code></pre>



</details>

<a id="0x1_table_with_length_remove"></a>

## Function `remove`

Remove from <code><a href="table.md#0x1_table">table</a></code> and return the value which <code>key</code> maps to.
Aborts if there is no entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_remove">remove</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K): V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_remove">remove</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, key: K): V {
    <b>let</b> val = <a href="table.md#0x1_table_remove">table::remove</a>(&<b>mut</b> <a href="table.md#0x1_table">table</a>.inner, key);
    <a href="table.md#0x1_table">table</a>.length = <a href="table.md#0x1_table">table</a>.length - 1;
    val
}
</code></pre>



</details>

<a id="0x1_table_with_length_contains"></a>

## Function `contains`

Returns true iff <code><a href="table.md#0x1_table">table</a></code> contains an entry for <code>key</code>.


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_contains">contains</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_contains">contains</a>&lt;K: <b>copy</b> + drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, key: K): bool {
    <a href="table.md#0x1_table_contains">table::contains</a>(&<a href="table.md#0x1_table">table</a>.inner, key)
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_TableWithLength"></a>

### Struct `TableWithLength`


<pre><code><b>struct</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K: <b>copy</b>, drop, V&gt; <b>has</b> store
</code></pre>



<dl>
<dt>
<code>inner: <a href="table.md#0x1_table_Table">table::Table</a>&lt;K, V&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>length: u64</code>
</dt>
<dd>

</dd>
</dl>



<pre><code><b>pragma</b> intrinsic = map,
    map_new = new,
    map_destroy_empty = destroy_empty,
    map_len = length,
    map_is_empty = empty,
    map_has_key = contains,
    map_add_no_override = add,
    map_add_override_if_exists = upsert,
    map_del_must_exist = remove,
    map_borrow = borrow,
    map_borrow_mut = borrow_mut,
    map_borrow_mut_with_default = borrow_mut_with_default,
    map_spec_get = spec_get,
    map_spec_set = spec_set,
    map_spec_del = spec_remove,
    map_spec_len = spec_len,
    map_spec_has_key = spec_contains;
</code></pre>



<a id="@Specification_1_new"></a>

### Function `new`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_new">new</a>&lt;K: <b>copy</b>, drop, V: store&gt;(): <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_destroy_empty"></a>

### Function `destroy_empty`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_destroy_empty">destroy_empty</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_add"></a>

### Function `add`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_add">add</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K, val: V)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_borrow"></a>

### Function `borrow`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow">borrow</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K): &V
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_borrow_mut"></a>

### Function `borrow_mut`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow_mut">borrow_mut</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K): &<b>mut</b> V
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_length"></a>

### Function `length`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_length">length</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;): u64
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_empty"></a>

### Function `empty`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_empty">empty</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;): bool
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_borrow_mut_with_default"></a>

### Function `borrow_mut_with_default`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_borrow_mut_with_default">borrow_mut_with_default</a>&lt;K: <b>copy</b>, drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K, default: V): &<b>mut</b> V
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_upsert"></a>

### Function `upsert`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_upsert">upsert</a>&lt;K: <b>copy</b>, drop, V: drop&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K, value: V)
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_remove"></a>

### Function `remove`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_remove">remove</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<b>mut</b> <a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K): V
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>



<a id="@Specification_1_contains"></a>

### Function `contains`


<pre><code><b>public</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_contains">contains</a>&lt;K: <b>copy</b>, drop, V&gt;(<a href="table.md#0x1_table">table</a>: &<a href="table_with_length.md#0x1_table_with_length_TableWithLength">table_with_length::TableWithLength</a>&lt;K, V&gt;, key: K): bool
</code></pre>




<pre><code><b>pragma</b> intrinsic;
</code></pre>




<a id="0x1_table_with_length_spec_len"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_spec_len">spec_len</a>&lt;K, V&gt;(t: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;): num;
</code></pre>




<a id="0x1_table_with_length_spec_contains"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_spec_contains">spec_contains</a>&lt;K, V&gt;(t: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, k: K): bool;
</code></pre>




<a id="0x1_table_with_length_spec_set"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_spec_set">spec_set</a>&lt;K, V&gt;(t: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, k: K, v: V): <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;;
</code></pre>




<a id="0x1_table_with_length_spec_remove"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_spec_remove">spec_remove</a>&lt;K, V&gt;(t: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, k: K): <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;;
</code></pre>




<a id="0x1_table_with_length_spec_get"></a>


<pre><code><b>native</b> <b>fun</b> <a href="table_with_length.md#0x1_table_with_length_spec_get">spec_get</a>&lt;K, V&gt;(t: <a href="table_with_length.md#0x1_table_with_length_TableWithLength">TableWithLength</a>&lt;K, V&gt;, k: K): V;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc/type_info.md
================================================

<a id="0x1_type_info"></a>

# Module `0x1::type_info`



-  [Struct `TypeInfo`](#0x1_type_info_TypeInfo)
-  [Constants](#@Constants_0)
-  [Function `account_address`](#0x1_type_info_account_address)
-  [Function `module_name`](#0x1_type_info_module_name)
-  [Function `struct_name`](#0x1_type_info_struct_name)
-  [Function `chain_id`](#0x1_type_info_chain_id)
-  [Function `type_of`](#0x1_type_info_type_of)
-  [Function `type_name`](#0x1_type_info_type_name)
-  [Function `chain_id_internal`](#0x1_type_info_chain_id_internal)
-  [Function `size_of_val`](#0x1_type_info_size_of_val)
-  [Function `verify_type_of`](#0x1_type_info_verify_type_of)
-  [Function `verify_type_of_generic`](#0x1_type_info_verify_type_of_generic)
-  [Specification](#@Specification_1)
    -  [Function `chain_id`](#@Specification_1_chain_id)
    -  [Function `type_of`](#@Specification_1_type_of)
    -  [Function `type_name`](#@Specification_1_type_name)
    -  [Function `chain_id_internal`](#@Specification_1_chain_id_internal)
    -  [Function `size_of_val`](#@Specification_1_size_of_val)
    -  [Function `verify_type_of_generic`](#@Specification_1_verify_type_of_generic)


<pre><code><b>use</b> <a href="../../move-stdlib/doc/bcs.md#0x1_bcs">0x1::bcs</a>;
<b>use</b> <a href="../../move-stdlib/doc/error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="../../move-stdlib/doc/features.md#0x1_features">0x1::features</a>;
<b>use</b> <a href="../../move-stdlib/doc/string.md#0x1_string">0x1::string</a>;
</code></pre>



<a id="0x1_type_info_TypeInfo"></a>

## Struct `TypeInfo`



<pre><code><b>struct</b> <a href="type_info.md#0x1_type_info_TypeInfo">TypeInfo</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>account_address: <b>address</b></code>
</dt>
<dd>

</dd>
<dt>
<code>module_name: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>struct_name: <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_type_info_E_NATIVE_FUN_NOT_AVAILABLE"></a>



<pre><code><b>const</b> <a href="type_info.md#0x1_type_info_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>: u64 = 1;
</code></pre>



<a id="0x1_type_info_account_address"></a>

## Function `account_address`



<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_account_address">account_address</a>(<a href="type_info.md#0x1_type_info">type_info</a>: &<a href="type_info.md#0x1_type_info_TypeInfo">type_info::TypeInfo</a>): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_account_address">account_address</a>(<a href="type_info.md#0x1_type_info">type_info</a>: &<a href="type_info.md#0x1_type_info_TypeInfo">TypeInfo</a>): <b>address</b> {
    <a href="type_info.md#0x1_type_info">type_info</a>.account_address
}
</code></pre>



</details>

<a id="0x1_type_info_module_name"></a>

## Function `module_name`



<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_module_name">module_name</a>(<a href="type_info.md#0x1_type_info">type_info</a>: &<a href="type_info.md#0x1_type_info_TypeInfo">type_info::TypeInfo</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_module_name">module_name</a>(<a href="type_info.md#0x1_type_info">type_info</a>: &<a href="type_info.md#0x1_type_info_TypeInfo">TypeInfo</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <a href="type_info.md#0x1_type_info">type_info</a>.module_name
}
</code></pre>



</details>

<a id="0x1_type_info_struct_name"></a>

## Function `struct_name`



<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_struct_name">struct_name</a>(<a href="type_info.md#0x1_type_info">type_info</a>: &<a href="type_info.md#0x1_type_info_TypeInfo">type_info::TypeInfo</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_struct_name">struct_name</a>(<a href="type_info.md#0x1_type_info">type_info</a>: &<a href="type_info.md#0x1_type_info_TypeInfo">TypeInfo</a>): <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    <a href="type_info.md#0x1_type_info">type_info</a>.struct_name
}
</code></pre>



</details>

<a id="0x1_type_info_chain_id"></a>

## Function `chain_id`

Returns the current chain ID, mirroring what <code>aptos_framework::chain_id::get()</code> would return, except in <code>#[test]</code>
functions, where this will always return <code>4u8</code> as the chain ID, whereas <code>aptos_framework::chain_id::get()</code> will
return whichever ID was passed to <code>aptos_framework::chain_id::initialize_for_test()</code>.


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_chain_id">chain_id</a>(): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_chain_id">chain_id</a>(): u8 {
    <b>if</b> (!<a href="../../move-stdlib/doc/features.md#0x1_features_aptos_stdlib_chain_id_enabled">features::aptos_stdlib_chain_id_enabled</a>()) {
        <b>abort</b>(std::error::invalid_state(<a href="type_info.md#0x1_type_info_E_NATIVE_FUN_NOT_AVAILABLE">E_NATIVE_FUN_NOT_AVAILABLE</a>))
    };

    <a href="type_info.md#0x1_type_info_chain_id_internal">chain_id_internal</a>()
}
</code></pre>



</details>

<a id="0x1_type_info_type_of"></a>

## Function `type_of`

Return the <code><a href="type_info.md#0x1_type_info_TypeInfo">TypeInfo</a></code> struct containing  for the type <code>T</code>.


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_type_of">type_of</a>&lt;T&gt;(): <a href="type_info.md#0x1_type_info_TypeInfo">type_info::TypeInfo</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>native</b> <b>fun</b> <a href="type_info.md#0x1_type_info_type_of">type_of</a>&lt;T&gt;(): <a href="type_info.md#0x1_type_info_TypeInfo">TypeInfo</a>;
</code></pre>



</details>

<a id="0x1_type_info_type_name"></a>

## Function `type_name`

Return the human readable string for the type, including the address, module name, and any type arguments.
Example: 0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>
Or: 0x1::table::Table<0x1::string::String, 0x1::string::String>


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_type_name">type_name</a>&lt;T&gt;(): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>native</b> <b>fun</b> <a href="type_info.md#0x1_type_info_type_name">type_name</a>&lt;T&gt;(): String;
</code></pre>



</details>

<a id="0x1_type_info_chain_id_internal"></a>

## Function `chain_id_internal`



<pre><code><b>fun</b> <a href="type_info.md#0x1_type_info_chain_id_internal">chain_id_internal</a>(): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="type_info.md#0x1_type_info_chain_id_internal">chain_id_internal</a>(): u8;
</code></pre>



</details>

<a id="0x1_type_info_size_of_val"></a>

## Function `size_of_val`

Return the BCS size, in bytes, of value at <code>val_ref</code>.

See the [BCS spec](https://github.com/diem/bcs)

See <code>test_size_of_val()</code> for an analysis of common types and
nesting patterns, as well as <code>test_size_of_val_vectors()</code> for an
analysis of vector size dynamism.


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_size_of_val">size_of_val</a>&lt;T&gt;(val_ref: &T): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_size_of_val">size_of_val</a>&lt;T&gt;(val_ref: &T): u64 {
    // Return <a href="../../move-stdlib/doc/vector.md#0x1_vector">vector</a> length of vectorized BCS representation.
    <a href="../../move-stdlib/doc/vector.md#0x1_vector_length">vector::length</a>(&<a href="../../move-stdlib/doc/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</a>(val_ref))
}
</code></pre>



</details>

<a id="0x1_type_info_verify_type_of"></a>

## Function `verify_type_of`



<pre><code>#[verify_only]
<b>fun</b> <a href="type_info.md#0x1_type_info_verify_type_of">verify_type_of</a>()
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="type_info.md#0x1_type_info_verify_type_of">verify_type_of</a>() {
    <b>let</b> <a href="type_info.md#0x1_type_info">type_info</a> = <a href="type_info.md#0x1_type_info_type_of">type_of</a>&lt;<a href="type_info.md#0x1_type_info_TypeInfo">TypeInfo</a>&gt;();
    <b>let</b> account_address = <a href="type_info.md#0x1_type_info_account_address">account_address</a>(&<a href="type_info.md#0x1_type_info">type_info</a>);
    <b>let</b> module_name = <a href="type_info.md#0x1_type_info_module_name">module_name</a>(&<a href="type_info.md#0x1_type_info">type_info</a>);
    <b>let</b> struct_name = <a href="type_info.md#0x1_type_info_struct_name">struct_name</a>(&<a href="type_info.md#0x1_type_info">type_info</a>);
    <b>spec</b> {
        <b>assert</b> account_address == @aptos_std;
        <b>assert</b> module_name == b"<a href="type_info.md#0x1_type_info">type_info</a>";
        <b>assert</b> struct_name == b"<a href="type_info.md#0x1_type_info_TypeInfo">TypeInfo</a>";
    };
}
</code></pre>



</details>

<a id="0x1_type_info_verify_type_of_generic"></a>

## Function `verify_type_of_generic`



<pre><code>#[verify_only]
<b>fun</b> <a href="type_info.md#0x1_type_info_verify_type_of_generic">verify_type_of_generic</a>&lt;T&gt;()
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>fun</b> <a href="type_info.md#0x1_type_info_verify_type_of_generic">verify_type_of_generic</a>&lt;T&gt;() {
    <b>let</b> <a href="type_info.md#0x1_type_info">type_info</a> = <a href="type_info.md#0x1_type_info_type_of">type_of</a>&lt;T&gt;();
    <b>let</b> account_address = <a href="type_info.md#0x1_type_info_account_address">account_address</a>(&<a href="type_info.md#0x1_type_info">type_info</a>);
    <b>let</b> module_name = <a href="type_info.md#0x1_type_info_module_name">module_name</a>(&<a href="type_info.md#0x1_type_info">type_info</a>);
    <b>let</b> struct_name = <a href="type_info.md#0x1_type_info_struct_name">struct_name</a>(&<a href="type_info.md#0x1_type_info">type_info</a>);
    <b>spec</b> {
        <b>assert</b> account_address == <a href="type_info.md#0x1_type_info_type_of">type_of</a>&lt;T&gt;().account_address;
        <b>assert</b> module_name == <a href="type_info.md#0x1_type_info_type_of">type_of</a>&lt;T&gt;().module_name;
        <b>assert</b> struct_name == <a href="type_info.md#0x1_type_info_type_of">type_of</a>&lt;T&gt;().struct_name;
    };
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_chain_id"></a>

### Function `chain_id`


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_chain_id">chain_id</a>(): u8
</code></pre>




<pre><code><b>aborts_if</b> !<a href="../../move-stdlib/doc/features.md#0x1_features_spec_is_enabled">features::spec_is_enabled</a>(<a href="../../move-stdlib/doc/features.md#0x1_features_APTOS_STD_CHAIN_ID_NATIVES">features::APTOS_STD_CHAIN_ID_NATIVES</a>);
<b>ensures</b> result == <a href="type_info.md#0x1_type_info_spec_chain_id_internal">spec_chain_id_internal</a>();
</code></pre>



<a id="@Specification_1_type_of"></a>

### Function `type_of`


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_type_of">type_of</a>&lt;T&gt;(): <a href="type_info.md#0x1_type_info_TypeInfo">type_info::TypeInfo</a>
</code></pre>




<a id="@Specification_1_type_name"></a>

### Function `type_name`


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_type_name">type_name</a>&lt;T&gt;(): <a href="../../move-stdlib/doc/string.md#0x1_string_String">string::String</a>
</code></pre>




<a id="@Specification_1_chain_id_internal"></a>

### Function `chain_id_internal`


<pre><code><b>fun</b> <a href="type_info.md#0x1_type_info_chain_id_internal">chain_id_internal</a>(): u8
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="type_info.md#0x1_type_info_spec_chain_id_internal">spec_chain_id_internal</a>();
</code></pre>




<a id="0x1_type_info_spec_chain_id_internal"></a>


<pre><code><b>fun</b> <a href="type_info.md#0x1_type_info_spec_chain_id_internal">spec_chain_id_internal</a>(): u8;
</code></pre>




<a id="0x1_type_info_spec_size_of_val"></a>


<pre><code><b>fun</b> <a href="type_info.md#0x1_type_info_spec_size_of_val">spec_size_of_val</a>&lt;T&gt;(val_ref: T): u64 {
   len(std::bcs::serialize(val_ref))
}
</code></pre>



<a id="@Specification_1_size_of_val"></a>

### Function `size_of_val`


<pre><code><b>public</b> <b>fun</b> <a href="type_info.md#0x1_type_info_size_of_val">size_of_val</a>&lt;T&gt;(val_ref: &T): u64
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="type_info.md#0x1_type_info_spec_size_of_val">spec_size_of_val</a>&lt;T&gt;(val_ref);
</code></pre>



<a id="@Specification_1_verify_type_of_generic"></a>

### Function `verify_type_of_generic`


<pre><code>#[verify_only]
<b>fun</b> <a href="type_info.md#0x1_type_info_verify_type_of_generic">verify_type_of_generic</a>&lt;T&gt;()
</code></pre>




<pre><code><b>aborts_if</b> !<a href="type_info.md#0x1_type_info_spec_is_struct">spec_is_struct</a>&lt;T&gt;();
</code></pre>




<a id="0x1_type_info_spec_is_struct"></a>


<pre><code><b>native</b> <b>fun</b> <a href="type_info.md#0x1_type_info_spec_is_struct">spec_is_struct</a>&lt;T&gt;(): bool;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/doc_template/overview.md
================================================
# Supra Standard Library

This is the reference documentation of the Supra standard library.

## Index

> {{move-index}}


================================================
File: aptos-move/framework/aptos-stdlib/doc_template/references.md
================================================
[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/aptos-stdlib/sources/any.move
================================================
module aptos_std::any {
    use aptos_std::type_info;
    use aptos_std::from_bcs::from_bytes;
    use std::bcs::to_bytes;
    use std::error;
    use std::string::String;

    friend aptos_std::copyable_any;

    /// The type provided for `unpack` is not the same as was given for `pack`.
    const ETYPE_MISMATCH: u64 = 1;

    /// A type which can represent a value of any type. This allows for representation of 'unknown' future
    /// values. For example, to define a resource such that it can be later be extended without breaking
    /// changes one can do
    ///
    /// ```move
    ///   struct Resource {
    ///      field: Type,
    ///      ...
    ///      extension: Option<Any>
    ///   }
    /// ```
    struct Any has drop, store {
        type_name: String,
        data: vector<u8>
    }

    /// Pack a value into the `Any` representation. Because Any can be stored and dropped, this is
    /// also required from `T`.
    public fun pack<T: drop + store>(x: T): Any {
        Any {
            type_name: type_info::type_name<T>(),
            data: to_bytes(&x)
        }
    }

    /// Unpack a value from the `Any` representation. This aborts if the value has not the expected type `T`.
    public fun unpack<T>(x: Any): T {
        assert!(type_info::type_name<T>() == x.type_name, error::invalid_argument(ETYPE_MISMATCH));
        from_bytes<T>(x.data)
    }

    /// Returns the type name of this Any
    public fun type_name(x: &Any): &String {
        &x.type_name
    }

    #[test_only]
    struct S has store, drop { x: u64 }

    #[test]
    fun test_any() {
        assert!(unpack<u64>(pack(22)) == 22, 1);
        assert!(unpack<S>(pack(S { x: 22 })) == S { x: 22 }, 2);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/any.spec.move
================================================
spec aptos_std::any {

    // -----------------------
    // Function specifications
    // -----------------------

    spec pack<T: drop + store>(x: T): Any {
        use std::bcs;
        use aptos_std::from_bcs;
        aborts_if false;
        ensures result == Any {
            type_name: type_info::type_name<T>(),
            data: bcs::serialize<T>(x)
        };
        ensures [abstract] from_bcs::deserializable<T>(result.data);
    }

    spec unpack<T>(x: Any): T {
        use aptos_std::from_bcs;
        include UnpackAbortsIf<T>;
        ensures result == from_bcs::deserialize<T>(x.data);
    }

    spec schema UnpackAbortsIf<T> {
        use aptos_std::from_bcs;
        x: Any;
        aborts_if type_info::type_name<T>() != x.type_name;
        aborts_if !from_bcs::deserializable<T>(x.data);
    }

    spec schema UnpackRequirement<T> {
        use aptos_std::from_bcs;
        x: Any;
        requires type_info::type_name<T>() == x.type_name;
        requires from_bcs::deserializable<T>(x.data);
    }

    spec type_name(x: &Any): &String {
        aborts_if false;
        ensures result == x.type_name;
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/capability.move
================================================
/// A module which defines the basic concept of
/// [*capabilities*](https://en.wikipedia.org/wiki/Capability-based_security) for managing access control.
///
/// EXPERIMENTAL
///
/// # Overview
///
/// A capability is a unforgeable token which testifies that a signer has authorized a certain operation.
/// The token is valid during the transaction where it is obtained. Since the type `capability::Cap` has
/// no ability to be stored in global memory, capabilities cannot leak out of a transaction. For every function
/// called within a transaction which has a capability as a parameter, it is guaranteed that the capability
/// has been obtained via a proper signer-based authorization step previously in the transaction's execution.
///
/// ## Usage
///
/// Initializing and acquiring capabilities is usually encapsulated in a module with a type
/// tag which can only be constructed by this module.
///
/// ```
/// module Pkg::Feature {
///   use std::capability::Cap;
///
///   /// A type tag used in Cap<Feature>. Only this module can create an instance,
///   /// and there is no public function other than Self::acquire which returns a value of this type.
///   /// This way, this module has full control how Cap<Feature> is given out.
///   struct Feature has drop {}
///
///   /// Initializes this module.
///   public fun initialize(s: &signer) {
///     // Create capability. This happens once at module initialization time.
///     // One needs to provide a witness for being the owner of Feature
///     // in the 2nd parameter.
///     <<additional conditions allowing to initialize this capability>>
///     capability::create<Feature>(s, &Feature{});
///   }
///
///   /// Acquires the capability to work with this feature.
///   public fun acquire(s: &signer): Cap<Feature> {
///     <<additional conditions allowing to acquire this capability>>
///     capability::acquire<Feature>(s, &Feature{});
///   }
///
///   /// Does something related to the feature. The caller must pass a Cap<Feature>.
///   public fun do_something(_cap: Cap<Feature>) { ... }
/// }
/// ```
///
/// ## Delegation
///
/// Capabilities come with the optional feature of *delegation*. Via `Self::delegate`, an owner of a capability
/// can designate another signer to be also capable of acquiring the capability. Like the original creator,
/// the delegate needs to present his signer to obtain the capability in his transactions. Delegation can
/// be revoked via `Self::revoke`, removing this access right from the delegate.
///
/// While the basic authorization mechanism for delegates is the same as with core capabilities, the
/// target of delegation might be subject of restrictions which need to be specified and verified. This can
/// be done via global invariants in the specification language. For example, in order to prevent delegation
/// all together for a capability, one can use the following invariant:
///
/// ```
///   invariant forall a: address where capability::spec_has_cap<Feature>(a):
///               len(capability::spec_delegates<Feature>(a)) == 0;
/// ```
///
/// Similarly, the following invariant would enforce that delegates, if existent, must satisfy a certain
/// predicate:
///
/// ```
///   invariant forall a: address where capability::spec_has_cap<Feature>(a):
///               forall d in capability::spec_delegates<Feature>(a):
///                  is_valid_delegate_for_feature(d);
/// ```
///
module aptos_std::capability {
    use std::error;
    use std::signer;
    use std::vector;

    /// Capability resource already exists on the specified account
    const ECAPABILITY_ALREADY_EXISTS: u64 = 1;
    /// Capability resource not found
    const ECAPABILITY_NOT_FOUND: u64 = 2;
    /// Account does not have delegated permissions
    const EDELEGATE: u64 = 3;

    /// The token representing an acquired capability. Cannot be stored in memory, but copied and dropped freely.
    struct Cap<phantom Feature> has copy, drop {
        root: address
    }

    /// A linear version of a capability token. This can be used if an acquired capability should be enforced
    /// to be used only once for an authorization.
    struct LinearCap<phantom Feature> has drop {
        root: address
    }

    /// An internal data structure for representing a configured capability.
    struct CapState<phantom Feature> has key {
        delegates: vector<address>
    }

    /// An internal data structure for representing a configured delegated capability.
    struct CapDelegateState<phantom Feature> has key {
        root: address
    }

    /// Creates a new capability class, owned by the passed signer. A caller must pass a witness that
    /// they own the `Feature` type parameter.
    public fun create<Feature>(owner: &signer, _feature_witness: &Feature) {
        let addr = signer::address_of(owner);
        assert!(!exists<CapState<Feature>>(addr), error::already_exists(ECAPABILITY_ALREADY_EXISTS));
        move_to<CapState<Feature>>(owner, CapState { delegates: vector::empty() });
    }

    /// Acquires a capability token. Only the owner of the capability class, or an authorized delegate,
    /// can succeed with this operation. A caller must pass a witness that they own the `Feature` type
    /// parameter.
    public fun acquire<Feature>(requester: &signer, _feature_witness: &Feature): Cap<Feature>
    acquires CapState, CapDelegateState {
        Cap<Feature> { root: validate_acquire<Feature>(requester) }
    }

    /// Acquires a linear capability token. It is up to the module which owns `Feature` to decide
    /// whether to expose a linear or non-linear capability.
    public fun acquire_linear<Feature>(requester: &signer, _feature_witness: &Feature): LinearCap<Feature>
    acquires CapState, CapDelegateState {
        LinearCap<Feature> { root: validate_acquire<Feature>(requester) }
    }

    /// Helper to validate an acquire. Returns the root address of the capability.
    fun validate_acquire<Feature>(requester: &signer): address
    acquires CapState, CapDelegateState {
        let addr = signer::address_of(requester);
        if (exists<CapDelegateState<Feature>>(addr)) {
            let root_addr = borrow_global<CapDelegateState<Feature>>(addr).root;
            // double check that requester is actually registered as a delegate
            assert!(exists<CapState<Feature>>(root_addr), error::invalid_state(EDELEGATE));
            assert!(vector::contains(&borrow_global<CapState<Feature>>(root_addr).delegates, &addr),
                error::invalid_state(EDELEGATE));
            root_addr
        } else {
            assert!(exists<CapState<Feature>>(addr), error::not_found(ECAPABILITY_NOT_FOUND));
            addr
        }
    }

    /// Returns the root address associated with the given capability token. Only the owner
    /// of the feature can do this.
    public fun root_addr<Feature>(cap: Cap<Feature>, _feature_witness: &Feature): address {
        cap.root
    }

    /// Returns the root address associated with the given linear capability token.
    public fun linear_root_addr<Feature>(cap: LinearCap<Feature>, _feature_witness: &Feature): address {
        cap.root
    }

    /// Registers a delegation relation. If the relation already exists, this function does
    /// nothing.
    // TODO: explore whether this should be idempotent like now or abort
    public fun delegate<Feature>(cap: Cap<Feature>, _feature_witness: &Feature, to: &signer)
    acquires CapState {
        let addr = signer::address_of(to);
        if (exists<CapDelegateState<Feature>>(addr)) return;
        move_to(to, CapDelegateState<Feature> { root: cap.root });
        add_element(&mut borrow_global_mut<CapState<Feature>>(cap.root).delegates, addr);
    }

    /// Revokes a delegation relation. If no relation exists, this function does nothing.
    // TODO: explore whether this should be idempotent like now or abort
    public fun revoke<Feature>(cap: Cap<Feature>, _feature_witness: &Feature, from: address)
    acquires CapState, CapDelegateState
    {
        if (!exists<CapDelegateState<Feature>>(from)) return;
        let CapDelegateState { root: _root } = move_from<CapDelegateState<Feature>>(from);
        remove_element(&mut borrow_global_mut<CapState<Feature>>(cap.root).delegates, &from);
    }

    /// Helper to remove an element from a vector.
    fun remove_element<E: drop>(v: &mut vector<E>, x: &E) {
        let (found, index) = vector::index_of(v, x);
        if (found) {
            vector::remove(v, index);
        }
    }

    /// Helper to add an element to a vector.
    fun add_element<E: drop>(v: &mut vector<E>, x: E) {
        if (!vector::contains(v, &x)) {
            vector::push_back(v, x)
        }
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/capability.spec.move
================================================
spec aptos_std::capability {
    /// Helper specification function to check whether a capability exists at address.
    spec fun spec_has_cap<Feature>(addr: address): bool {
        exists<CapState<Feature>>(addr)
    }

    /// Helper specification function to obtain the delegates of a capability.
    spec fun spec_delegates<Feature>(addr: address): vector<address> {
        global<CapState<Feature>>(addr).delegates
    }

    /// Helper specification function to check whether a delegated capability exists at address.
    spec fun spec_has_delegate_cap<Feature>(addr: address): bool {
        exists<CapDelegateState<Feature>>(addr)
    }

    spec create<Feature>(owner: &signer, _feature_witness: &Feature) {
        let addr = signer::address_of(owner);
        aborts_if spec_has_cap<Feature>(addr);
        ensures spec_has_cap<Feature>(addr);
    }

    spec acquire<Feature>(requester: &signer, _feature_witness: &Feature): Cap<Feature> {
        let addr = signer::address_of(requester);
        let root_addr = global<CapDelegateState<Feature>>(addr).root;
        include AcquireSchema<Feature>;
        ensures spec_has_delegate_cap<Feature>(addr) ==> result.root == root_addr;
        ensures !spec_has_delegate_cap<Feature>(addr) ==> result.root == addr;
    }

    spec acquire_linear<Feature>(requester: &signer, _feature_witness: &Feature): LinearCap<Feature> {
        let addr = signer::address_of(requester);
        let root_addr = global<CapDelegateState<Feature>>(addr).root;
        include AcquireSchema<Feature>;
        ensures spec_has_delegate_cap<Feature>(addr) ==> result.root == root_addr;
        ensures !spec_has_delegate_cap<Feature>(addr) ==> result.root == addr;
    }

    spec schema AcquireSchema<Feature> {
        addr: address;
        root_addr: address;
        aborts_if spec_has_delegate_cap<Feature>(addr) && !spec_has_cap<Feature>(root_addr);
        aborts_if spec_has_delegate_cap<Feature>(addr) && !vector::spec_contains(spec_delegates<Feature>(root_addr), addr);
        aborts_if !spec_has_delegate_cap<Feature>(addr) && !spec_has_cap<Feature>(addr);
    }

    spec delegate<Feature>(cap: Cap<Feature>, _feature_witness: &Feature, to: &signer) {
        let addr = signer::address_of(to);
        ensures spec_has_delegate_cap<Feature>(addr);
        ensures !old(spec_has_delegate_cap<Feature>(addr)) ==> global<CapDelegateState<Feature>>(addr).root == cap.root;
        ensures !old(spec_has_delegate_cap<Feature>(addr)) ==> vector::spec_contains(spec_delegates<Feature>(cap.root), addr);
    }

    spec revoke<Feature>(cap: Cap<Feature>, _feature_witness: &Feature, from: address) {
        ensures !spec_has_delegate_cap<Feature>(from);
        // TODO: this cannot be proved. See issue #7422
        // ensures old(spec_has_delegate_cap<Feature>(from))
        //     ==> !vector::spec_contains(spec_delegates<Feature>(cap.root), from);
    }

    spec remove_element<E: drop>(v: &mut vector<E>, x: &E) {
        // TODO: this cannot be proved. See issue #7422
        // ensures !vector::spec_contains(v, x);
    }

    spec add_element<E: drop>(v: &mut vector<E>, x: E) {
        ensures vector::spec_contains(v, x);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/comparator.move
================================================
/// Provides a framework for comparing two elements
module aptos_std::comparator {
    use std::bcs;
    use std::vector;

    const EQUAL: u8 = 0;
    const SMALLER: u8 = 1;
    const GREATER: u8 = 2;

    struct Result has drop {
        inner: u8,
    }

    public fun is_equal(result: &Result): bool {
        result.inner == EQUAL
    }

    public fun is_smaller_than(result: &Result): bool {
        result.inner == SMALLER
    }

    public fun is_greater_than(result: &Result): bool {
        result.inner == GREATER
    }

    // Performs a comparison of two types after BCS serialization.
    // BCS uses little endian encoding for all integer types,
    // so comparison between primitive integer types will not behave as expected.
    // For example, 1(0x1) will be larger than 256(0x100) after BCS serialization.
    public fun compare<T>(left: &T, right: &T): Result {
        let left_bytes = bcs::to_bytes(left);
        let right_bytes = bcs::to_bytes(right);

        compare_u8_vector(left_bytes, right_bytes)
    }

    // Performs a comparison of two vector<u8>s or byte vectors
    public fun compare_u8_vector(left: vector<u8>, right: vector<u8>): Result {
        let left_length = vector::length(&left);
        let right_length = vector::length(&right);

        let idx = 0;

        while (idx < left_length && idx < right_length) {
            let left_byte = *vector::borrow(&left, idx);
            let right_byte = *vector::borrow(&right, idx);

            if (left_byte < right_byte) {
                return Result { inner: SMALLER }
            } else if (left_byte > right_byte) {
                return Result { inner: GREATER }
            };
            idx = idx + 1;
        };

        if (left_length < right_length) {
            Result { inner: SMALLER }
        } else if (left_length > right_length) {
            Result { inner: GREATER }
        } else {
            Result { inner: EQUAL }
        }
    }

    #[test]
    public fun test_strings() {
        use std::string;

        let value0 = string::utf8(b"alpha");
        let value1 = string::utf8(b"beta");
        let value2 = string::utf8(b"betaa");

        assert!(is_equal(&compare(&value0, &value0)), 0);
        assert!(is_equal(&compare(&value1, &value1)), 1);
        assert!(is_equal(&compare(&value2, &value2)), 2);

        assert!(is_greater_than(&compare(&value0, &value1)), 3);
        assert!(is_smaller_than(&compare(&value1, &value0)), 4);

        assert!(is_smaller_than(&compare(&value0, &value2)), 5);
        assert!(is_greater_than(&compare(&value2, &value0)), 6);

        assert!(is_smaller_than(&compare(&value1, &value2)), 7);
        assert!(is_greater_than(&compare(&value2, &value1)), 8);
    }

    #[test]
    #[expected_failure]
    public fun test_integer() {
        // 1(0x1) will be larger than 256(0x100) after BCS serialization.
        let value0: u128 = 1;
        let value1: u128 = 256;

        assert!(is_equal(&compare(&value0, &value0)), 0);
        assert!(is_equal(&compare(&value1, &value1)), 1);

        assert!(is_smaller_than(&compare(&value0, &value1)), 2);
        assert!(is_greater_than(&compare(&value1, &value0)), 3);
    }

    #[test]
    public fun test_u128() {
        let value0: u128 = 5;
        let value1: u128 = 152;
        let value2: u128 = 511; // 0x1ff

        assert!(is_equal(&compare(&value0, &value0)), 0);
        assert!(is_equal(&compare(&value1, &value1)), 1);
        assert!(is_equal(&compare(&value2, &value2)), 2);

        assert!(is_smaller_than(&compare(&value0, &value1)), 2);
        assert!(is_greater_than(&compare(&value1, &value0)), 3);

        assert!(is_smaller_than(&compare(&value0, &value2)), 3);
        assert!(is_greater_than(&compare(&value2, &value0)), 4);

        assert!(is_smaller_than(&compare(&value1, &value2)), 5);
        assert!(is_greater_than(&compare(&value2, &value1)), 6);
    }

    #[test_only]
    struct Complex has drop {
        value0: vector<u128>,
        value1: u8,
        value2: u64,
    }

    #[test]
    public fun test_complex() {
        let value0_0 = vector::empty();
        vector::push_back(&mut value0_0, 10);
        vector::push_back(&mut value0_0, 9);
        vector::push_back(&mut value0_0, 5);

        let value0_1 = vector::empty();
        vector::push_back(&mut value0_1, 10);
        vector::push_back(&mut value0_1, 9);
        vector::push_back(&mut value0_1, 5);
        vector::push_back(&mut value0_1, 1);

        let base = Complex {
            value0: value0_0,
            value1: 13,
            value2: 41,
        };

        let other_0 = Complex {
            value0: value0_1,
            value1: 13,
            value2: 41,
        };

        let other_1 = Complex {
            value0: copy value0_0,
            value1: 14,
            value2: 41,
        };

        let other_2 = Complex {
            value0: value0_0,
            value1: 13,
            value2: 42,
        };

        assert!(is_equal(&compare(&base, &base)), 0);
        assert!(is_smaller_than(&compare(&base, &other_0)), 1);
        assert!(is_greater_than(&compare(&other_0, &base)), 2);
        assert!(is_smaller_than(&compare(&base, &other_1)), 3);
        assert!(is_greater_than(&compare(&other_1, &base)), 4);
        assert!(is_smaller_than(&compare(&base, &other_2)), 5);
        assert!(is_greater_than(&compare(&other_2, &base)), 6);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/comparator.spec.move
================================================
spec aptos_std::comparator {
    spec Result {
        invariant inner == EQUAL || inner == SMALLER || inner == GREATER;
    }

    spec is_equal(result: &Result): bool {
        aborts_if false;
        let res = result;
        ensures result == (res.inner == EQUAL);
    }

    spec is_smaller_than(result: &Result): bool {
        aborts_if false;
        let res = result;
        ensures result == (res.inner == SMALLER);
    }

    spec is_greater_than(result: &Result): bool {
        aborts_if false;
        let res = result;
        ensures result == (res.inner == GREATER);
    }

    spec compare<T>(left: &T, right: &T): Result {
        let left_bytes = bcs::to_bytes(left);
        let right_bytes = bcs::to_bytes(right);
        ensures result == spec_compare_u8_vector(left_bytes, right_bytes);
    }

    spec fun spec_compare_u8_vector(left: vector<u8>, right: vector<u8>): Result;

    spec compare_u8_vector(left: vector<u8>, right: vector<u8>): Result {
        pragma unroll = 5;
        pragma opaque;
        aborts_if false;

        let left_length = len(left);
        let right_length = len(right);

        ensures (result.inner == EQUAL) ==> (
            (left_length == right_length) &&
                (forall i: u64 where i < left_length: left[i] == right[i])
        );

        ensures (result.inner == SMALLER) ==> (
            (exists i: u64 where i < left_length:
                (i < right_length) &&
                    (left[i] < right[i]) &&
                    (forall j: u64 where j < i: left[j] == right[j])
            ) ||
                (left_length < right_length)
        );

        ensures (result.inner == GREATER) ==> (
            (exists i: u64 where i < left_length:
                (i < right_length) &&
                    (left[i] > right[i]) &&
                    (forall j: u64 where j < i: left[j] == right[j])
            ) ||
                (left_length > right_length)
        );

        ensures [abstract] result == spec_compare_u8_vector(left, right);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/copyable_any.move
================================================
module aptos_std::copyable_any {
    use aptos_std::type_info;
    use aptos_std::from_bcs::from_bytes;
    use std::bcs;
    use std::error;
    use std::string::String;

    /// The type provided for `unpack` is not the same as was given for `pack`.
    const ETYPE_MISMATCH: u64 = 0;

    /// The same as `any::Any` but with the copy ability.
    struct Any has drop, store, copy {
        type_name: String,
        data: vector<u8>
    }

    /// Pack a value into the `Any` representation. Because Any can be stored, dropped, and copied this is
    /// also required from `T`.
    public fun pack<T: drop + store + copy>(x: T): Any {
        Any {
            type_name: type_info::type_name<T>(),
            data: bcs::to_bytes(&x)
        }
    }

    /// Unpack a value from the `Any` representation. This aborts if the value has not the expected type `T`.
    public fun unpack<T>(x: Any): T {
        assert!(type_info::type_name<T>() == x.type_name, error::invalid_argument(ETYPE_MISMATCH));
        from_bytes<T>(x.data)
    }

    /// Returns the type name of this Any
    public fun type_name(x: &Any): &String {
        &x.type_name
    }

    #[test_only]
    struct S has store, drop, copy { x: u64 }

    #[test]
    fun test_any() {
        assert!(unpack<u64>(pack(22)) == 22, 1);
        assert!(unpack<S>(pack(S { x: 22 })) == S { x: 22 }, 2);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/copyable_any.spec.move
================================================
spec aptos_std::copyable_any {

    // -----------------------
    // Function specifications
    // -----------------------

    spec pack<T: drop + store + copy>(x: T): Any {
        use std::bcs;
        use aptos_std::from_bcs;
        aborts_if false;
        pragma opaque;
        ensures result == Any {
            type_name: type_info::type_name<T>(),
            data: bcs::serialize<T>(x)
        };
        ensures [abstract] from_bcs::deserializable<T>(result.data);
    }

    spec unpack<T>(x: Any): T {
        use aptos_std::from_bcs;
        include UnpackAbortsIf<T>;
        ensures result == from_bcs::deserialize<T>(x.data);
    }

    spec schema UnpackAbortsIf<T> {
        use aptos_std::from_bcs;
        x: Any;
        aborts_if type_info::type_name<T>() != x.type_name;
        aborts_if !from_bcs::deserializable<T>(x.data);
    }

    spec type_name(x: &Any): &String {
        aborts_if false;
        ensures result == x.type_name;
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/debug.move
================================================
/// Module providing debug functionality.
module aptos_std::debug {
    use std::string::String;

    public fun print<T>(x: &T) {
        native_print(format(x));
    }

    public fun print_stack_trace() {
        native_print(native_stack_trace());
    }

    inline fun format<T>(x: &T): String {
        aptos_std::string_utils::debug_string(x)
    }

    native fun native_print(x: String);
    native fun native_stack_trace(): String;

    #[test_only]
    use std::vector;

    #[test_only]
    struct Foo has drop {}
    #[test_only]
    struct Bar has drop { x: u128, y: Foo, z: bool }
    #[test_only]
    struct Box<T> has drop { x: T }

    #[test_only]
    struct GenericStruct<phantom T> has drop {
        val: u64,
    }

    #[test_only]
    struct TestInner has drop {
        val: u128,
        vec: vector<u128>,
        msgs: vector<vector<u8>>
    }

    #[test_only]
    struct TestStruct has drop {
        addr: address,
        number: u8,
        bytes: vector<u8>,
        name: String,
        vec: vector<TestInner>,
    }

    #[test_only]
    fun assert_equal<T>(x: &T, expected: vector<u8>) {
        if (std::string::bytes(&format(x)) != &expected) {
            print(&format(x));
            print(&std::string::utf8(expected));
            assert!(false, 1);
        };
    }

    #[test_only]
    fun assert_string_equal(x: vector<u8>, expected: vector<u8>) {
        assert!(std::string::bytes(&format(&std::string::utf8(x))) == &expected, 1);
    }

    #[test]
    public fun test()  {
        let x = 42;
        assert_equal(&x, b"42");

        let v = vector::empty();
        vector::push_back(&mut v, 100);
        vector::push_back(&mut v, 200);
        vector::push_back(&mut v, 300);
        assert_equal(&v, b"[ 100, 200, 300 ]");

        let foo = Foo {};
        assert_equal(&foo, b"0x1::debug::Foo {\n  dummy_field: false\n}");

        let bar = Bar { x: 404, y: Foo {}, z: true };
        assert_equal(&bar, b"0x1::debug::Bar {\n  x: 404,\n  y: 0x1::debug::Foo {\n    dummy_field: false\n  },\n  z: true\n}");

        let box = Box { x: Foo {} };
        assert_equal(&box, b"0x1::debug::Box<0x1::debug::Foo> {\n  x: 0x1::debug::Foo {\n    dummy_field: false\n  }\n}");
    }

    #[test]
    fun test_print_string() {
        let str_bytes = b"Hello, sane Move debugging!";

        assert_equal(&str_bytes, b"0x48656c6c6f2c2073616e65204d6f766520646562756767696e6721");

        let str = std::string::utf8(str_bytes);
        assert_equal(&str, b"\"Hello, sane Move debugging!\"");
    }

    #[test]
    fun test_print_quoted_string() {
        let str_bytes = b"Can you say \"Hel\\lo\"?";

        let str = std::string::utf8(str_bytes);
        assert_equal(&str, b"\"Can you say \\\"Hel\\\\lo\\\"?\"");
    }


    #[test_only]
    use std::features;
    #[test(s = @0x123)]
    fun test_print_primitive_types(s: signer) {
        let u8 = 255u8;
        assert_equal(&u8, b"255");

        let u16 = 65535u16;
        assert_equal(&u16, b"65535");

        let u32 = 4294967295u32;
        assert_equal(&u32, b"4294967295");

        let u64 = 18446744073709551615u64;
        assert_equal(&u64, b"18446744073709551615");

        let u128 = 340282366920938463463374607431768211455u128;
        assert_equal(&u128, b"340282366920938463463374607431768211455");

        let u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935u256;
        assert_equal(&u256, b"115792089237316195423570985008687907853269984665640564039457584007913129639935");

        let bool = false;
        assert_equal(&bool, b"false");

        let bool = true;
        assert_equal(&bool, b"true");

        let a = @0x1234c0ffee;
        assert_equal(&a, b"@0x1234c0ffee");

        if (features::signer_native_format_fix_enabled()) {
            let signer = s;
            assert_equal(&signer, b"signer(@0x123)");
        }
    }

    const MSG_1 : vector<u8> = b"abcdef";
    const MSG_2 : vector<u8> = b"123456";

    #[test]
    fun test_print_struct() {
        let obj = TestInner {
            val: 100,
            vec: vector[200u128, 400u128],
            msgs: vector[MSG_1, MSG_2],
        };

        assert_equal(&obj, b"0x1::debug::TestInner {\n  val: 100,\n  vec: [ 200, 400 ],\n  msgs: [\n    0x616263646566,\n    0x313233343536\n  ]\n}");

        let obj = TestInner {
            val: 10,
            vec: vector[],
            msgs: vector[],
        };

        assert_equal(&obj, b"0x1::debug::TestInner {\n  val: 10,\n  vec: [],\n  msgs: []\n}");
    }

    #[test(s1 = @0x123, s2 = @0x456)]
    fun test_print_vectors(s1: signer, s2: signer) {
        let v_u8 = x"ffabcdef";
        assert_equal(&v_u8, b"0xffabcdef");

        let v_u16 = vector[16u16, 17u16, 18u16, 19u16];
        assert_equal(&v_u16, b"[ 16, 17, 18, 19 ]");

        let v_u32 = vector[32u32, 33u32, 34u32, 35u32];
        assert_equal(&v_u32, b"[ 32, 33, 34, 35 ]");

        let v_u64 = vector[64u64, 65u64, 66u64, 67u64];
        assert_equal(&v_u64, b"[ 64, 65, 66, 67 ]");

        let v_u128 = vector[128u128, 129u128, 130u128, 131u128];
        assert_equal(&v_u128, b"[ 128, 129, 130, 131 ]");

        let v_u256 = vector[256u256, 257u256, 258u256, 259u256];
        assert_equal(&v_u256, b"[ 256, 257, 258, 259 ]");

        let v_bool = vector[true, false];
        assert_equal(&v_bool, b"[ true, false ]");

        let v_addr = vector[@0x1234, @0x5678, @0xabcdef];
        assert_equal(&v_addr, b"[ @0x1234, @0x5678, @0xabcdef ]");

        if (features::signer_native_format_fix_enabled()) {
            let v_signer = vector[s1, s2];
            assert_equal(&v_signer, b"[ signer(@0x123), signer(@0x456) ]");
        };

        let v = vector[
            TestInner {
                val: 4u128,
                vec: vector[127u128, 128u128],
                msgs: vector[x"00ff", x"abcd"],
            },
            TestInner {
                val: 8u128 ,
                vec: vector[128u128, 129u128],
                msgs: vector[x"0000"],
            }
        ];
        assert_equal(&v, b"[\n  0x1::debug::TestInner {\n    val: 4,\n    vec: [ 127, 128 ],\n    msgs: [\n      0x00ff,\n      0xabcd\n    ]\n  },\n  0x1::debug::TestInner {\n    val: 8,\n    vec: [ 128, 129 ],\n    msgs: [\n      0x0000\n    ]\n  }\n]");
    }

    #[test(s1 = @0x123, s2 = @0x456)]
    fun test_print_vector_of_vectors(s1: signer, s2: signer) {
        let v_u8 = vector[x"ffab", x"cdef"];
        assert_equal(&v_u8, b"[\n  0xffab,\n  0xcdef\n]");

        let v_u16 = vector[vector[16u16, 17u16], vector[18u16, 19u16]];
        assert_equal(&v_u16, b"[\n  [ 16, 17 ],\n  [ 18, 19 ]\n]");

        let v_u32 = vector[vector[32u32, 33u32], vector[34u32, 35u32]];
        assert_equal(&v_u32, b"[\n  [ 32, 33 ],\n  [ 34, 35 ]\n]");

        let v_u64 = vector[vector[64u64, 65u64], vector[66u64, 67u64]];
        assert_equal(&v_u64, b"[\n  [ 64, 65 ],\n  [ 66, 67 ]\n]");

        let v_u128 = vector[vector[128u128, 129u128], vector[130u128, 131u128]];
        assert_equal(&v_u128, b"[\n  [ 128, 129 ],\n  [ 130, 131 ]\n]");

        let v_u256 = vector[vector[256u256, 257u256], vector[258u256, 259u256]];
        assert_equal(&v_u256, b"[\n  [ 256, 257 ],\n  [ 258, 259 ]\n]");

        let v_bool = vector[vector[true, false], vector[false, true]];
        assert_equal(&v_bool, b"[\n  [ true, false ],\n  [ false, true ]\n]");

        let v_addr = vector[vector[@0x1234, @0x5678], vector[@0xabcdef, @0x9999]];
        assert_equal(&v_addr, b"[\n  [ @0x1234, @0x5678 ],\n  [ @0xabcdef, @0x9999 ]\n]");

        if (features::signer_native_format_fix_enabled()) {
            let v_signer = vector[vector[s1], vector[s2]];
            assert_equal(&v_signer, b"[\n  [ signer(@0x123) ],\n  [ signer(@0x456) ]\n]");
        };

        let v = vector[
            vector[
                TestInner { val: 4u128, vec: vector[127u128, 128u128], msgs: vector[] },
                TestInner { val: 8u128 , vec: vector[128u128, 129u128], msgs: vector[] }
            ],
            vector[
                TestInner { val: 4u128, vec: vector[127u128, 128u128], msgs: vector[] },
                TestInner { val: 8u128 , vec: vector[128u128, 129u128], msgs: vector[] }
            ]
        ];
        assert_equal(&v, b"[\n  [\n    0x1::debug::TestInner {\n      val: 4,\n      vec: [ 127, 128 ],\n      msgs: []\n    },\n    0x1::debug::TestInner {\n      val: 8,\n      vec: [ 128, 129 ],\n      msgs: []\n    }\n  ],\n  [\n    0x1::debug::TestInner {\n      val: 4,\n      vec: [ 127, 128 ],\n      msgs: []\n    },\n    0x1::debug::TestInner {\n      val: 8,\n      vec: [ 128, 129 ],\n      msgs: []\n    }\n  ]\n]");
    }

    #[test]
    fun test_print_nested_struct() {
        let obj = TestStruct {
            addr: @0x1,
            number: 255u8,
            bytes: x"c0ffee",
            name: std::string::utf8(b"He\"llo"),
            vec: vector[
                TestInner { val: 1, vec: vector[130u128, 131u128], msgs: vector[] },
                TestInner { val: 2, vec: vector[132u128, 133u128], msgs: vector[] }
            ],
        };

        assert_equal(&obj, b"0x1::debug::TestStruct {\n  addr: @0x1,\n  number: 255,\n  bytes: 0xc0ffee,\n  name: \"He\\\"llo\",\n  vec: [\n    0x1::debug::TestInner {\n      val: 1,\n      vec: [ 130, 131 ],\n      msgs: []\n    },\n    0x1::debug::TestInner {\n      val: 2,\n      vec: [ 132, 133 ],\n      msgs: []\n    }\n  ]\n}");
    }

    #[test]
    fun test_print_generic_struct() {
        let obj = GenericStruct<Foo> {
            val: 60u64,
        };

        assert_equal(&obj, b"0x1::debug::GenericStruct<0x1::debug::Foo> {\n  val: 60\n}");
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/debug.spec.move
================================================
spec aptos_std::debug {
    spec print<T>(x: &T) {
        aborts_if false;
    }

    spec print_stack_trace() {
        aborts_if false;
    }

    spec native_print(x: String) {
        pragma opaque;
        aborts_if false;
    }

    spec native_stack_trace(): String {
        pragma opaque;
        aborts_if false;
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/fixed_point64.move
================================================
/// Defines a fixed-point numeric type with a 64-bit integer part and
/// a 64-bit fractional part.

module aptos_std::fixed_point64 {

    /// Define a fixed-point numeric type with 64 fractional bits.
    /// This is just a u128 integer but it is wrapped in a struct to
    /// make a unique type. This is a binary representation, so decimal
    /// values may not be exactly representable, but it provides more
    /// than 9 decimal digits of precision both before and after the
    /// decimal point (18 digits total). For comparison, double precision
    /// floating-point has less than 16 decimal digits of precision, so
    /// be careful about using floating-point to convert these values to
    /// decimal.
    struct FixedPoint64 has copy, drop, store { value: u128 }

    const MAX_U128: u256 = 340282366920938463463374607431768211455;

    /// The denominator provided was zero
    const EDENOMINATOR: u64 = 0x10001;
    /// The quotient value would be too large to be held in a `u128`
    const EDIVISION: u64 = 0x20002;
    /// The multiplied value would be too large to be held in a `u128`
    const EMULTIPLICATION: u64 = 0x20003;
    /// A division by zero was encountered
    const EDIVISION_BY_ZERO: u64 = 0x10004;
    /// The computed ratio when converting to a `FixedPoint64` would be unrepresentable
    const ERATIO_OUT_OF_RANGE: u64 = 0x20005;
    /// Abort code on calculation result is negative.
    const ENEGATIVE_RESULT: u64 = 0x10006;

    /// Returns x - y. x must be not less than y.
    public fun sub(x: FixedPoint64, y: FixedPoint64): FixedPoint64 {
        let x_raw = get_raw_value(x);
        let y_raw = get_raw_value(y);
        assert!(x_raw >= y_raw, ENEGATIVE_RESULT);
        create_from_raw_value(x_raw - y_raw)
    }
    spec sub {
        pragma opaque;
        aborts_if x.value < y.value with ENEGATIVE_RESULT;
        ensures result.value == x.value - y.value;
    }

    /// Returns x + y. The result cannot be greater than MAX_U128.
    public fun add(x: FixedPoint64, y: FixedPoint64): FixedPoint64 {
        let x_raw = get_raw_value(x);
        let y_raw = get_raw_value(y);
        let result = (x_raw as u256) + (y_raw as u256);
        assert!(result <= MAX_U128, ERATIO_OUT_OF_RANGE);
        create_from_raw_value((result as u128))
    }
    spec add {
        pragma opaque;
        aborts_if (x.value as u256) + (y.value as u256) > MAX_U128 with ERATIO_OUT_OF_RANGE;
        ensures result.value == x.value + y.value;
    }

    /// Multiply a u128 integer by a fixed-point number, truncating any
    /// fractional part of the product. This will abort if the product
    /// overflows.
    public fun multiply_u128(val: u128, multiplier: FixedPoint64): u128 {
        // The product of two 128 bit values has 256 bits, so perform the
        // multiplication with u256 types and keep the full 256 bit product
        // to avoid losing accuracy.
        let unscaled_product = (val as u256) * (multiplier.value as u256);
        // The unscaled product has 64 fractional bits (from the multiplier)
        // so rescale it by shifting away the low bits.
        let product = unscaled_product >> 64;
        // Check whether the value is too large.
        assert!(product <= MAX_U128, EMULTIPLICATION);
        (product as u128)
    }
    spec multiply_u128 {
        pragma opaque;
        include MultiplyAbortsIf;
        ensures result == spec_multiply_u128(val, multiplier);
    }
    spec schema MultiplyAbortsIf {
        val: num;
        multiplier: FixedPoint64;
        aborts_if spec_multiply_u128(val, multiplier) > MAX_U128 with EMULTIPLICATION;
    }
    spec fun spec_multiply_u128(val: num, multiplier: FixedPoint64): num {
        (val * multiplier.value) >> 64
    }

    public fun multiply_u128_return_fixpoint64(val: u128, multiplier: FixedPoint64): FixedPoint64 {
        // The product of two 128 bit values has 256 bits, so perform the
        // multiplication with u256 types and keep the full 256 bit product
        // to avoid losing accuracy.
        let unscaled_product = (val as u256) * (multiplier.value as u256);
        // Check whether the value is too large.
        assert!(unscaled_product <= MAX_U128, EMULTIPLICATION);
        create_from_raw_value((unscaled_product as u128))
    }


    /// Divide a u128 integer by a fixed-point number, truncating any
    /// fractional part of the quotient. This will abort if the divisor
    /// is zero or if the quotient overflows.
    public fun divide_u128(val: u128, divisor: FixedPoint64): u128 {
        // Check for division by zero.
        assert!(divisor.value != 0, EDIVISION_BY_ZERO);
        // First convert to 256 bits and then shift left to
        // add 64 fractional zero bits to the dividend.
        let scaled_value = (val as u256) << 64;
        let quotient = scaled_value / (divisor.value as u256);
        // Check whether the value is too large.
        assert!(quotient <= MAX_U128, EDIVISION);
        // the value may be too large, which will cause the cast to fail
        // with an arithmetic error.
        (quotient as u128)
    }
    spec divide_u128 {
        pragma opaque;
        include DivideAbortsIf;
        ensures result == spec_divide_u128(val, divisor);
    }
    spec schema DivideAbortsIf {
        val: num;
        divisor: FixedPoint64;
        aborts_if divisor.value == 0 with EDIVISION_BY_ZERO;
        aborts_if spec_divide_u128(val, divisor) > MAX_U128 with EDIVISION;
    }
    spec fun spec_divide_u128(val: num, divisor: FixedPoint64): num {
        (val << 64) / divisor.value
    }

    /// Create a fixed-point value from a rational number specified by its
    /// numerator and denominator. Calling this function should be preferred
    /// for using `Self::create_from_raw_value` which is also available.
    /// This will abort if the denominator is zero. It will also
    /// abort if the numerator is nonzero and the ratio is not in the range
    /// 2^-64 .. 2^64-1. When specifying decimal fractions, be careful about
    /// rounding errors: if you round to display N digits after the decimal
    /// point, you can use a denominator of 10^N to avoid numbers where the
    /// very small imprecision in the binary representation could change the
    /// rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.
    public fun create_from_rational(numerator: u128, denominator: u128): FixedPoint64 {
        // If the denominator is zero, this will abort.
        // Scale the numerator to have 64 fractional bits, so that the quotient will have 64
        // fractional bits.
        let scaled_numerator = (numerator as u256) << 64;
        assert!(denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / (denominator as u256);
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        // Return the quotient as a fixed-point number. We first need to check whether the cast
        // can succeed.
        assert!(quotient <= MAX_U128, ERATIO_OUT_OF_RANGE);
        FixedPoint64 { value: (quotient as u128) }
    }
    spec create_from_rational {
        pragma opaque;
        pragma verify_duration_estimate = 1000; // TODO: set because of timeout (property proved).
        include CreateFromRationalAbortsIf;
        ensures result == spec_create_from_rational(numerator, denominator);
    }
    spec schema CreateFromRationalAbortsIf {
        numerator: u128;
        denominator: u128;
        let scaled_numerator = (numerator as u256)<< 64;
        let scaled_denominator = (denominator as u256);
        let quotient = scaled_numerator / scaled_denominator;
        aborts_if scaled_denominator == 0 with EDENOMINATOR;
        aborts_if quotient == 0 && scaled_numerator != 0 with ERATIO_OUT_OF_RANGE;
        aborts_if quotient > MAX_U128 with ERATIO_OUT_OF_RANGE;
    }
    spec fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint64 {
        FixedPoint64{value: (numerator << 128) / (denominator << 64)}
    }

    /// Create a fixedpoint value from a raw value.
    public fun create_from_raw_value(value: u128): FixedPoint64 {
        FixedPoint64 { value }
    }
    spec create_from_raw_value {
        pragma opaque;
        aborts_if false;
        ensures result.value == value;
    }

    /// Accessor for the raw u128 value. Other less common operations, such as
    /// adding or subtracting FixedPoint64 values, can be done using the raw
    /// values directly.
    public fun get_raw_value(num: FixedPoint64): u128 {
        num.value
    }

    /// Returns true if the ratio is zero.
    public fun is_zero(num: FixedPoint64): bool {
        num.value == 0
    }

    /// Returns the smaller of the two FixedPoint64 numbers.
    public fun min(num1: FixedPoint64, num2: FixedPoint64): FixedPoint64 {
        if (num1.value < num2.value) {
            num1
        } else {
            num2
        }
    }
    spec min {
        pragma opaque;
        aborts_if false;
        ensures result == spec_min(num1, num2);
    }
    spec fun spec_min(num1: FixedPoint64, num2: FixedPoint64): FixedPoint64 {
        if (num1.value < num2.value) {
            num1
        } else {
            num2
        }
    }

    /// Returns the larger of the two FixedPoint64 numbers.
    public fun max(num1: FixedPoint64, num2: FixedPoint64): FixedPoint64 {
        if (num1.value > num2.value) {
            num1
        } else {
            num2
        }
    }
    spec max {
        pragma opaque;
        aborts_if false;
        ensures result == spec_max(num1, num2);
    }
    spec fun spec_max(num1: FixedPoint64, num2: FixedPoint64): FixedPoint64 {
        if (num1.value > num2.value) {
            num1
        } else {
            num2
        }
    }

    /// Returns true if num1 <= num2
    public fun less_or_equal(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value <= num2.value
    }
    spec less_or_equal {
        pragma opaque;
        aborts_if false;
        ensures result == spec_less_or_equal(num1, num2);
    }
    spec fun spec_less_or_equal(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value <= num2.value
    }

    /// Returns true if num1 < num2
    public fun less(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value < num2.value
    }
    spec less {
        pragma opaque;
        aborts_if false;
        ensures result == spec_less(num1, num2);
    }
    spec fun spec_less(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value < num2.value
    }

    /// Returns true if num1 >= num2
    public fun greater_or_equal(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value >= num2.value
    }
    spec greater_or_equal {
        pragma opaque;
        aborts_if false;
        ensures result == spec_greater_or_equal(num1, num2);
    }
    spec fun spec_greater_or_equal(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value >= num2.value
    }

    /// Returns true if num1 > num2
    public fun greater(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value > num2.value
    }
    spec greater {
        pragma opaque;
        aborts_if false;
        ensures result == spec_greater(num1, num2);
    }
    spec fun spec_greater(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value > num2.value
    }

    /// Returns true if num1 = num2
    public fun equal(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value == num2.value
    }
    spec equal {
        pragma opaque;
        aborts_if false;
        ensures result == spec_equal(num1, num2);
    }
    spec fun spec_equal(num1: FixedPoint64, num2: FixedPoint64): bool {
        num1.value == num2.value
    }

    /// Returns true if num1 almost equals to num2, which means abs(num1-num2) <= precision
    public fun almost_equal(num1: FixedPoint64, num2: FixedPoint64, precision: FixedPoint64): bool {
        if (num1.value > num2.value) {
            (num1.value - num2.value <= precision.value)
        } else {
            (num2.value - num1.value <= precision.value)
        }
    }
    spec almost_equal {
        pragma opaque;
        aborts_if false;
        ensures result == spec_almost_equal(num1, num2, precision);
    }
    spec fun spec_almost_equal(num1: FixedPoint64, num2: FixedPoint64, precision: FixedPoint64): bool {
        if (num1.value > num2.value) {
            (num1.value - num2.value <= precision.value)
        } else {
            (num2.value - num1.value <= precision.value)
        }
    }
    /// Create a fixedpoint value from a u128 value.
    public fun create_from_u128(val: u128): FixedPoint64 {
        let value = (val as u256) << 64;
        assert!(value <= MAX_U128, ERATIO_OUT_OF_RANGE);
        FixedPoint64 {value: (value as u128)}
    }
    spec create_from_u128 {
        pragma opaque;
        include CreateFromU64AbortsIf;
        ensures result == spec_create_from_u128(val);
    }
    spec schema CreateFromU64AbortsIf {
        val: num;
        let scaled_value = (val as u256) << 64;
        aborts_if scaled_value > MAX_U128;
    }
    spec fun spec_create_from_u128(val: num): FixedPoint64 {
        FixedPoint64 {value: val << 64}
    }

    /// Returns the largest integer less than or equal to a given number.
    public fun floor(num: FixedPoint64): u128 {
        num.value >> 64
    }
    spec floor {
        pragma opaque;
        aborts_if false;
        ensures result == spec_floor(num);
    }
    spec fun spec_floor(val: FixedPoint64): u128 {
        let fractional = val.value % (1 << 64);
        if (fractional == 0) {
            val.value >> 64
        } else {
            (val.value - fractional) >> 64
        }
    }

    /// Rounds up the given FixedPoint64 to the next largest integer.
    public fun ceil(num: FixedPoint64): u128 {
        let floored_num = floor(num) << 64;
        if (num.value == floored_num) {
            return floored_num >> 64
        };
        let val = ((floored_num as u256) + (1 << 64));
        (val >> 64 as u128)
    }
    spec ceil {
        // TODO: set because of timeout (property proved).
        pragma verify_duration_estimate = 1000;
        pragma opaque;
        aborts_if false;
        ensures result == spec_ceil(num);
    }
    spec fun spec_ceil(val: FixedPoint64): u128 {
        let fractional = val.value % (1 << 64);
        let one = 1 << 64;
        if (fractional == 0) {
            val.value >> 64
        } else {
            (val.value - fractional + one) >> 64
        }
    }

    /// Returns the value of a FixedPoint64 to the nearest integer.
    public fun round(num: FixedPoint64): u128 {
        let floored_num = floor(num) << 64;
        let boundary = floored_num + ((1 << 64) / 2);
        if (num.value < boundary) {
            floored_num >> 64
        } else {
            ceil(num)
        }
    }
    spec round {
        pragma opaque;
        aborts_if false;
        ensures result == spec_round(num);
    }
    spec fun spec_round(val: FixedPoint64): u128 {
        let fractional = val.value % (1 << 64);
        let boundary = (1 << 64) / 2;
        let one = 1 << 64;
        if (fractional < boundary) {
            (val.value - fractional) >> 64
        } else {
            (val.value - fractional + one) >> 64
        }
    }

    // **************** SPECIFICATIONS ****************

    spec module {} // switch documentation context to module level

    spec module {
        pragma aborts_if_is_strict;
    }

    #[test]
    public entry fun test_sub() {
        let x = create_from_rational(9, 7);
        let y = create_from_rational(1, 3);
        let result = sub(x, y);
        // 9/7 - 1/3 = 20/21
        let expected_result = create_from_rational(20, 21);
        assert_approx_the_same((get_raw_value(result) as u256), (get_raw_value(expected_result) as u256), 16);
    }

    #[test]
    #[expected_failure(abort_code = 0x10006, location = Self)]
    public entry fun test_sub_should_abort() {
        let x = create_from_rational(1, 3);
        let y = create_from_rational(9, 7);
        let _ = sub(x, y);
    }

    #[test_only]
    /// For functions that approximate a value it's useful to test a value is close
    /// to the most correct value up to last digit
    fun assert_approx_the_same(x: u256, y: u256, precission: u128) {
        if (x < y) {
            let tmp = x;
            x = y;
            y = tmp;
        };
        let mult = 1u256;
        let n = 10u256;
        while (precission > 0) {
            if (precission % 2 == 1) {
                mult = mult * n;
            };
            precission = precission / 2;
            n = n * n;
        };
        assert!((x - y) * mult < x, 0);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/from_bcs.move
================================================
/// This module provides a number of functions to convert _primitive_ types from their representation in `std::bcs`
/// to values. This is the opposite of `bcs::to_bytes`. Note that it is not safe to define a generic public `from_bytes`
/// function because this can violate implicit struct invariants, therefore only primitive types are offerred. If
/// a general conversion back-and-force is needed, consider the `aptos_std::Any` type which preserves invariants.
///
/// Example:
/// ```
/// use std::bcs;
/// use aptos_std::from_bcs;
///
/// assert!(from_bcs::to_address(bcs::to_bytes(&@0xabcdef)) == @0xabcdef, 0);
/// ```
module aptos_std::from_bcs {
    use std::string::{Self, String};

    /// UTF8 check failed in conversion from bytes to string
    const EINVALID_UTF8: u64 = 0x1;

    public fun to_bool(v: vector<u8>): bool {
        from_bytes<bool>(v)
    }

    public fun to_u8(v: vector<u8>): u8 {
        from_bytes<u8>(v)
    }

    public fun to_u16(v: vector<u8>): u16 {
        from_bytes<u16>(v)
    }

    public fun to_u32(v: vector<u8>): u32 {
        from_bytes<u32>(v)
    }

    public fun to_u64(v: vector<u8>): u64 {
        from_bytes<u64>(v)
    }

    public fun to_u128(v: vector<u8>): u128 {
        from_bytes<u128>(v)
    }

    public fun to_u256(v: vector<u8>): u256 {
        from_bytes<u256>(v)
    }

    public fun to_address(v: vector<u8>): address {
        from_bytes<address>(v)
    }

    public fun to_bytes(v: vector<u8>): vector<u8> {
        from_bytes<vector<u8>>(v)
    }

    public fun to_string(v: vector<u8>): String {
        // To make this safe, we need to evaluate the utf8 invariant.
        let s = from_bytes<String>(v);
        assert!(string::internal_check_utf8(string::bytes(&s)), EINVALID_UTF8);
        s
    }

    /// Package private native function to deserialize a type T.
    ///
    /// Note that this function does not put any constraint on `T`. If code uses this function to
    /// deserialize a linear value, its their responsibility that the data they deserialize is
    /// owned.
    public(friend) native fun from_bytes<T>(bytes: vector<u8>): T;
    friend aptos_std::any;
    friend aptos_std::copyable_any;


    #[test_only]
    use std::bcs;

    #[test]
    fun test_address() {
        let addr = @0x01;
        let addr_vec = x"0000000000000000000000000000000000000000000000000000000000000001";
        let addr_out = to_address(addr_vec);
        let addr_vec_out = bcs::to_bytes(&addr_out);
        assert!(addr == addr_out, 0);
        assert!(addr_vec == addr_vec_out, 1);
    }

    #[test]
    #[expected_failure(abort_code = 0x10001, location = Self)]
    fun test_address_fail() {
        let bad_vec = b"01";
        to_address(bad_vec);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/from_bcs.spec.move
================================================
spec aptos_std::from_bcs {
    // ----------------------------------
    // Uninterpreted functions and axioms
    // ----------------------------------
    spec module {
        // An uninterpreted function to represent the desrialization.
        fun deserialize<T>(bytes: vector<u8>): T;

        // Checks if `bytes` is valid so that it can be deserialized into type T.
        // This is modeled as an uninterpreted function.
        fun deserializable<T>(bytes: vector<u8>): bool;

        // `deserialize` is an injective function.
        // axiom<T> forall b1: vector<u8>, b2: vector<u8>:
        //    (deserialize<T>(b1) == deserialize<T>(b2) ==> b1 == b2);

        // If the input are equal, the result of deserialize should be equal too
        axiom<T> forall b1: vector<u8>, b2: vector<u8>:
            ( b1 == b2 ==> deserializable<T>(b1) == deserializable<T>(b2) );

        axiom<T> forall b1: vector<u8>, b2: vector<u8>:
            ( b1 == b2 ==> deserialize<T>(b1) == deserialize<T>(b2) );

        // `deserialize` is an inverse function of `bcs::serialize`.
        // TODO: disabled because this generic axiom causes a timeout.
        // axiom<T> forall v: T: deserialize<T>(bcs::serialize(v)) == v;

        // All serialized bytes are deserializable.
        // TODO: disabled because this generic axiom causes a timeout.
        // axiom<T> forall v: T: deserializable<T>(bcs::serialize(v));
    }


    // -----------------------
    // Function specifications
    // -----------------------

    spec from_bytes<T>(bytes: vector<u8>): T {
        pragma opaque;
        aborts_if !deserializable<T>(bytes);
        ensures result == deserialize<T>(bytes);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/hash.move
================================================
/// Cryptographic hashes:
/// - Keccak-256: see https://keccak.team/keccak.html
///
/// In addition, SHA2-256 and SHA3-256 are available in `std::hash`. Note that SHA3-256 is a variant of Keccak: it is
/// NOT the same as Keccak-256.
///
/// Non-cryptograhic hashes:
/// - SipHash: an add-rotate-xor (ARX) based family of pseudorandom functions created by Jean-Philippe Aumasson and Daniel J. Bernstein in 2012
module aptos_std::aptos_hash {
    use std::bcs;
    use std::features;

    //
    // Constants
    //

    /// A newly-added native function is not yet enabled.
    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 1;

    //
    // Functions
    //

    /// Returns the (non-cryptographic) SipHash of `bytes`. See https://en.wikipedia.org/wiki/SipHash
    native public fun sip_hash(bytes: vector<u8>): u64;

    /// Returns the (non-cryptographic) SipHash of the BCS serialization of `v`. See https://en.wikipedia.org/wiki/SipHash
    public fun sip_hash_from_value<MoveValue>(v: &MoveValue): u64 {
        let bytes = bcs::to_bytes(v);

        sip_hash(bytes)
    }

    /// Returns the Keccak-256 hash of `bytes`.
    native public fun keccak256(bytes: vector<u8>): vector<u8>;

    /// Returns the SHA2-512 hash of `bytes`.
    public fun sha2_512(bytes: vector<u8>): vector<u8> {
        if(!features::sha_512_and_ripemd_160_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        sha2_512_internal(bytes)
    }

    /// Returns the SHA3-512 hash of `bytes`.
    public fun sha3_512(bytes: vector<u8>): vector<u8> {
        if(!features::sha_512_and_ripemd_160_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        sha3_512_internal(bytes)
    }


    /// Returns the RIPEMD-160 hash of `bytes`.
    ///
    /// WARNING: Only 80-bit security is provided by this function. This means an adversary who can compute roughly 2^80
    /// hashes will, with high probability, find a collision x_1 != x_2 such that RIPEMD-160(x_1) = RIPEMD-160(x_2).
    public fun ripemd160(bytes: vector<u8>): vector<u8> {
        if(!features::sha_512_and_ripemd_160_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        ripemd160_internal(bytes)
    }

    /// Returns the BLAKE2B-256 hash of `bytes`.
    public fun blake2b_256(bytes: vector<u8>): vector<u8> {
        if(!features::blake2b_256_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        blake2b_256_internal(bytes)
    }

    //
    // Private native functions
    //

    /// Returns the SHA2-512 hash of `bytes`.
    native fun sha2_512_internal(bytes: vector<u8>): vector<u8>;


    /// Returns the SHA3-512 hash of `bytes`.
    native fun sha3_512_internal(bytes: vector<u8>): vector<u8>;

    /// Returns the RIPEMD-160 hash of `bytes`.
    ///
    /// WARNING: Only 80-bit security is provided by this function. This means an adversary who can compute roughly 2^80
    /// hashes will, with high probability, find a collision x_1 != x_2 such that RIPEMD-160(x_1) = RIPEMD-160(x_2).
    native fun ripemd160_internal(bytes: vector<u8>): vector<u8>;

    /// Returns the BLAKE2B-256 hash of `bytes`.
    native fun blake2b_256_internal(bytes: vector<u8>): vector<u8>;

    //
    // Testing
    //

    #[test]
    fun keccak256_test() {
        let inputs = vector[
            b"testing",
            b"",
        ];

        let outputs = vector[
            x"5f16f4c7f149ac4f9510d9cf8cf384038ad348b3bcdc01915f95de12df9d1b02",
            x"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
        ];

        let i = 0;
        while (i < std::vector::length(&inputs)) {
            let input = *std::vector::borrow(&inputs, i);
            let hash_expected = *std::vector::borrow(&outputs, i);
            let hash = keccak256(input);

            assert!(hash_expected == hash, 1);

            i = i + 1;
        };
    }

    #[test(fx = @aptos_std)]
    fun sha2_512_test(fx: signer) {
        // We need to enable the feature in order for the native call to be allowed.
        features::change_feature_flags_for_testing(&fx, vector[features::get_sha_512_and_ripemd_160_feature()], vector[]);

        let inputs = vector[
        b"testing",
        b"",
        ];

        // From https://emn178.github.io/online-tools/sha512.html
        let outputs = vector[
        x"521b9ccefbcd14d179e7a1bb877752870a6d620938b28a66a107eac6e6805b9d0989f45b5730508041aa5e710847d439ea74cd312c9355f1f2dae08d40e41d50",
        x"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e",
        ];

        let i = 0;
        while (i < std::vector::length(&inputs)) {
            let input = *std::vector::borrow(&inputs, i);
            let hash_expected = *std::vector::borrow(&outputs, i);
            let hash = sha2_512(input);

            assert!(hash_expected == hash, 1);

            i = i + 1;
        };
    }

    #[test(fx = @aptos_std)]
    fun sha3_512_test(fx: signer) {
        // We need to enable the feature in order for the native call to be allowed.
        features::change_feature_flags_for_testing(&fx, vector[features::get_sha_512_and_ripemd_160_feature()], vector[]);
        let inputs = vector[
        b"testing",
        b"",
        ];

        // From https://emn178.github.io/online-tools/sha3_512.html
        let outputs = vector[
        x"881c7d6ba98678bcd96e253086c4048c3ea15306d0d13ff48341c6285ee71102a47b6f16e20e4d65c0c3d677be689dfda6d326695609cbadfafa1800e9eb7fc1",
        x"a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26",
        ];

        let i = 0;
        while (i < std::vector::length(&inputs)) {
            let input = *std::vector::borrow(&inputs, i);
            let hash_expected = *std::vector::borrow(&outputs, i);
            let hash = sha3_512(input);

            assert!(hash_expected == hash, 1);

            i = i + 1;
        };
    }

    #[test(fx = @aptos_std)]
    fun ripemd160_test(fx: signer) {
        // We need to enable the feature in order for the native call to be allowed.
        features::change_feature_flags_for_testing(&fx, vector[features::get_sha_512_and_ripemd_160_feature()], vector[]);
        let inputs = vector[
        b"testing",
        b"",
        ];

        // From https://www.browserling.com/tools/ripemd160-hash
        let outputs = vector[
        x"b89ba156b40bed29a5965684b7d244c49a3a769b",
        x"9c1185a5c5e9fc54612808977ee8f548b2258d31",
        ];

        let i = 0;
        while (i < std::vector::length(&inputs)) {
            let input = *std::vector::borrow(&inputs, i);
            let hash_expected = *std::vector::borrow(&outputs, i);
            let hash = ripemd160(input);

            assert!(hash_expected == hash, 1);

            i = i + 1;
        };
    }

    #[test(fx = @aptos_std)]
    #[expected_failure(abort_code = 196609, location = Self)]
    fun blake2b_256_aborts(fx: signer) {
        // We disable the feature to make sure the `blake2b_256` call aborts
        features::change_feature_flags_for_testing(&fx, vector[], vector[features::get_blake2b_256_feature()]);

        blake2b_256(b"This will abort");
    }

    #[test(fx = @aptos_std)]
    fun blake2b_256_test(fx: signer) {
        // We need to enable the feature in order for the native call to be allowed.
        features::change_feature_flags_for_testing(&fx, vector[features::get_blake2b_256_feature()], vector[]);
        let inputs = vector[
        b"",
        b"testing",
        b"testing again", // empty message doesn't yield an output on the online generator
        ];

        // From https://www.toolkitbay.com/tkb/tool/BLAKE2b_256
        //
        // For computing the hash of an empty string, we use the following Python3 script:
        // ```
        //   #!/usr/bin/python3
        //
        //   import hashlib
        //
        //   print(hashlib.blake2b(b'', digest_size=32).hexdigest());
        // ```
        let outputs = vector[
        x"0e5751c026e543b2e8ab2eb06099daa1d1e5df47778f7787faab45cdf12fe3a8",
        x"99397ff32ae348b8b6536d5c213f343d7e9fdeaa10e8a23a9f90ab21a1658565",
        x"1deab5a4eb7481453ca9b29e1f7c4be8ba44de4faeeafdf173b310cbaecfc84c",
        ];

        let i = 0;
        while (i < std::vector::length(&inputs)) {
            let input = *std::vector::borrow(&inputs, i);
            let hash_expected = *std::vector::borrow(&outputs, i);
            let hash = blake2b_256(input);

            assert!(hash_expected == hash, 1);

            i = i + 1;
        };
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/hash.spec.move
================================================
spec aptos_std::aptos_hash {
    spec module {
        /// `spec_sip_hash` is not assumed to be injective.
        fun spec_sip_hash(bytes: vector<u8>): u64;

        /// `spec_keccak256` is an injective function.
        fun spec_keccak256(bytes: vector<u8>): vector<u8>;
        axiom forall b1: vector<u8>, b2: vector<u8>:
            (spec_keccak256(b1) == spec_keccak256(b2) ==> b1 == b2);

        /// `spec_sha2_512_internal` is an injective function.
        fun spec_sha2_512_internal(bytes: vector<u8>): vector<u8>;
        axiom forall b1: vector<u8>, b2: vector<u8>:
            (spec_sha2_512_internal(b1) == spec_sha2_512_internal(b2) ==> b1 == b2);

        /// `spec_sha3_512_internal` is an injective function.
        fun spec_sha3_512_internal(bytes: vector<u8>): vector<u8>;
        axiom forall b1: vector<u8>, b2: vector<u8>:
            (spec_sha3_512_internal(b1) == spec_sha3_512_internal(b2) ==> b1 == b2);

        /// `spec_ripemd160_internal` is an injective function.
        fun spec_ripemd160_internal(bytes: vector<u8>): vector<u8>;
        axiom forall b1: vector<u8>, b2: vector<u8>:
            (spec_ripemd160_internal(b1) == spec_ripemd160_internal(b2) ==> b1 == b2);

        /// `spec_blake2b_256_internal` is an injective function.
        fun spec_blake2b_256_internal(bytes: vector<u8>): vector<u8>;
        axiom forall b1: vector<u8>, b2: vector<u8>:
            (spec_blake2b_256_internal(b1) == spec_blake2b_256_internal(b2) ==> b1 == b2);
    }

    spec sip_hash(bytes: vector<u8>): u64 {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_sip_hash(bytes);
    }

    spec sip_hash_from_value<MoveValue>(v: &MoveValue): u64 {
        pragma opaque;
        ensures result == spec_sip_hash(bcs::serialize(v));
    }

    spec keccak256(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_keccak256(bytes);
    }

    spec sha2_512_internal(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_sha2_512_internal(bytes);
    }

    spec sha3_512_internal(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_sha3_512_internal(bytes);
    }

    spec ripemd160_internal(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_ripemd160_internal(bytes);
    }

    spec sha2_512(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if !features::spec_is_enabled(features::SHA_512_AND_RIPEMD_160_NATIVES);
        ensures result == spec_sha2_512_internal(bytes);
    }

    spec sha3_512(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if !features::spec_is_enabled(features::SHA_512_AND_RIPEMD_160_NATIVES);
        ensures result == spec_sha3_512_internal(bytes);
    }

    spec ripemd160(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if !features::spec_is_enabled(features::SHA_512_AND_RIPEMD_160_NATIVES);
        ensures result == spec_ripemd160_internal(bytes);
    }

    spec blake2b_256_internal(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if false;
        ensures result == spec_blake2b_256_internal(bytes);
    }

    spec blake2b_256(bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if !features::spec_is_enabled(features::BLAKE2B_256_NATIVE);
        ensures result == spec_blake2b_256_internal(bytes);
    }

}


================================================
File: aptos-move/framework/aptos-stdlib/sources/math128.move
================================================
/// Standard math utilities missing in the Move Language.
module aptos_std::math128 {

    use std::fixed_point32::FixedPoint32;
    use std::fixed_point32;
    use aptos_std::fixed_point64::FixedPoint64;
    use aptos_std::fixed_point64;

    /// Cannot log2 the value 0
    const EINVALID_ARG_FLOOR_LOG2: u64 = 1;

    /// Return the largest of two numbers.
    public fun max(a: u128, b: u128): u128 {
        if (a >= b) a else b
    }

    /// Return the smallest of two numbers.
    public fun min(a: u128, b: u128): u128 {
        if (a < b) a else b
    }

    /// Return the average of two.
    public fun average(a: u128, b: u128): u128 {
        if (a < b) {
            a + (b - a) / 2
        } else {
            b + (a - b) / 2
        }
    }

    /// Return greatest common divisor of `a` & `b`, via the Euclidean algorithm.
    public inline fun gcd(a: u128, b: u128): u128 {
        let (large, small) = if (a > b) (a, b) else (b, a);
        while (small != 0) {
            let tmp = small;
            small = large % small;
            large = tmp;
        };
        large
    }

    /// Returns a * b / c going through u256 to prevent intermediate overflow
    public inline fun mul_div(a: u128, b: u128, c: u128): u128 {
        // Inline functions cannot take constants, as then every module using it needs the constant
        assert!(c != 0, std::error::invalid_argument(4));
        (((a as u256) * (b as u256) / (c as u256)) as u128)
    }

    /// Return x clamped to the interval [lower, upper].
    public fun clamp(x: u128, lower: u128, upper: u128): u128 {
        min(upper, max(lower, x))
    }

    /// Return the value of n raised to power e
    public fun pow(n: u128, e: u128): u128 {
        if (e == 0) {
            1
        } else {
            let p = 1;
            while (e > 1) {
                if (e % 2 == 1) {
                    p = p * n;
                };
                e = e / 2;
                n = n * n;
            };
            p * n
        }
    }

    /// Returns floor(log2(x))
    public fun floor_log2(x: u128): u8 {
        let res = 0;
        assert!(x != 0, std::error::invalid_argument(EINVALID_ARG_FLOOR_LOG2));
        // Effectively the position of the most significant set bit
        let n = 64;
        while (n > 0) {
            if (x >= (1 << n)) {
                x = x >> n;
                res = res + n;
            };
            n = n >> 1;
        };
        res
    }

    // Returns log2(x)
    public fun log2(x: u128): FixedPoint32 {
        let integer_part = floor_log2(x);
        // Normalize x to [1, 2) in fixed point 32.
        if (x >= 1 << 32) {
            x = x >> (integer_part - 32);
        } else {
            x = x << (32 - integer_part);
        };
        let frac = 0;
        let delta = 1 << 31;
        while (delta != 0) {
            // log x = 1/2 log x^2
            // x in [1, 2)
            x = (x * x) >> 32;
            // x is now in [1, 4)
            // if x in [2, 4) then log x = 1 + log (x / 2)
            if (x >= (2 << 32)) { frac = frac + delta; x = x >> 1; };
            delta = delta >> 1;
        };
        fixed_point32::create_from_raw_value (((integer_part as u64) << 32) + frac)
    }

    // Return log2(x) as FixedPoint64
    public fun log2_64(x: u128): FixedPoint64 {
        let integer_part = floor_log2(x);
        // Normalize x to [1, 2) in fixed point 63. To ensure x is smaller then 1<<64
        if (x >= 1 << 63) {
            x = x >> (integer_part - 63);
        } else {
            x = x << (63 - integer_part);
        };
        let frac = 0;
        let delta = 1 << 63;
        while (delta != 0) {
            // log x = 1/2 log x^2
            // x in [1, 2)
            x = (x * x) >> 63;
            // x is now in [1, 4)
            // if x in [2, 4) then log x = 1 + log (x / 2)
            if (x >= (2 << 63)) { frac = frac + delta; x = x >> 1; };
            delta = delta >> 1;
        };
        fixed_point64::create_from_raw_value (((integer_part as u128) << 64) + frac)
    }

    /// Returns square root of x, precisely floor(sqrt(x))
    public fun sqrt(x: u128): u128 {
        if (x == 0) return 0;
        // Note the plus 1 in the expression. Let n = floor_lg2(x) we have x in [2^n, 2^{n+1}) and thus the answer in
        // the half-open interval [2^(n/2), 2^{(n+1)/2}). For even n we can write this as [2^(n/2), sqrt(2) 2^{n/2})
        // for odd n [2^((n+1)/2)/sqrt(2), 2^((n+1)/2). For even n the left end point is integer for odd the right
        // end point is integer. If we choose as our first approximation the integer end point we have as maximum
        // relative error either (sqrt(2) - 1) or (1 - 1/sqrt(2)) both are smaller then 1/2.
        let res = 1 << ((floor_log2(x) + 1) >> 1);
        // We use standard newton-rhapson iteration to improve the initial approximation.
        // The error term evolves as delta_i+1 = delta_i^2 / 2 (quadratic convergence).
        // It turns out that after 5 iterations the delta is smaller than 2^-64 and thus below the treshold.
        res = (res + x / res) >> 1;
        res = (res + x / res) >> 1;
        res = (res + x / res) >> 1;
        res = (res + x / res) >> 1;
        res = (res + x / res) >> 1;
        min(res, x / res)
    }

    public inline fun ceil_div(x: u128, y: u128): u128 {
        // ceil_div(x, y) = floor((x + y - 1) / y) = floor((x - 1) / y) + 1
        // (x + y - 1) could spuriously overflow. so we use the later version
        if (x == 0) {
            // Inline functions cannot take constants, as then every module using it needs the constant
            assert!(y != 0, std::error::invalid_argument(4));
            0
        }
        else (x - 1) / y + 1
    }

    #[test]
    public entry fun test_ceil_div() {
        assert!(ceil_div(9, 3) == 3, 0);
        assert!(ceil_div(10, 3) == 4, 0);
        assert!(ceil_div(11, 3) == 4, 0);
        assert!(ceil_div(12, 3) == 4, 0);
        assert!(ceil_div(13, 3) == 5, 0);

        // No overflow
        assert!(ceil_div((((1u256<<128) - 9) as u128), 11) == 30934760629176223951215873402888019223, 0);
    }

    #[test]
    fun test_gcd() {
        assert!(gcd(20, 8) == 4, 0);
        assert!(gcd(8, 20) == 4, 0);
        assert!(gcd(1, 100) == 1, 0);
        assert!(gcd(100, 1) == 1, 0);
        assert!(gcd(210, 45) == 15, 0);
        assert!(gcd(45, 210) == 15, 0);
        assert!(gcd(0, 0) == 0, 0);
        assert!(gcd(1, 0) == 1, 0);
        assert!(gcd(50, 0) == 50, 0);
        assert!(gcd(0, 1) == 1, 0);
        assert!(gcd(0, 50) == 50, 0);
        assert!(gcd(54, 24) == 6, 0);
        assert!(gcd(24, 54) == 6, 0);
        assert!(gcd(10, 10) == 10, 0);
        assert!(gcd(1071, 462) == 21, 0);
        assert!(gcd(462, 1071) == 21, 0);
    }

    #[test]
    public entry fun test_max() {
        let result = max(3u128, 6u128);
        assert!(result == 6, 0);

        let result = max(15u128, 12u128);
        assert!(result == 15, 1);
    }

    #[test]
    public entry fun test_min() {
        let result = min(3u128, 6u128);
        assert!(result == 3, 0);

        let result = min(15u128, 12u128);
        assert!(result == 12, 1);
    }

    #[test]
    public entry fun test_average() {
        let result = average(3u128, 6u128);
        assert!(result == 4, 0);

        let result = average(15u128, 12u128);
        assert!(result == 13, 0);
    }

    #[test]
    public entry fun test_pow() {
        let result = pow(10u128, 18u128);
        assert!(result == 1000000000000000000, 0);

        let result = pow(10u128, 1u128);
        assert!(result == 10, 0);

        let result = pow(10u128, 0u128);
        assert!(result == 1, 0);
    }

    #[test]
    public entry fun test_mul_div() {
        let tmp: u128 = 1<<127;
        assert!(mul_div(tmp,tmp,tmp) == tmp, 0);

        assert!(mul_div(tmp,5,5) == tmp, 0);
        // Note that ordering other way is imprecise.
        assert!((tmp / 5) * 5 != tmp, 0);
    }

    #[test]
    #[expected_failure(abort_code = 0x10004, location = aptos_std::math128)]
    public entry fun test_mul_div_by_zero() {
        mul_div(1, 1, 0);
    }

    #[test]
    public entry fun test_floor_log2() {
        let idx: u8 = 0;
        while (idx < 128) {
            assert!(floor_log2(1<<idx) == idx, 0);
            idx = idx + 1;
        };
        idx = 1;
        while (idx <= 128) {
            assert!(floor_log2((((1u256<<idx) - 1) as u128)) == idx - 1, 0);
            idx = idx + 1;
        };
    }

    #[test]
    public entry fun test_log2() {
        let idx: u8 = 0;
        while (idx < 128) {
            let res = log2(1<<idx);
            assert!(fixed_point32::get_raw_value(res) == (idx as u64) << 32, 0);
            idx = idx + 1;
        };
        idx = 10;
        while (idx <= 128) {
            let res = log2((((1u256<<idx) - 1) as u128));
            // idx + log2 (1 - 1/2^idx) = idx + ln (1-1/2^idx)/ln2
            // Use 3rd order taylor to approximate expected result
            let expected = (idx as u128) << 32;
            let taylor1 = ((1 << 32) / ((1u256<<idx)) as u128);
            let taylor2 = (taylor1 * taylor1) >> 32;
            let taylor3 = (taylor2 * taylor1) >> 32;
            let expected = expected - ((taylor1 + taylor2 / 2 + taylor3 / 3) << 32) / 2977044472;
            // verify it matches to 8 significant digits
            assert_approx_the_same((fixed_point32::get_raw_value(res) as u128), expected, 8);
            idx = idx + 1;
        };
    }

    #[test]
    public entry fun test_log2_64() {
        let idx: u8 = 0;
        while (idx < 128) {
            let res = log2_64(1<<idx);
            assert!(fixed_point64::get_raw_value(res) == (idx as u128) << 64, 0);
            idx = idx + 1;
        };
        idx = 10;
        while (idx <= 128) {
            let res = log2_64((((1u256<<idx) - 1) as u128));
            // idx + log2 (1 - 1/2^idx) = idx + ln (1-1/2^idx)/ln2
            // Use 3rd order taylor to approximate expected result
            let expected = (idx as u256) << 64;
            let taylor1 = (1 << 64) / ((1u256<<idx));
            let taylor2 = (taylor1 * taylor1) >> 64;
            let taylor3 = (taylor2 * taylor1) >> 64;
            let taylor4 = (taylor3 * taylor1) >> 64;
            let expected = expected - ((taylor1 + taylor2 / 2 + taylor3 / 3 + taylor4 / 4) << 64) / 12786308645202655660;
            // verify it matches to 8 significant digits
            assert_approx_the_same(fixed_point64::get_raw_value(res), (expected as u128), 14);
            idx = idx + 1;
        };
    }

    #[test]
    public entry fun test_sqrt() {
        let result = sqrt(0);
        assert!(result == 0, 0);

        let result = sqrt(1);
        assert!(result == 1, 0);

        let result = sqrt(256);
        assert!(result == 16, 0);

        let result = sqrt(1<<126);
        assert!(result == 1<<63, 0);

        let result = sqrt((((1u256 << 128) - 1) as u128));
        assert!(result == (1u128 << 64) - 1, 0);

        let result = sqrt((1u128 << 127));
        assert!(result == 13043817825332782212, 0);

        let result = sqrt((1u128 << 127) - 1);
        assert!(result == 13043817825332782212, 0);
    }

    #[test_only]
    /// For functions that approximate a value it's useful to test a value is close
    /// to the most correct value up to last digit
    fun assert_approx_the_same(x: u128, y: u128, precission: u128) {
        if (x < y) {
            let tmp = x;
            x = y;
            y = tmp;
        };
        let mult = pow(10, precission);
        assert!((x - y) * mult < x, 0);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/math128.spec.move
================================================
spec aptos_std::math128 {

    spec max(a: u128, b: u128): u128 {
        aborts_if false;
        ensures a >= b ==> result == a;
        ensures a < b ==> result == b;
    }

    spec min(a: u128, b: u128): u128 {
        aborts_if false;
        ensures a < b ==> result == a;
        ensures a >= b ==> result == b;
    }

    spec average(a: u128, b: u128): u128 {
        pragma opaque;
        aborts_if false;
        ensures result == (a + b) / 2;
    }

    spec clamp(x: u128, lower: u128, upper: u128): u128 {
        requires (lower <= upper);
        aborts_if false;
        ensures (lower <=x && x <= upper) ==> result == x;
        ensures (x < lower) ==> result == lower;
        ensures (upper < x) ==> result == upper;
    }

    // The specs of `pow`, `floor_log2` and `sqrt` are validated with a smaller domain
    // in aptos-core/third_party/move/move-prover/tests/sources/functional/math8.move

    spec pow(n: u128, e: u128): u128 {
        pragma opaque;
        aborts_if [abstract] spec_pow(n, e) > MAX_U128;
        ensures [abstract] result == spec_pow(n, e);
    }

    spec floor_log2(x: u128): u8 {
        pragma opaque;
        aborts_if [abstract] x == 0;
        ensures [abstract] spec_pow(2, result) <= x;
        ensures [abstract] x < spec_pow(2, result+1);
    }

    spec sqrt(x: u128): u128 {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] x > 0 ==> result * result <= x;
        ensures [abstract] x > 0 ==> x < (result+1) * (result+1);
    }

    spec fun spec_pow(n: u128, e: u128): u128 {
        if (e == 0) {
            1
        }
        else {
            n * spec_pow(n, e-1)
        }
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/math64.move
================================================
/// Standard math utilities missing in the Move Language.
module aptos_std::math64 {

    use std::fixed_point32::FixedPoint32;
    use std::fixed_point32;

    /// Cannot log2 the value 0
    const EINVALID_ARG_FLOOR_LOG2: u64 = 1;

    /// Return the largest of two numbers.
    public fun max(a: u64, b: u64): u64 {
        if (a >= b) a else b
    }

    /// Return the smallest of two numbers.
    public fun min(a: u64, b: u64): u64 {
        if (a < b) a else b
    }

    /// Return the average of two.
    public fun average(a: u64, b: u64): u64 {
        if (a < b) {
            a + (b - a) / 2
        } else {
            b + (a - b) / 2
        }
    }

    /// Return greatest common divisor of `a` & `b`, via the Euclidean algorithm.
    public inline fun gcd(a: u64, b: u64): u64 {
        let (large, small) = if (a > b) (a, b) else (b, a);
        while (small != 0) {
            let tmp = small;
            small = large % small;
            large = tmp;
        };
        large
    }

    /// Returns a * b / c going through u128 to prevent intermediate overflow
    public inline fun mul_div(a: u64, b: u64, c: u64): u64 {
        // Inline functions cannot take constants, as then every module using it needs the constant
        assert!(c != 0, std::error::invalid_argument(4));
        (((a as u128) * (b as u128) / (c as u128)) as u64)
    }

    /// Return x clamped to the interval [lower, upper].
    public fun clamp(x: u64, lower: u64, upper: u64): u64 {
        min(upper, max(lower, x))
    }

    /// Return the value of n raised to power e
    public fun pow(n: u64, e: u64): u64 {
        if (e == 0) {
            1
        } else {
            let p = 1;
            while (e > 1) {
                if (e % 2 == 1) {
                    p = p * n;
                };
                e = e / 2;
                n = n * n;
            };
            p * n
        }
    }

    /// Returns floor(lg2(x))
    public fun floor_log2(x: u64): u8 {
        let res = 0;
        assert!(x != 0, std::error::invalid_argument(EINVALID_ARG_FLOOR_LOG2));
        // Effectively the position of the most significant set bit
        let n = 32;
        while (n > 0) {
            if (x >= (1 << n)) {
                x = x >> n;
                res = res + n;
            };
            n = n >> 1;
        };
        res
    }

    // Returns log2(x)
    public fun log2(x: u64): FixedPoint32 {
        let integer_part = floor_log2(x);
        // Normalize x to [1, 2) in fixed point 32.
        let y = (if (x >= 1 << 32) {
            x >> (integer_part - 32)
        } else {
            x << (32 - integer_part)
        } as u128);
        let frac = 0;
        let delta = 1 << 31;
        while (delta != 0) {
            // log x = 1/2 log x^2
            // x in [1, 2)
            y = (y * y) >> 32;
            // x is now in [1, 4)
            // if x in [2, 4) then log x = 1 + log (x / 2)
            if (y >= (2 << 32)) { frac = frac + delta; y = y >> 1; };
            delta = delta >> 1;
        };
        fixed_point32::create_from_raw_value (((integer_part as u64) << 32) + frac)
    }

    /// Returns square root of x, precisely floor(sqrt(x))
    public fun sqrt(x: u64): u64 {
        if (x == 0) return 0;
        // Note the plus 1 in the expression. Let n = floor_lg2(x) we have x in [2^n, 2^(n+1)> and thus the answer in
        // the half-open interval [2^(n/2), 2^((n+1)/2)>. For even n we can write this as [2^(n/2), sqrt(2) 2^(n/2)>
        // for odd n [2^((n+1)/2)/sqrt(2), 2^((n+1)/2>. For even n the left end point is integer for odd the right
        // end point is integer. If we choose as our first approximation the integer end point we have as maximum
        // relative error either (sqrt(2) - 1) or (1 - 1/sqrt(2)) both are smaller then 1/2.
        let res = 1 << ((floor_log2(x) + 1) >> 1);
        // We use standard newton-rhapson iteration to improve the initial approximation.
        // The error term evolves as delta_i+1 = delta_i^2 / 2 (quadratic convergence).
        // It turns out that after 4 iterations the delta is smaller than 2^-32 and thus below the treshold.
        res = (res + x / res) >> 1;
        res = (res + x / res) >> 1;
        res = (res + x / res) >> 1;
        res = (res + x / res) >> 1;
        min(res, x / res)
    }

    public inline fun ceil_div(x: u64, y: u64): u64 {
        // ceil_div(x, y) = floor((x + y - 1) / y) = floor((x - 1) / y) + 1
        // (x + y - 1) could spuriously overflow. so we use the later version
        if (x == 0) {
            // Inline functions cannot take constants, as then every module using it needs the constant
            assert!(y != 0, std::error::invalid_argument(4));
            0
        }
        else (x - 1) / y + 1
    }

    #[test]
    public entry fun test_ceil_div() {
        assert!(ceil_div(9, 3) == 3, 0);
        assert!(ceil_div(10, 3) == 4, 0);
        assert!(ceil_div(11, 3) == 4, 0);
        assert!(ceil_div(12, 3) == 4, 0);
        assert!(ceil_div(13, 3) == 5, 0);

        // No overflow
        assert!(ceil_div((((1u128<<64) - 9) as u64), 11) == 1676976733973595601, 0);
    }

    #[test]
    fun test_gcd() {
        assert!(gcd(20, 8) == 4, 0);
        assert!(gcd(8, 20) == 4, 0);
        assert!(gcd(1, 100) == 1, 0);
        assert!(gcd(100, 1) == 1, 0);
        assert!(gcd(210, 45) == 15, 0);
        assert!(gcd(45, 210) == 15, 0);
        assert!(gcd(0, 0) == 0, 0);
        assert!(gcd(1, 0) == 1, 0);
        assert!(gcd(50, 0) == 50, 0);
        assert!(gcd(0, 1) == 1, 0);
        assert!(gcd(0, 50) == 50, 0);
        assert!(gcd(54, 24) == 6, 0);
        assert!(gcd(24, 54) == 6, 0);
        assert!(gcd(10, 10) == 10, 0);
        assert!(gcd(1071, 462) == 21, 0);
        assert!(gcd(462, 1071) == 21, 0);
    }

    #[test]
    public entry fun test_max_64() {
        let result = max(3u64, 6u64);
        assert!(result == 6, 0);

        let result = max(15u64, 12u64);
        assert!(result == 15, 1);
    }

    #[test]
    public entry fun test_min() {
        let result = min(3u64, 6u64);
        assert!(result == 3, 0);

        let result = min(15u64, 12u64);
        assert!(result == 12, 1);
    }

    #[test]
    public entry fun test_average() {
        let result = average(3u64, 6u64);
        assert!(result == 4, 0);

        let result = average(15u64, 12u64);
        assert!(result == 13, 0);
    }

    #[test]
    public entry fun test_average_does_not_overflow() {
        let result = average(18446744073709551615, 18446744073709551615);
        assert!(result == 18446744073709551615, 0);
    }

    #[test]
    public entry fun test_pow() {
        let result = pow(10u64, 18u64);
        assert!(result == 1000000000000000000, 0);

        let result = pow(10u64, 1u64);
        assert!(result == 10, 0);

        let result = pow(10u64, 0u64);
        assert!(result == 1, 0);
    }

    #[test]
    public entry fun test_mul_div() {
        let tmp: u64 = 1<<63;
        assert!(mul_div(tmp,tmp,tmp) == tmp, 0);

        assert!(mul_div(tmp,5,5) == tmp, 0);
        // Note that ordering other way is imprecise.
        assert!((tmp / 5) * 5 != tmp, 0);
    }

    #[test]
    #[expected_failure(abort_code = 0x10004, location = aptos_std::math64)]
    public entry fun test_mul_div_by_zero() {
        mul_div(1, 1, 0);
    }

    #[test]
    public entry fun test_floor_lg2() {
        let idx: u8 = 0;
        while (idx < 64) {
            assert!(floor_log2(1<<idx) == idx, 0);
            idx = idx + 1;
        };
        idx = 1;
        while (idx <= 64) {
            assert!(floor_log2((((1u128<<idx) - 1) as u64)) == idx - 1, 0);
            idx = idx + 1;
        };
    }

    #[test]
    public entry fun test_log2() {
        let idx: u8 = 0;
        while (idx < 64) {
            let res = log2(1<<idx);
            assert!(fixed_point32::get_raw_value(res) == (idx as u64) << 32, 0);
            idx = idx + 1;
        };
        idx = 10;
        while (idx <= 64) {
            let res = log2((((1u128<<idx) - 1) as u64));
            // idx + log2 (1 - 1/2^idx) = idx + ln (1-1/2^idx)/ln2
            // Use 3rd order taylor to approximate expected result
            let expected = (idx as u128) << 32;
            let taylor1 = ((1 << 32) / ((1u256<<idx)) as u128);
            let taylor2 = (taylor1 * taylor1) >> 32;
            let taylor3 = (taylor2 * taylor1) >> 32;
            let expected = expected - ((taylor1 + taylor2 / 2 + taylor3 / 3) << 32) / 2977044472;
            // verify it matches to 8 significant digits
            assert_approx_the_same((fixed_point32::get_raw_value(res) as u128), expected, 8);
            idx = idx + 1;
        };
    }

    #[test]
    public entry fun test_sqrt() {
        let result = sqrt(0);
        assert!(result == 0, 0);

        let result = sqrt(1);
        assert!(result == 1, 0);

        let result = sqrt(256);
        assert!(result == 16, 0);

        let result = sqrt(1<<62);
        assert!(result == 1<<31, 0);

        let result = sqrt((((1u128 << 64) - 1) as u64));
        assert!(result == (1u64 << 32) - 1, 0);

        let result = sqrt((1u64 << 63));
        assert!(result == 3037000499, 0);

        let result = sqrt((1u64 << 63) - 1);
        assert!(result == 3037000499, 0);
    }

    #[test_only]
    /// For functions that approximate a value it's useful to test a value is close
    /// to the most correct value up to last digit
    fun assert_approx_the_same(x: u128, y: u128, precission: u64) {
        if (x < y) {
            let tmp = x;
            x = y;
            y = tmp;
        };
        let mult = (pow(10, precission) as u128);
        assert!((x - y) * mult < x, 0);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/math64.spec.move
================================================
spec aptos_std::math64 {

    spec max(a: u64, b: u64): u64 {
        aborts_if false;
        ensures a >= b ==> result == a;
        ensures a < b ==> result == b;
    }

    spec min(a: u64, b: u64): u64 {
        aborts_if false;
        ensures a < b ==> result == a;
        ensures a >= b ==> result == b;
    }

    spec average(a: u64, b: u64): u64 {
        pragma opaque;
        aborts_if false;
        ensures result == (a + b) / 2;
    }

    spec clamp(x: u64, lower: u64, upper: u64): u64 {
        requires (lower <= upper);
        aborts_if false;
        ensures (lower <=x && x <= upper) ==> result == x;
        ensures (x < lower) ==> result == lower;
        ensures (upper < x) ==> result == upper;
    }

    // The specs of `pow`, `floor_log2` and `sqrt` are validated with a smaller domain
    // in aptos-core/third_party/move/move-prover/tests/sources/functional/math8.move

    spec pow(n: u64, e: u64): u64 {
        pragma opaque;
        aborts_if [abstract] spec_pow(n, e) > MAX_U64;
        ensures [abstract] result == spec_pow(n, e);
    }

    spec floor_log2(x: u64): u8 {
        pragma opaque;
        aborts_if [abstract] x == 0;
        ensures [abstract] spec_pow(2, result) <= x;
        ensures [abstract] x < spec_pow(2, result+1);
    }

    spec sqrt(x: u64): u64 {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] x > 0 ==> result * result <= x;
        ensures [abstract] x > 0 ==> x < (result+1) * (result+1);
    }

    spec fun spec_pow(n: u64, e: u64): u64 {
        if (e == 0) {
            1
        }
        else {
            n * spec_pow(n, e-1)
        }
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/math_fixed.move
================================================
/// Standard math utilities missing in the Move Language.
module aptos_std::math_fixed {
    use std::fixed_point32;
    use std::fixed_point32::FixedPoint32;
    use aptos_std::math128;
    use aptos_std::math64;

    /// Abort code on overflow
    const EOVERFLOW_EXP: u64 = 1;

    /// Natural log 2 in 32 bit fixed point
    const LN2: u128 = 2977044472;  // ln(2) in fixed 32 representation
    const LN2_X_32: u64 = 32 * 2977044472;  // 32 * ln(2) in fixed 32 representation

    /// Square root of fixed point number
    public fun sqrt(x: FixedPoint32): FixedPoint32 {
        let y = (fixed_point32::get_raw_value(x) as u128);
        fixed_point32::create_from_raw_value((math128::sqrt(y << 32) as u64))
    }

    /// Exponent function with a precission of 9 digits.
    public fun exp(x: FixedPoint32): FixedPoint32 {
        let raw_value = (fixed_point32::get_raw_value(x) as u128);
        fixed_point32::create_from_raw_value((exp_raw(raw_value) as u64))
    }

    /// Because log2 is negative for values < 1 we instead return log2(x) + 32 which
    /// is positive for all values of x.
    public fun log2_plus_32(x: FixedPoint32): FixedPoint32 {
        let raw_value = (fixed_point32::get_raw_value(x) as u128);
        math128::log2(raw_value)
    }

    public fun ln_plus_32ln2(x: FixedPoint32): FixedPoint32 {
        let raw_value = (fixed_point32::get_raw_value(x) as u128);
        let x = (fixed_point32::get_raw_value(math128::log2(raw_value)) as u128);
        fixed_point32::create_from_raw_value((x * LN2 >> 32 as u64))
    }

    /// Integer power of a fixed point number
    public fun pow(x: FixedPoint32, n: u64): FixedPoint32 {
        let raw_value = (fixed_point32::get_raw_value(x) as u128);
        fixed_point32::create_from_raw_value((pow_raw(raw_value, (n as u128)) as u64))
    }

    /// Specialized function for x * y / z that omits intermediate shifting
    public fun mul_div(x: FixedPoint32, y: FixedPoint32, z: FixedPoint32): FixedPoint32 {
        let a = fixed_point32::get_raw_value(x);
        let b = fixed_point32::get_raw_value(y);
        let c = fixed_point32::get_raw_value(z);
        fixed_point32::create_from_raw_value (math64::mul_div(a, b, c))
    }

    // Calculate e^x where x and the result are fixed point numbers
    fun exp_raw(x: u128): u128 {
        // exp(x / 2^32) = 2^(x / (2^32 * ln(2))) = 2^(floor(x / (2^32 * ln(2))) + frac(x / (2^32 * ln(2))))
        let shift_long = x / LN2;
        assert!(shift_long <= 31, std::error::invalid_state(EOVERFLOW_EXP));
        let shift = (shift_long as u8);
        let remainder = x % LN2;
        // At this point we want to calculate 2^(remainder / ln2) << shift
        // ln2 = 595528 * 4999 which means
        let bigfactor = 595528;
        let exponent = remainder / bigfactor;
        let x = remainder % bigfactor;
        // 2^(remainder / ln2) = (2^(1/4999))^exponent * exp(x / 2^32)
        let roottwo = 4295562865;  // fixed point representation of 2^(1/4999)
        // This has an error of 5000 / 4 10^9 roughly 6 digits of precission
        let power = pow_raw(roottwo, exponent);
        let eps_correction = 1241009291;
        power = power + ((power * eps_correction * exponent) >> 64);
        // x is fixed point number smaller than 595528/2^32 < 0.00014 so we need only 2 tayler steps
        // to get the 6 digits of precission
        let taylor1 = (power * x) >> (32 - shift);
        let taylor2 = (taylor1 * x) >> 32;
        let taylor3 = (taylor2 * x) >> 32;
        (power << shift) + taylor1 + taylor2 / 2 + taylor3 / 6
    }

    // Calculate x to the power of n, where x and the result are fixed point numbers.
    fun pow_raw(x: u128, n: u128): u128 {
        let res: u256 = 1 << 64;
        x = x << 32;
        while (n != 0) {
            if (n & 1 != 0) {
                res = (res * (x as u256)) >> 64;
            };
            n = n >> 1;
            x = ((((x as u256) * (x as u256)) >> 64) as u128);
        };
        ((res >> 32) as u128)
    }

    #[test]
    public entry fun test_sqrt() {
        // Sqrt is based on math128::sqrt and thus most of the testing is done there.
        let fixed_base = 1 << 32;
        let result = sqrt(fixed_point32::create_from_u64(1));
        assert!(fixed_point32::get_raw_value(result) == fixed_base, 0);

        let result = sqrt(fixed_point32::create_from_u64(2));
        assert_approx_the_same((fixed_point32::get_raw_value(result) as u128), 6074001000, 9);
    }

    #[test]
    public entry fun test_exp() {
        let fixed_base = 1 << 32;
        let result = exp_raw(0);
        assert!(result == fixed_base, 0);

        let result = exp_raw(fixed_base);
        let e = 11674931554;  // e in 32 bit fixed point
        assert_approx_the_same(result, e, 9);

        let result = exp_raw(10 * fixed_base);
        let exp10 = 94602950235157;  // e^10 in 32 bit fixed point
        assert_approx_the_same(result, exp10, 9);
    }

    #[test]
    public entry fun test_pow() {
        // We use the case of exp
        let result = pow_raw(4295562865, 4999);
        assert_approx_the_same(result,  1 << 33, 6);
    }

    #[test_only]
    /// For functions that approximate a value it's useful to test a value is close
    /// to the most correct value up to last digit
    fun assert_approx_the_same(x: u128, y: u128, precission: u128) {
        if (x < y) {
            let tmp = x;
            x = y;
            y = tmp;
        };
        let mult = math128::pow(10, precission);
        assert!((x - y) * mult < x, 0);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/math_fixed64.move
================================================
/// Standard math utilities missing in the Move Language.

module aptos_std::math_fixed64 {
    use aptos_std::fixed_point64;
    use aptos_std::fixed_point64::FixedPoint64;
    use aptos_std::math128;

    /// Abort code on overflow
    const EOVERFLOW_EXP: u64 = 1;

    /// Natural log 2 in 32 bit fixed point
    const LN2: u256 = 12786308645202655660;  // ln(2) in fixed 64 representation

    /// Square root of fixed point number
    public fun sqrt(x: FixedPoint64): FixedPoint64 {
        let y = fixed_point64::get_raw_value(x);
        let z = (math128::sqrt(y) << 32 as u256);
        z = (z + ((y as u256) << 64) / z) >> 1;
        fixed_point64::create_from_raw_value((z as u128))
    }

    /// Exponent function with a precission of 9 digits.
    public fun exp(x: FixedPoint64): FixedPoint64 {
        let raw_value = (fixed_point64::get_raw_value(x) as u256);
        fixed_point64::create_from_raw_value((exp_raw(raw_value) as u128))
    }

    /// Because log2 is negative for values < 1 we instead return log2(x) + 64 which
    /// is positive for all values of x.
    public fun log2_plus_64(x: FixedPoint64): FixedPoint64 {
        let raw_value = (fixed_point64::get_raw_value(x) as u128);
        math128::log2_64(raw_value)
    }

    public fun ln_plus_32ln2(x: FixedPoint64): FixedPoint64 {
        let raw_value = fixed_point64::get_raw_value(x);
        let x = (fixed_point64::get_raw_value(math128::log2_64(raw_value)) as u256);
        fixed_point64::create_from_raw_value(((x * LN2) >> 64 as u128))
    }

    /// Integer power of a fixed point number
    public fun pow(x: FixedPoint64, n: u64): FixedPoint64 {
        let raw_value = (fixed_point64::get_raw_value(x) as u256);
        fixed_point64::create_from_raw_value((pow_raw(raw_value, (n as u128)) as u128))
    }

    /// Specialized function for x * y / z that omits intermediate shifting
    public fun mul_div(x: FixedPoint64, y: FixedPoint64, z: FixedPoint64): FixedPoint64 {
        let a = fixed_point64::get_raw_value(x);
        let b = fixed_point64::get_raw_value(y);
        let c = fixed_point64::get_raw_value(z);
        fixed_point64::create_from_raw_value (math128::mul_div(a, b, c))
    }

    // Calculate e^x where x and the result are fixed point numbers
    fun exp_raw(x: u256): u256 {
        // exp(x / 2^64) = 2^(x / (2^64 * ln(2))) = 2^(floor(x / (2^64 * ln(2))) + frac(x / (2^64 * ln(2))))
        let shift_long = x / LN2;
        assert!(shift_long <= 63, std::error::invalid_state(EOVERFLOW_EXP));
        let shift = (shift_long as u8);
        let remainder = x % LN2;
        // At this point we want to calculate 2^(remainder / ln2) << shift
        // ln2 = 580 * 22045359733108027
        let bigfactor = 22045359733108027;
        let exponent = remainder / bigfactor;
        let x = remainder % bigfactor;
        // 2^(remainder / ln2) = (2^(1/580))^exponent * exp(x / 2^64)
        let roottwo = 18468802611690918839;  // fixed point representation of 2^(1/580)
        // 2^(1/580) = roottwo(1 - eps), so the number we seek is roottwo^exponent (1 - eps * exponent)
        let power = pow_raw(roottwo, (exponent as u128));
        let eps_correction = 219071715585908898;
        power = power - ((power * eps_correction * exponent) >> 128);
        // x is fixed point number smaller than bigfactor/2^64 < 0.0011 so we need only 5 tayler steps
        // to get the 15 digits of precission
        let taylor1 = (power * x) >> (64 - shift);
        let taylor2 = (taylor1 * x) >> 64;
        let taylor3 = (taylor2 * x) >> 64;
        let taylor4 = (taylor3 * x) >> 64;
        let taylor5 = (taylor4 * x) >> 64;
        let taylor6 = (taylor5 * x) >> 64;
        (power << shift) + taylor1 + taylor2 / 2 + taylor3 / 6 + taylor4 / 24 + taylor5 / 120 + taylor6 / 720
    }

    // Calculate x to the power of n, where x and the result are fixed point numbers.
    fun pow_raw(x: u256, n: u128): u256 {
        let res: u256 = 1 << 64;
        while (n != 0) {
            if (n & 1 != 0) {
                res = (res * x) >> 64;
            };
            n = n >> 1;
            x = (x * x) >> 64;
        };
        res
    }

    #[test]
    public entry fun test_sqrt() {
        // Sqrt is based on math128::sqrt and thus most of the testing is done there.
        let fixed_base = 1 << 64;
        let result = sqrt(fixed_point64::create_from_u128(1));
        assert!(fixed_point64::get_raw_value(result) == fixed_base, 0);

        let result = sqrt(fixed_point64::create_from_u128(2));
        assert_approx_the_same((fixed_point64::get_raw_value(result) as u256), 26087635650665564424, 16);
    }

    #[test]
    public entry fun test_exp() {
        let fixed_base = 1 << 64;
        let result = exp_raw(0);
        assert!(result == fixed_base, 0);

        let result = exp_raw(fixed_base);
        let e = 50143449209799256682;  // e in 32 bit fixed point
        assert_approx_the_same(result, e, 16);

        let result = exp_raw(10 * fixed_base);
        let exp10 = 406316577365116946489258;  // e^10 in 32 bit fixed point
        assert_approx_the_same(result, exp10, 16);
    }

    #[test]
    public entry fun test_pow() {
        // We use the case of exp
        let result = pow_raw(18468802611690918839, 580);
        assert_approx_the_same(result,  1 << 65, 16);
    }

    #[test_only]
    /// For functions that approximate a value it's useful to test a value is close
    /// to the most correct value up to last digit
    fun assert_approx_the_same(x: u256, y: u256, precission: u128) {
        if (x < y) {
            let tmp = x;
            x = y;
            y = tmp;
        };
        let mult = (math128::pow(10, precission) as u256);
        assert!((x - y) * mult < x, 0);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/pool_u64.move
================================================
///
/// Simple module for tracking and calculating shares of a pool of coins. The shares are worth more as the total coins in
/// the pool increases. New shareholder can buy more shares or redeem their existing shares.
///
/// Example flow:
/// 1. Pool start outs empty.
/// 2. Shareholder A buys in with 1000 coins. A will receive 1000 shares in the pool. Pool now has 1000 total coins and
/// 1000 total shares.
/// 3. Pool appreciates in value from rewards and now has 2000 coins. A's 1000 shares are now worth 2000 coins.
/// 4. Shareholder B now buys in with 1000 coins. Since before the buy in, each existing share is worth 2 coins, B will
/// receive 500 shares in exchange for 1000 coins. Pool now has 1500 shares and 3000 coins.
/// 5. Pool appreciates in value from rewards and now has 6000 coins.
/// 6. A redeems 500 shares. Each share is worth 6000 / 1500 = 4. A receives 2000 coins. Pool has 4000 coins and 1000
/// shares left.
///
module aptos_std::pool_u64 {
    use aptos_std::simple_map::{Self, SimpleMap};
    use std::error;
    use std::vector;

    /// Shareholder not present in pool.
    const ESHAREHOLDER_NOT_FOUND: u64 = 1;
    /// There are too many shareholders in the pool.
    const ETOO_MANY_SHAREHOLDERS: u64 = 2;
    /// Cannot destroy non-empty pool.
    const EPOOL_IS_NOT_EMPTY: u64 = 3;
    /// Cannot redeem more shares than the shareholder has in the pool.
    const EINSUFFICIENT_SHARES: u64 = 4;
    /// Shareholder cannot have more than u64.max shares.
    const ESHAREHOLDER_SHARES_OVERFLOW: u64 = 5;
    /// Pool's total coins cannot exceed u64.max.
    const EPOOL_TOTAL_COINS_OVERFLOW: u64 = 6;
    /// Pool's total shares cannot exceed u64.max.
    const EPOOL_TOTAL_SHARES_OVERFLOW: u64 = 7;

    const MAX_U64: u64 = 18446744073709551615;

    struct Pool has store {
        shareholders_limit: u64,
        total_coins: u64,
        total_shares: u64,
        shares: SimpleMap<address, u64>,
        shareholders: vector<address>,
        // Default to 1. This can be used to minimize rounding errors when computing shares and coins amount.
        // However, users need to make sure the coins amount don't overflow when multiplied by the scaling factor.
        scaling_factor: u64,
    }

    /// Create a new pool.
    public fun new(shareholders_limit: u64): Pool {
        // Default to a scaling factor of 1 (effectively no scaling).
        create_with_scaling_factor(shareholders_limit, 1)
    }

    #[deprecated]
    /// Deprecated. Use `new` instead.
    /// Create a new pool.
    public fun create(shareholders_limit: u64): Pool {
        new(shareholders_limit)
    }

    /// Create a new pool with custom `scaling_factor`.
    public fun create_with_scaling_factor(shareholders_limit: u64, scaling_factor: u64): Pool {
        Pool {
            shareholders_limit,
            total_coins: 0,
            total_shares: 0,
            shares: simple_map::create<address, u64>(),
            shareholders: vector::empty<address>(),
            scaling_factor,
        }
    }

    /// Destroy an empty pool. This will fail if the pool has any balance of coins.
    public fun destroy_empty(pool: Pool) {
        assert!(pool.total_coins == 0, error::invalid_state(EPOOL_IS_NOT_EMPTY));
        let Pool {
            shareholders_limit: _,
            total_coins: _,
            total_shares: _,
            shares: _,
            shareholders: _,
            scaling_factor: _,
        } = pool;
    }

    /// Return `pool`'s total balance of coins.
    public fun total_coins(pool: &Pool): u64 {
        pool.total_coins
    }

    /// Return the total number of shares across all shareholders in `pool`.
    public fun total_shares(pool: &Pool): u64 {
        pool.total_shares
    }

    /// Return true if `shareholder` is in `pool`.
    public fun contains(pool: &Pool, shareholder: address): bool {
        simple_map::contains_key(&pool.shares, &shareholder)
    }

    /// Return the number of shares of `stakeholder` in `pool`.
    public fun shares(pool: &Pool, shareholder: address): u64 {
        if (contains(pool, shareholder)) {
            *simple_map::borrow(&pool.shares, &shareholder)
        } else {
            0
        }
    }

    /// Return the balance in coins of `shareholder` in `pool.`
    public fun balance(pool: &Pool, shareholder: address): u64 {
        let num_shares = shares(pool, shareholder);
        shares_to_amount(pool, num_shares)
    }

    /// Return the list of shareholders in `pool`.
    public fun shareholders(pool: &Pool): vector<address> {
        pool.shareholders
    }

    /// Return the number of shareholders in `pool`.
    public fun shareholders_count(pool: &Pool): u64 {
        vector::length(&pool.shareholders)
    }

    /// Update `pool`'s total balance of coins.
    public fun update_total_coins(pool: &mut Pool, new_total_coins: u64) {
        pool.total_coins = new_total_coins;
    }

    /// Allow an existing or new shareholder to add their coins to the pool in exchange for new shares.
    public fun buy_in(pool: &mut Pool, shareholder: address, coins_amount: u64): u64 {
        if (coins_amount == 0) return 0;

        let new_shares = amount_to_shares(pool, coins_amount);
        assert!(MAX_U64 - pool.total_coins >= coins_amount, error::invalid_argument(EPOOL_TOTAL_COINS_OVERFLOW));
        assert!(MAX_U64 - pool.total_shares >= new_shares, error::invalid_argument(EPOOL_TOTAL_COINS_OVERFLOW));

        pool.total_coins = pool.total_coins + coins_amount;
        pool.total_shares = pool.total_shares + new_shares;
        add_shares(pool, shareholder, new_shares);
        new_shares
    }

    /// Add the number of shares directly for `shareholder` in `pool`.
    /// This would dilute other shareholders if the pool's balance of coins didn't change.
    fun add_shares(pool: &mut Pool, shareholder: address, new_shares: u64): u64 {
        if (contains(pool, shareholder)) {
            let existing_shares = simple_map::borrow_mut(&mut pool.shares, &shareholder);
            let current_shares = *existing_shares;
            assert!(MAX_U64 - current_shares >= new_shares, error::invalid_argument(ESHAREHOLDER_SHARES_OVERFLOW));

            *existing_shares = current_shares + new_shares;
            *existing_shares
        } else if (new_shares > 0) {
            assert!(
                vector::length(&pool.shareholders) < pool.shareholders_limit,
                error::invalid_state(ETOO_MANY_SHAREHOLDERS),
            );

            vector::push_back(&mut pool.shareholders, shareholder);
            simple_map::add(&mut pool.shares, shareholder, new_shares);
            new_shares
        } else {
            new_shares
        }
    }

    /// Allow `shareholder` to redeem their shares in `pool` for coins.
    public fun redeem_shares(pool: &mut Pool, shareholder: address, shares_to_redeem: u64): u64 {
        assert!(contains(pool, shareholder), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));
        assert!(shares(pool, shareholder) >= shares_to_redeem, error::invalid_argument(EINSUFFICIENT_SHARES));

        if (shares_to_redeem == 0) return 0;

        let redeemed_coins = shares_to_amount(pool, shares_to_redeem);
        pool.total_coins = pool.total_coins - redeemed_coins;
        pool.total_shares = pool.total_shares - shares_to_redeem;
        deduct_shares(pool, shareholder, shares_to_redeem);

        redeemed_coins
    }

    /// Transfer shares from `shareholder_1` to `shareholder_2`.
    public fun transfer_shares(
        pool: &mut Pool,
        shareholder_1: address,
        shareholder_2: address,
        shares_to_transfer: u64,
    ) {
        assert!(contains(pool, shareholder_1), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));
        assert!(shares(pool, shareholder_1) >= shares_to_transfer, error::invalid_argument(EINSUFFICIENT_SHARES));
        if (shares_to_transfer == 0) return;

        deduct_shares(pool, shareholder_1, shares_to_transfer);
        add_shares(pool, shareholder_2, shares_to_transfer);
    }

    /// Directly deduct `shareholder`'s number of shares in `pool` and return the number of remaining shares.
    fun deduct_shares(pool: &mut Pool, shareholder: address, num_shares: u64): u64 {
        assert!(contains(pool, shareholder), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));
        assert!(shares(pool, shareholder) >= num_shares, error::invalid_argument(EINSUFFICIENT_SHARES));

        let existing_shares = simple_map::borrow_mut(&mut pool.shares, &shareholder);
        *existing_shares = *existing_shares - num_shares;

        // Remove the shareholder completely if they have no shares left.
        let remaining_shares = *existing_shares;
        if (remaining_shares == 0) {
            let (_, shareholder_index) = vector::index_of(&pool.shareholders, &shareholder);
            vector::remove(&mut pool.shareholders, shareholder_index);
            simple_map::remove(&mut pool.shares, &shareholder);
        };

        remaining_shares
    }

    /// Return the number of new shares `coins_amount` can buy in `pool`.
    /// `amount` needs to big enough to avoid rounding number.
    public fun amount_to_shares(pool: &Pool, coins_amount: u64): u64 {
        amount_to_shares_with_total_coins(pool, coins_amount, pool.total_coins)
    }

    /// Return the number of new shares `coins_amount` can buy in `pool` with a custom total coins number.
    /// `amount` needs to big enough to avoid rounding number.
    public fun amount_to_shares_with_total_coins(pool: &Pool, coins_amount: u64, total_coins: u64): u64 {
        // No shares yet so amount is worth the same number of shares.
        if (pool.total_coins == 0 || pool.total_shares == 0) {
            // Multiply by scaling factor to minimize rounding errors during internal calculations for buy ins/redeems.
            // This can overflow but scaling factor is expected to be chosen carefully so this would not overflow.
            coins_amount * pool.scaling_factor
        } else {
            // Shares price = total_coins / total existing shares.
            // New number of shares = new_amount / shares_price = new_amount * existing_shares / total_amount.
            // We rearrange the calc and do multiplication first to avoid rounding errors.
            multiply_then_divide(pool, coins_amount, pool.total_shares, total_coins)
        }
    }

    /// Return the number of coins `shares` are worth in `pool`.
    /// `shares` needs to big enough to avoid rounding number.
    public fun shares_to_amount(pool: &Pool, shares: u64): u64 {
        shares_to_amount_with_total_coins(pool, shares, pool.total_coins)
    }

    /// Return the number of coins `shares` are worth in `pool` with a custom total coins number.
    /// `shares` needs to big enough to avoid rounding number.
    public fun shares_to_amount_with_total_coins(pool: &Pool, shares: u64, total_coins: u64): u64 {
        // No shares or coins yet so shares are worthless.
        if (pool.total_coins == 0 || pool.total_shares == 0) {
            0
        } else {
            // Shares price = total_coins / total existing shares.
            // Shares worth = shares * shares price = shares * total_coins / total existing shares.
            // We rearrange the calc and do multiplication first to avoid rounding errors.
            multiply_then_divide(pool, shares, total_coins, pool.total_shares)
        }
    }

    public fun multiply_then_divide(_pool: &Pool, x: u64, y: u64, z: u64): u64 {
        let result = (to_u128(x) * to_u128(y)) / to_u128(z);
        (result as u64)
    }

    fun to_u128(num: u64): u128 {
        (num as u128)
    }

    #[test_only]
    public fun destroy_pool(pool: Pool) {
        let Pool {
            shareholders_limit: _,
            total_coins: _,
            total_shares: _,
            shares: _,
            shareholders: _,
            scaling_factor: _,
        } = pool;
    }

    #[test]
    public entry fun test_buy_in_and_redeem() {
        let pool = new(5);

        // Shareholders 1 and 2 buy in first.
        buy_in(&mut pool, @1, 1000);
        buy_in(&mut pool, @2, 2000);
        assert!(shareholders_count(&pool) == 2, 0);
        assert!(total_coins(&pool) == 3000, 1);
        assert!(total_shares(&pool) == 3000, 2);
        assert!(shares(&pool, @1) == 1000, 3);
        assert!(shares(&pool, @2) == 2000, 4);
        assert!(balance(&pool, @1) == 1000, 5);
        assert!(balance(&pool, @2) == 2000, 6);

        // Pool increases in value.
        update_total_coins(&mut pool, 5000);
        assert!(shares(&pool, @1) == 1000, 7);
        assert!(shares(&pool, @2) == 2000, 8);
        let expected_balance_1 = 1000 * 5000 / 3000;
        assert!(balance(&pool, @1) == expected_balance_1, 9);
        let expected_balance_2 = 2000 * 5000 / 3000;
        assert!(balance(&pool, @2) == expected_balance_2, 10);

        // Shareholder 3 buys in into the 5000-coin pool with 1000 coins. There are 3000 existing shares.
        let expected_shares = 1000 * 3000 / 5000;
        buy_in(&mut pool, @3, 1000);
        assert!(shares(&pool, @3) == expected_shares, 11);
        assert!(balance(&pool, @3) == 1000, 12);

        // Pool increases more in value.
        update_total_coins(&mut pool, 8000);

        // Shareholders 1 and 2 redeem.
        let all_shares = 3000 + expected_shares;
        assert!(total_shares(&pool) == all_shares, 13);
        let expected_value_per_500_shares = 500 * 8000 / all_shares;
        assert!(redeem_shares(&mut pool, @1, 500) == expected_value_per_500_shares, 14);
        assert!(redeem_shares(&mut pool, @1, 500) == expected_value_per_500_shares, 15);
        assert!(redeem_shares(&mut pool, @2, 2000) == expected_value_per_500_shares * 4, 16);

        // Due to a very small rounding error of 1, shareholder 3 actually has 1 more coin.
        let shareholder_3_balance = expected_value_per_500_shares * 6 / 5 + 1;
        assert!(balance(&pool, @3) == shareholder_3_balance, 17);
        assert!(total_coins(&pool) == shareholder_3_balance, 18);
        assert!(shareholders_count(&pool) == 1, 19);
        let num_shares_3 = shares(&pool, @3);
        assert!(redeem_shares(&mut pool, @3, num_shares_3) == shareholder_3_balance, 20);

        // Nothing left.
        assert!(shareholders_count(&pool) == 0, 21);
        destroy_empty(pool);
    }

    #[test]
    #[expected_failure(abort_code = 196611, location = Self)]
    public entry fun test_destroy_empty_should_fail_if_not_empty() {
        let pool = new(1);
        update_total_coins(&mut pool, 100);
        destroy_empty(pool);
    }

    #[test]
    public entry fun test_buy_in_and_redeem_large_numbers() {
        let pool = new(2);
        let half_max_u64 = MAX_U64 / 2;
        let shares_1 = buy_in(&mut pool, @1, half_max_u64);
        assert!(shares_1 == half_max_u64, 0);
        let shares_2 = buy_in(&mut pool, @2, half_max_u64 + 1);
        assert!(shares_2 == half_max_u64 + 1, 1);
        assert!(total_shares(&pool) == MAX_U64, 2);
        assert!(total_coins(&pool) == MAX_U64, 3);
        assert!(redeem_shares(&mut pool, @1, shares_1) == half_max_u64, 4);
        assert!(redeem_shares(&mut pool, @2, shares_2) == half_max_u64 + 1, 5);
        destroy_empty(pool);
    }

    #[test]
    public entry fun test_buy_in_and_redeem_large_numbers_with_scaling_factor() {
        let scaling_factor = 100;
        let pool = create_with_scaling_factor(2, scaling_factor);
        let coins_amount = MAX_U64 / 100;
        let shares = buy_in(&mut pool, @1, coins_amount);
        assert!(total_shares(&pool) == coins_amount * scaling_factor, 0);
        assert!(total_coins(&pool) == coins_amount, 1);
        assert!(redeem_shares(&mut pool, @1, shares) == coins_amount, 2);
        destroy_empty(pool);
    }

    #[test]
    public entry fun test_buy_in_zero_amount() {
        let pool = new(2);
        buy_in(&mut pool, @1, 100);
        assert!(buy_in(&mut pool, @2, 0) == 0, 0);
        assert!(total_shares(&pool) == shares(&pool, @1), 1);
        assert!(shareholders_count(&pool) == 1, 2);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_buy_in_with_small_coins_amount() {
        let pool = new(2);
        // Shareholder 1 buys in with 1e17 coins.
        buy_in(&mut pool, @1, 100000000000000000);
        // Shareholder 2 buys in with a very small amount.
        assert!(buy_in(&mut pool, @2, 1) == 1, 0);
        // Pool's total coins increases by 20%. Shareholder 2 shouldn't see any actual balance increase as it gets
        // rounded down.
        let total_coins = total_coins(&pool);
        update_total_coins(&mut pool, total_coins * 6 / 5);
        // Minus 1 due to rounding error.
        assert!(balance(&pool, @1) == 100000000000000000 * 6 / 5 - 1, 1);
        assert!(balance(&pool, @2) == 1, 2);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_add_zero_shares_should_not_add_shareholder() {
        let pool = new(1);
        update_total_coins(&mut pool, 1000);
        assert!(add_shares(&mut pool, @1, 0) == 0, 0);
        assert!(shareholders_count(&pool) == 0, 1);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_add_zero_shares_returns_existing_number_of_shares() {
        let pool = new(1);
        update_total_coins(&mut pool, 1000);
        add_shares(&mut pool, @1, 1);
        assert!(shares(&pool, @1) == add_shares(&mut pool, @1, 0), 0);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_add_shares_existing_shareholder() {
        let pool = new(1);
        update_total_coins(&mut pool, 1000);
        add_shares(&mut pool, @1, 1);
        add_shares(&mut pool, @1, 2);
        assert!(shares(&mut pool, @1) == 3, 0);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_add_shares_new_shareholder() {
        let pool = new(2);
        update_total_coins(&mut pool, 1000);
        add_shares(&mut pool, @1, 1);
        add_shares(&mut pool, @2, 2);
        assert!(shares(&mut pool, @1) == 1, 0);
        assert!(shares(&mut pool, @2) == 2, 1);
        destroy_pool(pool);
    }

    #[test]
    #[expected_failure(abort_code = 196610, location = Self)]
    public entry fun test_add_shares_should_enforce_shareholder_limit() {
        let pool = new(2);
        add_shares(&mut pool, @1, 1);
        add_shares(&mut pool, @2, 2);
        add_shares(&mut pool, @3, 2);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_add_shares_should_work_after_reducing_shareholders_below_limit() {
        let pool = new(3);
        add_shares(&mut pool, @1, 1);
        add_shares(&mut pool, @2, 2);
        deduct_shares(&mut pool, @2, 2);
        add_shares(&mut pool, @3, 3);
        assert!(shares(&pool, @3) == 3, 0);
        destroy_pool(pool);
    }

    #[test]
    #[expected_failure(abort_code = 65537, location = Self)]
    public entry fun test_redeem_shares_non_existent_shareholder() {
        let pool = new(1);
        add_shares(&mut pool, @1, 1);
        redeem_shares(&mut pool, @2, 1);
        destroy_pool(pool);
    }

    #[test]
    #[expected_failure(abort_code = 65540, location = Self)]
    public entry fun test_redeem_shares_insufficient_shares() {
        let pool = new(1);
        add_shares(&mut pool, @1, 1);
        redeem_shares(&mut pool, @1, 2);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_redeem_small_number_of_shares() {
        let pool = new(2);
        // 1e17 shares and coins.
        buy_in(&mut pool, @1, 100000000000000000);
        buy_in(&mut pool, @2, 100000000000000000);
        assert!(redeem_shares(&mut pool, @1, 1) == 1, 0);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_redeem_zero_shares() {
        let pool = new(2);
        buy_in(&mut pool, @1, 1);
        assert!(redeem_shares(&mut pool, @1, 0) == 0, 0);
        assert!(shares(&pool, @1) == 1, 1);
        assert!(total_coins(&pool) == 1, 2);
        assert!(total_shares(&pool) == 1, 3);
        destroy_pool(pool);
    }

    #[test]
    #[expected_failure(abort_code = 65537, location = Self)]
    public entry fun test_deduct_shares_non_existent_shareholder() {
        let pool = new(1);
        add_shares(&mut pool, @1, 1);
        deduct_shares(&mut pool, @2, 1);
        destroy_pool(pool);
    }

    #[test]
    #[expected_failure(abort_code = 65540, location = Self)]
    public entry fun test_deduct_shares_insufficient_shares() {
        let pool = new(1);
        add_shares(&mut pool, @1, 1);
        deduct_shares(&mut pool, @1, 2);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_deduct_shares_remove_shareholder_with_no_shares() {
        let pool = new(2);
        add_shares(&mut pool, @1, 1);
        add_shares(&mut pool, @2, 2);
        assert!(shareholders_count(&pool) == 2, 0);
        deduct_shares(&mut pool, @1, 1);
        assert!(shareholders_count(&pool) == 1, 1);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_transfer_shares() {
        let pool = new(2);
        add_shares(&mut pool, @1, 2);
        add_shares(&mut pool, @2, 2);
        assert!(shareholders_count(&pool) == 2, 0);
        transfer_shares(&mut pool, @1, @2, 1);
        assert!(shares(&pool, @1) == 1, 0);
        assert!(shares(&pool, @2) == 3, 0);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_amount_to_shares_empty_pool() {
        let pool = new(1);
        // No total shares and total coins.
        assert!(amount_to_shares(&pool, 1000) == 1000, 0);

        // No total shares but some total coins.
        update_total_coins(&mut pool, 1000);
        assert!(amount_to_shares(&pool, 1000) == 1000, 1);

        // No total coins but some total shares.
        update_total_coins(&mut pool, 0);
        add_shares(&mut pool, @1, 100);
        assert!(amount_to_shares(&pool, 1000) == 1000, 2);
        destroy_pool(pool);
    }

    #[test]
    public entry fun test_shares_to_amount_empty_pool() {
        let pool = new(1);
        // No total shares and total coins.
        assert!(shares_to_amount(&pool, 1000) == 0, 0);

        // No total shares but some total coins.
        update_total_coins(&mut pool, 1000);
        assert!(shares_to_amount(&pool, 1000) == 0, 1);

        // No total coins but some total shares.
        update_total_coins(&mut pool, 0);
        add_shares(&mut pool, @1, 100);
        assert!(shares_to_amount(&pool, 1000) == 0, 2);
        destroy_pool(pool);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/pool_u64.spec.move
================================================
// This file specifies the module `pool_u64`. It specifies the invariants of the struct Pool, and the pre/post-conditions
// of the functions.
spec aptos_std::pool_u64 {

    spec module {
        // TODO: Disabled due to the issue with the data invariant verification
        pragma verify = false;
    }
    // -----------------
    // Struct invariants
    // -----------------

    // The invariants of the struct Pool.
    spec Pool {
        // `shares` contains the key `addr` if and only if `shareholders` contains `addr.
        invariant forall addr: address:
            (simple_map::spec_contains_key(shares, addr) == vector::spec_contains(shareholders, addr));

        // `shareholders` does not contain duplicates.
        invariant forall i in 0..len(shareholders), j in 0..len(shareholders):
            shareholders[i] == shareholders[j] ==> i == j;
    }


    // -----------------------
    // Function specifications
    // -----------------------

    spec fun spec_contains(pool: Pool, shareholder: address): bool {
        simple_map::spec_contains_key(pool.shares, shareholder)
    }

    spec contains(pool: &Pool, shareholder: address): bool {
        aborts_if false;
        ensures result == spec_contains(pool, shareholder);
    }

    spec fun spec_shares(pool: Pool, shareholder: address): u64 {
        if (simple_map::spec_contains_key(pool.shares, shareholder)) {
            simple_map::spec_get(pool.shares, shareholder)
        }
        else {
            0
        }
    }

    spec shares(pool: &Pool, shareholder: address): u64 {
        aborts_if false;
        ensures result == spec_shares(pool, shareholder);
    }

    spec balance(pool: &Pool, shareholder: address): u64 {
        let shares = spec_shares(pool, shareholder);
        let total_coins = pool.total_coins;
        aborts_if pool.total_coins > 0 && pool.total_shares > 0 && (shares * total_coins) / pool.total_shares > MAX_U64;
        ensures result == spec_shares_to_amount_with_total_coins(pool, shares, total_coins);
    }

    spec buy_in(pool: &mut Pool, shareholder: address, coins_amount: u64): u64 {
        let new_shares = spec_amount_to_shares_with_total_coins(pool, coins_amount, pool.total_coins);
        aborts_if pool.total_coins + coins_amount > MAX_U64;
        aborts_if pool.total_shares + new_shares > MAX_U64;
        include coins_amount > 0 ==> AddSharesAbortsIf { new_shares: new_shares };
        include coins_amount > 0 ==> AddSharesEnsures { new_shares: new_shares };
        ensures pool.total_coins == old(pool.total_coins) + coins_amount;
        ensures pool.total_shares == old(pool.total_shares) + new_shares;
        ensures result == new_shares;
    }

    spec add_shares(pool: &mut Pool, shareholder: address, new_shares: u64): u64 {
        include AddSharesAbortsIf;
        include AddSharesEnsures;

        let key_exists = simple_map::spec_contains_key(pool.shares, shareholder);
        ensures result == if (key_exists) { simple_map::spec_get(pool.shares, shareholder) }
        else { new_shares };
    }
    spec schema AddSharesAbortsIf {
        pool: Pool;
        shareholder: address;
        new_shares: u64;

        let key_exists = simple_map::spec_contains_key(pool.shares, shareholder);
        let current_shares = simple_map::spec_get(pool.shares, shareholder);

        aborts_if key_exists && current_shares + new_shares > MAX_U64;
        aborts_if !key_exists && new_shares > 0 && len(pool.shareholders) >= pool.shareholders_limit;
    }
    spec schema AddSharesEnsures {
        pool: Pool;
        shareholder: address;
        new_shares: u64;

        let key_exists = simple_map::spec_contains_key(pool.shares, shareholder);
        let current_shares = simple_map::spec_get(pool.shares, shareholder);

        ensures key_exists ==>
            pool.shares == simple_map::spec_set(old(pool.shares), shareholder, current_shares + new_shares);
        ensures (!key_exists && new_shares > 0) ==>
            pool.shares == simple_map::spec_set(old(pool.shares), shareholder, new_shares);
        ensures (!key_exists && new_shares > 0) ==>
            vector::eq_push_back(pool.shareholders, old(pool.shareholders), shareholder);
    }

    spec fun spec_amount_to_shares_with_total_coins(pool: Pool, coins_amount: u64, total_coins: u64): u64 {
        if (pool.total_coins == 0 || pool.total_shares == 0) {
            coins_amount * pool.scaling_factor
        }
        else {
            (coins_amount * pool.total_shares) / total_coins
        }
    }

    spec amount_to_shares_with_total_coins(pool: &Pool, coins_amount: u64, total_coins: u64): u64 {
        aborts_if pool.total_coins > 0 && pool.total_shares > 0
            && (coins_amount * pool.total_shares) / total_coins > MAX_U64;
        aborts_if (pool.total_coins == 0 || pool.total_shares == 0)
            && coins_amount * pool.scaling_factor > MAX_U64;
        aborts_if pool.total_coins > 0 && pool.total_shares > 0 && total_coins == 0;
        ensures result == spec_amount_to_shares_with_total_coins(pool, coins_amount, total_coins);
    }

    spec shares_to_amount_with_total_coins(pool: &Pool, shares: u64, total_coins: u64): u64 {
        aborts_if pool.total_coins > 0 && pool.total_shares > 0
            && (shares * total_coins) / pool.total_shares > MAX_U64;
        ensures result == spec_shares_to_amount_with_total_coins(pool, shares, total_coins);
    }

    spec fun spec_shares_to_amount_with_total_coins(pool: Pool, shares: u64, total_coins: u64): u64 {
        if (pool.total_coins == 0 || pool.total_shares == 0) {
            0
        }
        else {
            (shares * total_coins) / pool.total_shares
        }
    }

    spec multiply_then_divide(_pool: &Pool, x: u64, y: u64, z: u64): u64 {
        aborts_if z == 0;
        aborts_if (x * y) / z > MAX_U64;
        ensures result == (x * y) / z;
    }

    spec redeem_shares(pool: &mut Pool, shareholder: address, shares_to_redeem: u64): u64 {
        let redeemed_coins = spec_shares_to_amount_with_total_coins(pool, shares_to_redeem, pool.total_coins);
        aborts_if !spec_contains(pool, shareholder);
        aborts_if spec_shares(pool, shareholder) < shares_to_redeem;
        aborts_if pool.total_coins < redeemed_coins;
        aborts_if pool.total_shares < shares_to_redeem;
        ensures pool.total_coins == old(pool.total_coins) - redeemed_coins;
        ensures pool.total_shares == old(pool.total_shares) - shares_to_redeem;
        include shares_to_redeem > 0 ==> DeductSharesEnsures { num_shares: shares_to_redeem };
        ensures result == redeemed_coins;
    }

    spec transfer_shares(
        pool: &mut Pool,
        shareholder_1: address,
        shareholder_2: address,
        shares_to_transfer: u64
    ) {
        pragma aborts_if_is_partial;
        aborts_if !spec_contains(pool, shareholder_1);
        aborts_if spec_shares(pool, shareholder_1) < shares_to_transfer;
        // TODO: difficult to specify due to the intermediate state problem.
    }

    spec deduct_shares(pool: &mut Pool, shareholder: address, num_shares: u64): u64 {
        aborts_if !spec_contains(pool, shareholder);
        aborts_if spec_shares(pool, shareholder) < num_shares;

        include DeductSharesEnsures;
        let remaining_shares = simple_map::spec_get(pool.shares, shareholder) - num_shares;
        ensures remaining_shares > 0 ==> result == simple_map::spec_get(pool.shares, shareholder);
        ensures remaining_shares == 0 ==> result == 0;
    }
    spec schema DeductSharesEnsures {
        pool: Pool;
        shareholder: address;
        num_shares: u64;
        let remaining_shares = simple_map::spec_get(pool.shares, shareholder) - num_shares;
        ensures remaining_shares > 0 ==> simple_map::spec_get(pool.shares, shareholder) == remaining_shares;
        ensures remaining_shares == 0 ==> !simple_map::spec_contains_key(pool.shares, shareholder);
        ensures remaining_shares == 0 ==> !vector::spec_contains(pool.shareholders, shareholder);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/pool_u64_unbound.move
================================================
///
/// Simple module for tracking and calculating shares of a pool of coins. The shares are worth more as the total coins in
/// the pool increases. New shareholder can buy more shares or redeem their existing shares.
///
/// Example flow:
/// 1. Pool start outs empty.
/// 2. Shareholder A buys in with 1000 coins. A will receive 1000 shares in the pool. Pool now has 1000 total coins and
/// 1000 total shares.
/// 3. Pool appreciates in value from rewards and now has 2000 coins. A's 1000 shares are now worth 2000 coins.
/// 4. Shareholder B now buys in with 1000 coins. Since before the buy in, each existing share is worth 2 coins, B will
/// receive 500 shares in exchange for 1000 coins. Pool now has 1500 shares and 3000 coins.
/// 5. Pool appreciates in value from rewards and now has 6000 coins.
/// 6. A redeems 500 shares. Each share is worth 6000 / 1500 = 4. A receives 2000 coins. Pool has 4000 coins and 1000
/// shares left.
///
module aptos_std::pool_u64_unbound {
    use aptos_std::table_with_length::{Self as table, TableWithLength as Table};
    use std::error;

    /// Shareholder not present in pool.
    const ESHAREHOLDER_NOT_FOUND: u64 = 1;
    /// There are too many shareholders in the pool.
    const ETOO_MANY_SHAREHOLDERS: u64 = 2;
    /// Cannot destroy non-empty pool.
    const EPOOL_IS_NOT_EMPTY: u64 = 3;
    /// Cannot redeem more shares than the shareholder has in the pool.
    const EINSUFFICIENT_SHARES: u64 = 4;
    /// Shareholder cannot have more than u64.max shares.
    const ESHAREHOLDER_SHARES_OVERFLOW: u64 = 5;
    /// Pool's total coins cannot exceed u64.max.
    const EPOOL_TOTAL_COINS_OVERFLOW: u64 = 6;
    /// Pool's total shares cannot exceed u64.max.
    const EPOOL_TOTAL_SHARES_OVERFLOW: u64 = 7;

    const MAX_U64: u64 = 18446744073709551615;

    const MAX_U128: u128 = 340282366920938463463374607431768211455;

    struct Pool has store {
        total_coins: u64,
        total_shares: u128,
        shares: Table<address, u128>,
        // Default to 1. This can be used to minimize rounding errors when computing shares and coins amount.
        // However, users need to make sure the coins amount don't overflow when multiplied by the scaling factor.
        scaling_factor: u64,
    }

    /// Create a new pool.
    public fun new(): Pool {
        // Default to a scaling factor of 1 (effectively no scaling).
        create_with_scaling_factor(1)
    }

    #[deprecated]
    /// Deprecated. Use `new` instead.
    /// Create a new pool.
    public fun create(): Pool {
        new()
    }

    /// Create a new pool with custom `scaling_factor`.
    public fun create_with_scaling_factor(scaling_factor: u64): Pool {
        Pool {
            total_coins: 0,
            total_shares: 0,
            shares: table::new<address, u128>(),
            scaling_factor,
        }
    }

    /// Destroy an empty pool. This will fail if the pool has any balance of coins.
    public fun destroy_empty(pool: Pool) {
        assert!(pool.total_coins == 0, error::invalid_state(EPOOL_IS_NOT_EMPTY));
        let Pool {
            total_coins: _,
            total_shares: _,
            shares,
            scaling_factor: _,
        } = pool;
        table::destroy_empty<address, u128>(shares);
    }

    /// Return `pool`'s total balance of coins.
    public fun total_coins(pool: &Pool): u64 {
        pool.total_coins
    }

    /// Return the total number of shares across all shareholders in `pool`.
    public fun total_shares(pool: &Pool): u128 {
        pool.total_shares
    }

    /// Return true if `shareholder` is in `pool`.
    public fun contains(pool: &Pool, shareholder: address): bool {
        table::contains(&pool.shares, shareholder)
    }

    /// Return the number of shares of `stakeholder` in `pool`.
    public fun shares(pool: &Pool, shareholder: address): u128 {
        if (contains(pool, shareholder)) {
            *table::borrow(&pool.shares, shareholder)
        } else {
            0
        }
    }

    /// Return the balance in coins of `shareholder` in `pool.`
    public fun balance(pool: &Pool, shareholder: address): u64 {
        let num_shares = shares(pool, shareholder);
        shares_to_amount(pool, num_shares)
    }

    /// Return the number of shareholders in `pool`.
    public fun shareholders_count(pool: &Pool): u64 {
        table::length(&pool.shares)
    }

    /// Update `pool`'s total balance of coins.
    public fun update_total_coins(pool: &mut Pool, new_total_coins: u64) {
        pool.total_coins = new_total_coins;
    }

    /// Allow an existing or new shareholder to add their coins to the pool in exchange for new shares.
    public fun buy_in(pool: &mut Pool, shareholder: address, coins_amount: u64): u128 {
        if (coins_amount == 0) return 0;

        let new_shares = amount_to_shares(pool, coins_amount);
        assert!(MAX_U64 - pool.total_coins >= coins_amount, error::invalid_argument(EPOOL_TOTAL_COINS_OVERFLOW));
        assert!(MAX_U128 - pool.total_shares >= new_shares, error::invalid_argument(EPOOL_TOTAL_SHARES_OVERFLOW));

        pool.total_coins = pool.total_coins + coins_amount;
        pool.total_shares = pool.total_shares + new_shares;
        add_shares(pool, shareholder, new_shares);
        new_shares
    }

    /// Add the number of shares directly for `shareholder` in `pool`.
    /// This would dilute other shareholders if the pool's balance of coins didn't change.
    fun add_shares(pool: &mut Pool, shareholder: address, new_shares: u128): u128 {
        if (contains(pool, shareholder)) {
            let existing_shares = table::borrow_mut(&mut pool.shares, shareholder);
            let current_shares = *existing_shares;
            assert!(MAX_U128 - current_shares >= new_shares, error::invalid_argument(ESHAREHOLDER_SHARES_OVERFLOW));

            *existing_shares = current_shares + new_shares;
            *existing_shares
        } else if (new_shares > 0) {
            table::add(&mut pool.shares, shareholder, new_shares);
            new_shares
        } else {
            new_shares
        }
    }

    /// Allow `shareholder` to redeem their shares in `pool` for coins.
    public fun redeem_shares(pool: &mut Pool, shareholder: address, shares_to_redeem: u128): u64 {
        assert!(contains(pool, shareholder), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));
        assert!(shares(pool, shareholder) >= shares_to_redeem, error::invalid_argument(EINSUFFICIENT_SHARES));

        if (shares_to_redeem == 0) return 0;

        let redeemed_coins = shares_to_amount(pool, shares_to_redeem);
        pool.total_coins = pool.total_coins - redeemed_coins;
        pool.total_shares = pool.total_shares - shares_to_redeem;
        deduct_shares(pool, shareholder, shares_to_redeem);

        redeemed_coins
    }

    /// Transfer shares from `shareholder_1` to `shareholder_2`.
    public fun transfer_shares(
        pool: &mut Pool,
        shareholder_1: address,
        shareholder_2: address,
        shares_to_transfer: u128,
    ) {
        assert!(contains(pool, shareholder_1), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));
        assert!(shares(pool, shareholder_1) >= shares_to_transfer, error::invalid_argument(EINSUFFICIENT_SHARES));
        if (shares_to_transfer == 0) return;

        deduct_shares(pool, shareholder_1, shares_to_transfer);
        add_shares(pool, shareholder_2, shares_to_transfer);
    }

    /// Directly deduct `shareholder`'s number of shares in `pool` and return the number of remaining shares.
    fun deduct_shares(pool: &mut Pool, shareholder: address, num_shares: u128): u128 {
        assert!(contains(pool, shareholder), error::invalid_argument(ESHAREHOLDER_NOT_FOUND));
        assert!(shares(pool, shareholder) >= num_shares, error::invalid_argument(EINSUFFICIENT_SHARES));

        let existing_shares = table::borrow_mut(&mut pool.shares, shareholder);
        *existing_shares = *existing_shares - num_shares;

        // Remove the shareholder completely if they have no shares left.
        let remaining_shares = *existing_shares;
        if (remaining_shares == 0) {
            table::remove(&mut pool.shares, shareholder);
        };

        remaining_shares
    }

    /// Return the number of new shares `coins_amount` can buy in `pool`.
    /// `amount` needs to big enough to avoid rounding number.
    public fun amount_to_shares(pool: &Pool, coins_amount: u64): u128 {
        amount_to_shares_with_total_coins(pool, coins_amount, pool.total_coins)
    }

    /// Return the number of new shares `coins_amount` can buy in `pool` with a custom total coins number.
    /// `amount` needs to big enough to avoid rounding number.
    public fun amount_to_shares_with_total_coins(pool: &Pool, coins_amount: u64, total_coins: u64): u128 {
        // No shares yet so amount is worth the same number of shares.
        if (pool.total_coins == 0 || pool.total_shares == 0) {
            // Multiply by scaling factor to minimize rounding errors during internal calculations for buy ins/redeems.
            // This can overflow but scaling factor is expected to be chosen carefully so this would not overflow.
            to_u128(coins_amount) * to_u128(pool.scaling_factor)
        } else {
            // Shares price = total_coins / total existing shares.
            // New number of shares = new_amount / shares_price = new_amount * existing_shares / total_amount.
            // We rearrange the calc and do multiplication first to avoid rounding errors.
            multiply_then_divide(pool, to_u128(coins_amount), pool.total_shares, to_u128(total_coins))
        }
    }

    /// Return the number of coins `shares` are worth in `pool`.
    /// `shares` needs to big enough to avoid rounding number.
    public fun shares_to_amount(pool: &Pool, shares: u128): u64 {
        shares_to_amount_with_total_coins(pool, shares, pool.total_coins)
    }

    /// Return the number of coins `shares` are worth in `pool` with a custom total coins number.
    /// `shares` needs to big enough to avoid rounding number.
    public fun shares_to_amount_with_total_coins(pool: &Pool, shares: u128, total_coins: u64): u64 {
        // No shares or coins yet so shares are worthless.
        if (pool.total_coins == 0 || pool.total_shares == 0) {
            0
        } else {
            // Shares price = total_coins / total existing shares.
            // Shares worth = shares * shares price = shares * total_coins / total existing shares.
            // We rearrange the calc and do multiplication first to avoid rounding errors.
            (multiply_then_divide(pool, shares, to_u128(total_coins), pool.total_shares) as u64)
        }
    }

    /// Return the number of coins `shares` are worth in `pool` with custom total coins and shares numbers.
    public fun shares_to_amount_with_total_stats(
        pool: &Pool,
        shares: u128,
        total_coins: u64,
        total_shares: u128,
    ): u64 {
        if (pool.total_coins == 0 || total_shares == 0) {
            0
        } else {
            (multiply_then_divide(pool, shares, to_u128(total_coins), total_shares) as u64)
        }
    }

    public fun multiply_then_divide(_pool: &Pool, x: u128, y: u128, z: u128): u128 {
        let result = (to_u256(x) * to_u256(y)) / to_u256(z);
        (result as u128)
    }

    fun to_u128(num: u64): u128 {
        (num as u128)
    }

    fun to_u256(num: u128): u256 {
        (num as u256)
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/pool_u64_unbound.spec.move
================================================
// This file specifies the module `pool_u64_unbound`.
// It specifies the pre/post-conditions of the functions.
spec aptos_std::pool_u64_unbound {

    // -----------------------
    // Function specifications
    // -----------------------

    spec Pool {
        invariant forall addr: address:
            table::spec_contains(shares, addr) ==> (table::spec_get(shares, addr) > 0);
    }

    spec fun spec_contains(pool: Pool, shareholder: address): bool {
        table::spec_contains(pool.shares, shareholder)
    }

    spec contains(pool: &Pool, shareholder: address): bool {
        aborts_if false;
        ensures result == spec_contains(pool, shareholder);
    }

    spec fun spec_shares(pool: Pool, shareholder: address): u64 {
        if (spec_contains(pool, shareholder)) {
            table::spec_get(pool.shares, shareholder)
        }
        else {
            0
        }
    }

    spec shares(pool: &Pool, shareholder: address): u128 {
        aborts_if false;
        ensures result == spec_shares(pool, shareholder);
    }

    spec balance(pool: &Pool, shareholder: address): u64 {
        let shares = spec_shares(pool, shareholder);
        let total_coins = pool.total_coins;
        aborts_if pool.total_coins > 0 && pool.total_shares > 0 && (shares * total_coins) / pool.total_shares > MAX_U64;
        ensures result == spec_shares_to_amount_with_total_coins(pool, shares, total_coins);
    }

    spec buy_in(pool: &mut Pool, shareholder: address, coins_amount: u64): u128 {
        let new_shares = spec_amount_to_shares_with_total_coins(pool, coins_amount, pool.total_coins);
        aborts_if pool.total_coins + coins_amount > MAX_U64;
        aborts_if pool.total_shares + new_shares > MAX_U128;
        include coins_amount > 0 ==> AddSharesAbortsIf { new_shares: new_shares };
        include coins_amount > 0 ==> AddSharesEnsures { new_shares: new_shares };
        ensures pool.total_coins == old(pool.total_coins) + coins_amount;
        ensures pool.total_shares == old(pool.total_shares) + new_shares;
        ensures result == new_shares;
    }

    spec add_shares(pool: &mut Pool, shareholder: address, new_shares: u128): u128 {
        include AddSharesAbortsIf;
        include AddSharesEnsures;

        let key_exists = table::spec_contains(pool.shares, shareholder);
        ensures result == if (key_exists) { table::spec_get(pool.shares, shareholder) }
        else { new_shares };
    }
    spec schema AddSharesAbortsIf {
        pool: Pool;
        shareholder: address;
        new_shares: u64;

        let key_exists = table::spec_contains(pool.shares, shareholder);
        let current_shares = table::spec_get(pool.shares, shareholder);

        aborts_if key_exists && current_shares + new_shares > MAX_U128;
    }
    spec schema AddSharesEnsures {
        pool: Pool;
        shareholder: address;
        new_shares: u64;

        let key_exists = table::spec_contains(pool.shares, shareholder);
        let current_shares = table::spec_get(pool.shares, shareholder);

        ensures key_exists ==>
            pool.shares == table::spec_set(old(pool.shares), shareholder, current_shares + new_shares);
        ensures (!key_exists && new_shares > 0) ==>
            pool.shares == table::spec_set(old(pool.shares), shareholder, new_shares);
    }

    spec fun spec_amount_to_shares_with_total_coins(pool: Pool, coins_amount: u64, total_coins: u64): u128 {
        if (pool.total_coins == 0 || pool.total_shares == 0) {
            coins_amount * pool.scaling_factor
        }
        else {
            (coins_amount * pool.total_shares) / total_coins
        }
    }

    spec amount_to_shares_with_total_coins(pool: &Pool, coins_amount: u64, total_coins: u64): u128 {
        aborts_if pool.total_coins > 0 && pool.total_shares > 0
            && (coins_amount * pool.total_shares) / total_coins > MAX_U128;
        aborts_if (pool.total_coins == 0 || pool.total_shares == 0)
            && coins_amount * pool.scaling_factor > MAX_U128;
        aborts_if pool.total_coins > 0 && pool.total_shares > 0 && total_coins == 0;
        ensures result == spec_amount_to_shares_with_total_coins(pool, coins_amount, total_coins);
    }

    spec shares_to_amount_with_total_coins(pool: &Pool, shares: u128, total_coins: u64): u64 {
        aborts_if pool.total_coins > 0 && pool.total_shares > 0
            && (shares * total_coins) / pool.total_shares > MAX_U64;
        ensures result == spec_shares_to_amount_with_total_coins(pool, shares, total_coins);
    }

    spec fun spec_shares_to_amount_with_total_coins(pool: Pool, shares: u128, total_coins: u64): u64 {
        if (pool.total_coins == 0 || pool.total_shares == 0) {
            0
        }
        else {
            (shares * total_coins) / pool.total_shares
        }
    }

    spec multiply_then_divide(_pool: &Pool, x: u128, y: u128, z: u128): u128 {
        aborts_if z == 0;
        aborts_if (x * y) / z > MAX_U128;
        ensures result == (x * y) / z;
    }

    spec redeem_shares(pool: &mut Pool, shareholder: address, shares_to_redeem: u128): u64 {
        let redeemed_coins = spec_shares_to_amount_with_total_coins(pool, shares_to_redeem, pool.total_coins);
        aborts_if !spec_contains(pool, shareholder);
        aborts_if spec_shares(pool, shareholder) < shares_to_redeem;
        aborts_if pool.total_coins < redeemed_coins;
        aborts_if pool.total_shares < shares_to_redeem;
        ensures pool.total_coins == old(pool.total_coins) - redeemed_coins;
        ensures pool.total_shares == old(pool.total_shares) - shares_to_redeem;
        include shares_to_redeem > 0 ==> DeductSharesEnsures { num_shares: shares_to_redeem };
        ensures result == redeemed_coins;
    }

    spec transfer_shares(
    pool: &mut Pool,
    shareholder_1: address,
    shareholder_2: address,
    shares_to_transfer: u128
    ) {
        aborts_if (shareholder_1 != shareholder_2) && shares_to_transfer > 0 && spec_contains(pool, shareholder_2) &&
            (spec_shares(pool, shareholder_2) + shares_to_transfer > MAX_U128);
        aborts_if !spec_contains(pool, shareholder_1);
        aborts_if spec_shares(pool, shareholder_1) < shares_to_transfer;
        ensures shareholder_1 == shareholder_2 ==> spec_shares(old(pool), shareholder_1) == spec_shares(pool, shareholder_1);
        ensures ((shareholder_1 != shareholder_2) && (spec_shares(old(pool), shareholder_1) == shares_to_transfer)) ==>
            !spec_contains(pool, shareholder_1);
        ensures (shareholder_1 != shareholder_2 && shares_to_transfer > 0) ==>
            (spec_contains(pool, shareholder_2));
        ensures (shareholder_1 != shareholder_2 && shares_to_transfer > 0 && !spec_contains(old(pool), shareholder_2)) ==>
            (spec_contains(pool, shareholder_2) && spec_shares(pool, shareholder_2) == shares_to_transfer);
        ensures (shareholder_1 != shareholder_2 && shares_to_transfer > 0 && spec_contains(old(pool), shareholder_2)) ==>
            (spec_contains(pool, shareholder_2) && spec_shares(pool, shareholder_2) == spec_shares(old(pool), shareholder_2) + shares_to_transfer);
        ensures ((shareholder_1 != shareholder_2) && (spec_shares(old(pool), shareholder_1) > shares_to_transfer)) ==>
            (spec_contains(pool, shareholder_1) && (spec_shares(pool, shareholder_1) == spec_shares(old(pool), shareholder_1) - shares_to_transfer));
    }

    spec deduct_shares(pool: &mut Pool, shareholder: address, num_shares: u128): u128 {
        aborts_if !spec_contains(pool, shareholder);
        aborts_if spec_shares(pool, shareholder) < num_shares;

        include DeductSharesEnsures;
        let remaining_shares = table::spec_get(pool.shares, shareholder) - num_shares;
        ensures remaining_shares > 0 ==> result == table::spec_get(pool.shares, shareholder);
        ensures remaining_shares == 0 ==> result == 0;
    }
    spec schema DeductSharesEnsures {
        pool: Pool;
        shareholder: address;
        num_shares: u64;
        let remaining_shares = table::spec_get(pool.shares, shareholder) - num_shares;
        ensures remaining_shares > 0 ==> table::spec_get(pool.shares, shareholder) == remaining_shares;
        ensures remaining_shares == 0 ==> !table::spec_contains(pool.shares, shareholder);
    }

    spec to_u128(num: u64): u128 {
        aborts_if false;
        ensures result == num;
    }

    spec to_u256(num: u128): u256 {
        aborts_if false;
        ensures result == num;
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/simple_map.move
================================================
/// This module provides a solution for unsorted maps, that is it has the properties that
/// 1) Keys point to Values
/// 2) Each Key must be unique
/// 3) A Key can be found within O(N) time
/// 4) The keys are unsorted.
/// 5) Adds and removals take O(N) time
module aptos_std::simple_map {
    use std::error;
    use std::option;
    use std::vector;

    /// Map key already exists
    const EKEY_ALREADY_EXISTS: u64 = 1;
    /// Map key is not found
    const EKEY_NOT_FOUND: u64 = 2;

    struct SimpleMap<Key, Value> has copy, drop, store {
        data: vector<Element<Key, Value>>,
    }

    struct Element<Key, Value> has copy, drop, store {
        key: Key,
        value: Value,
    }

    public fun length<Key: store, Value: store>(map: &SimpleMap<Key, Value>): u64 {
        vector::length(&map.data)
    }

    /// Create an empty SimpleMap.
    public fun new<Key: store, Value: store>(): SimpleMap<Key, Value> {
        SimpleMap {
            data: vector::empty(),
        }
    }

    /// Create a SimpleMap from a vector of keys and values. The keys must be unique.
    public fun new_from<Key: store, Value: store>(
        keys: vector<Key>,
        values: vector<Value>,
    ): SimpleMap<Key, Value> {
        let map = new();
        add_all(&mut map, keys, values);
        map
    }

    #[deprecated]
    /// Create an empty SimpleMap.
    /// This function is deprecated, use `new` instead.
    public fun create<Key: store, Value: store>(): SimpleMap<Key, Value> {
        new()
    }

    public fun borrow<Key: store, Value: store>(
        map: &SimpleMap<Key, Value>,
        key: &Key,
    ): &Value {
        let maybe_idx = find(map, key);
        assert!(option::is_some(&maybe_idx), error::invalid_argument(EKEY_NOT_FOUND));
        let idx = option::extract(&mut maybe_idx);
        &vector::borrow(&map.data, idx).value
    }

    public fun borrow_mut<Key: store, Value: store>(
        map: &mut SimpleMap<Key, Value>,
        key: &Key,
    ): &mut Value {
        let maybe_idx = find(map, key);
        assert!(option::is_some(&maybe_idx), error::invalid_argument(EKEY_NOT_FOUND));
        let idx = option::extract(&mut maybe_idx);
        &mut vector::borrow_mut(&mut map.data, idx).value
    }

    public fun contains_key<Key: store, Value: store>(
        map: &SimpleMap<Key, Value>,
        key: &Key,
    ): bool {
        let maybe_idx = find(map, key);
        option::is_some(&maybe_idx)
    }

    public fun destroy_empty<Key: store, Value: store>(map: SimpleMap<Key, Value>) {
        let SimpleMap { data } = map;
        vector::destroy_empty(data);
    }

    /// Add a key/value pair to the map. The key must not already exist.
    public fun add<Key: store, Value: store>(
        map: &mut SimpleMap<Key, Value>,
        key: Key,
        value: Value,
    ) {
        let maybe_idx = find(map, &key);
        assert!(option::is_none(&maybe_idx), error::invalid_argument(EKEY_ALREADY_EXISTS));

        vector::push_back(&mut map.data, Element { key, value });
    }

    /// Add multiple key/value pairs to the map. The keys must not already exist.
    public fun add_all<Key: store, Value: store>(
        map: &mut SimpleMap<Key, Value>,
        keys: vector<Key>,
        values: vector<Value>,
    ) {
        vector::zip(keys, values, |key, value| {
            add(map, key, value);
        });
    }

    /// Insert key/value pair or update an existing key to a new value
    public fun upsert<Key: store, Value: store>(
        map: &mut SimpleMap<Key, Value>,
        key: Key,
        value: Value
    ): (std::option::Option<Key>, std::option::Option<Value>) {
        let data = &mut map.data;
        let len = vector::length(data);
        let i = 0;
        while (i < len) {
            let element = vector::borrow(data, i);
            if (&element.key == &key) {
                vector::push_back(data, Element { key, value });
                vector::swap(data, i, len);
                let Element { key, value } = vector::pop_back(data);
                return (std::option::some(key), std::option::some(value))
            };
            i = i + 1;
        };
        vector::push_back(&mut map.data, Element { key, value });
        (std::option::none(), std::option::none())
    }

    /// Return all keys in the map. This requires keys to be copyable.
    public fun keys<Key: copy, Value>(map: &SimpleMap<Key, Value>): vector<Key> {
        vector::map_ref(&map.data, |e| {
            let e: &Element<Key, Value> = e;
            e.key
        })
    }

    /// Return all values in the map. This requires values to be copyable.
    public fun values<Key, Value: copy>(map: &SimpleMap<Key, Value>): vector<Value> {
        vector::map_ref(&map.data, |e| {
            let e: &Element<Key, Value> = e;
            e.value
        })
    }

    /// Transform the map into two vectors with the keys and values respectively
    /// Primarily used to destroy a map
    public fun to_vec_pair<Key: store, Value: store>(
        map: SimpleMap<Key, Value>): (vector<Key>, vector<Value>) {
        let keys: vector<Key> = vector::empty();
        let values: vector<Value> = vector::empty();
        let SimpleMap { data } = map;
        vector::for_each(data, |e| {
            let Element { key, value } = e;
            vector::push_back(&mut keys, key);
            vector::push_back(&mut values, value);
        });
        (keys, values)
    }

    /// For maps that cannot be dropped this is a utility to destroy them
    /// using lambdas to destroy the individual keys and values.
    public inline fun destroy<Key: store, Value: store>(
        map: SimpleMap<Key, Value>,
        dk: |Key|,
        dv: |Value|
    ) {
        let (keys, values) = to_vec_pair(map);
        vector::destroy(keys, |_k| dk(_k));
        vector::destroy(values, |_v| dv(_v));
    }

    /// Remove a key/value pair from the map. The key must exist.
    public fun remove<Key: store, Value: store>(
        map: &mut SimpleMap<Key, Value>,
        key: &Key,
    ): (Key, Value) {
        let maybe_idx = find(map, key);
        assert!(option::is_some(&maybe_idx), error::invalid_argument(EKEY_NOT_FOUND));
        let placement = option::extract(&mut maybe_idx);
        let Element { key, value } = vector::swap_remove(&mut map.data, placement);
        (key, value)
    }

    fun find<Key: store, Value: store>(
        map: &SimpleMap<Key, Value>,
        key: &Key,
    ): option::Option<u64> {
        let leng = vector::length(&map.data);
        let i = 0;
        while (i < leng) {
            let element = vector::borrow(&map.data, i);
            if (&element.key == key) {
                return option::some(i)
            };
            i = i + 1;
        };
        option::none<u64>()
    }

    #[test]
    public fun test_add_remove_many() {
        let map = create<u64, u64>();

        assert!(length(&map) == 0, 0);
        assert!(!contains_key(&map, &3), 1);
        add(&mut map, 3, 1);
        assert!(length(&map) == 1, 2);
        assert!(contains_key(&map, &3), 3);
        assert!(borrow(&map, &3) == &1, 4);
        *borrow_mut(&mut map, &3) = 2;
        assert!(borrow(&map, &3) == &2, 5);

        assert!(!contains_key(&map, &2), 6);
        add(&mut map, 2, 5);
        assert!(length(&map) == 2, 7);
        assert!(contains_key(&map, &2), 8);
        assert!(borrow(&map, &2) == &5, 9);
        *borrow_mut(&mut map, &2) = 9;
        assert!(borrow(&map, &2) == &9, 10);

        remove(&mut map, &2);
        assert!(length(&map) == 1, 11);
        assert!(!contains_key(&map, &2), 12);
        assert!(borrow(&map, &3) == &2, 13);

        remove(&mut map, &3);
        assert!(length(&map) == 0, 14);
        assert!(!contains_key(&map, &3), 15);

        destroy_empty(map);
    }

    #[test]
    public fun test_add_all() {
        let map = create<u64, u64>();

        assert!(length(&map) == 0, 0);
        add_all(&mut map, vector[1, 2, 3], vector[10, 20, 30]);
        assert!(length(&map) == 3, 1);
        assert!(borrow(&map, &1) == &10, 2);
        assert!(borrow(&map, &2) == &20, 3);
        assert!(borrow(&map, &3) == &30, 4);

        remove(&mut map, &1);
        remove(&mut map, &2);
        remove(&mut map, &3);
        destroy_empty(map);
    }

    #[test]
    public fun test_keys() {
        let map = create<u64, u64>();
        assert!(keys(&map) == vector[], 0);
        add(&mut map, 2, 1);
        add(&mut map, 3, 1);

        assert!(keys(&map) == vector[2, 3], 0);
    }

    #[test]
    public fun test_values() {
        let map = create<u64, u64>();
        assert!(values(&map) == vector[], 0);
        add(&mut map, 2, 1);
        add(&mut map, 3, 2);

        assert!(values(&map) == vector[1, 2], 0);
    }

    #[test]
    #[expected_failure]
    public fun test_add_twice() {
        let map = create<u64, u64>();
        add(&mut map, 3, 1);
        add(&mut map, 3, 1);

        remove(&mut map, &3);
        destroy_empty(map);
    }

    #[test]
    #[expected_failure]
    public fun test_remove_twice() {
        let map = create<u64, u64>();
        add(&mut map, 3, 1);
        remove(&mut map, &3);
        remove(&mut map, &3);

        destroy_empty(map);
    }

    #[test]
    public fun test_upsert_test() {
        let map = create<u64, u64>();
        // test adding 3 elements using upsert
        upsert<u64, u64>(&mut map, 1, 1);
        upsert(&mut map, 2, 2);
        upsert(&mut map, 3, 3);

        assert!(length(&map) == 3, 0);
        assert!(contains_key(&map, &1), 1);
        assert!(contains_key(&map, &2), 2);
        assert!(contains_key(&map, &3), 3);
        assert!(borrow(&map, &1) == &1, 4);
        assert!(borrow(&map, &2) == &2, 5);
        assert!(borrow(&map, &3) == &3, 6);

        // change mapping 1->1 to 1->4
        upsert(&mut map, 1, 4);

        assert!(length(&map) == 3, 7);
        assert!(contains_key(&map, &1), 8);
        assert!(borrow(&map, &1) == &4, 9);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/simple_map.spec.move
================================================
/// Specifications of the `simple_map` module.
spec aptos_std::simple_map {

    // Make most of the public API intrinsic. Those functions have custom specifications in the prover.

    spec SimpleMap {
        pragma intrinsic = map,
            map_new = create,
            map_len = length,
            map_destroy_empty = destroy_empty,
            map_has_key = contains_key,
            map_add_no_override = add,
            map_del_return_key = remove,
            map_borrow = borrow,
            map_borrow_mut = borrow_mut,
            map_spec_get = spec_get,
            map_spec_set = spec_set,
            map_spec_del = spec_remove,
            map_spec_len = spec_len,
            map_spec_has_key = spec_contains_key;
    }

    spec length {
        pragma intrinsic;
    }

    spec create {
        pragma intrinsic;
    }

    spec borrow {
        pragma intrinsic;
    }

    spec borrow_mut {
        pragma intrinsic;
    }

    spec contains_key {
        pragma intrinsic;
    }

    spec destroy_empty {
        pragma intrinsic;
    }

    spec add {
        pragma intrinsic;
    }

    spec add_all {
        pragma intrinsic;
    }

    spec remove {
        pragma intrinsic;
    }

    spec find {
        pragma verify=false;
    }

    spec keys {
        pragma verify=false;
    }

    spec values {
        pragma verify=false;
    }

    spec new<Key: store, Value: store>(): SimpleMap<Key, Value> {
        pragma intrinsic;
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] spec_len(result) == 0;
        ensures [abstract] forall k: Key: !spec_contains_key(result, k);
    }

    spec new_from<Key: store, Value: store>(
    keys: vector<Key>,
    values: vector<Value>,
    ): SimpleMap<Key, Value> {
        pragma intrinsic;
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] spec_len(result) == len(keys);
        ensures [abstract] forall k: Key: spec_contains_key(result, k) <==> vector::spec_contains(keys, k);
        ensures [abstract] forall i in 0..len(keys):
            spec_get(result, vector::borrow(keys, i)) == vector::borrow(values, i);
    }

    spec to_vec_pair<Key: store, Value: store>(map: SimpleMap<Key, Value>): (vector<Key>, vector<Value>) {
        pragma intrinsic;
        pragma opaque;
        ensures [abstract]
            forall k: Key: vector::spec_contains(result_1, k) <==>
                spec_contains_key(map, k);
        ensures [abstract] forall i in 0..len(result_1):
            spec_get(map, vector::borrow(result_1, i)) == vector::borrow(result_2, i);
    }

    spec upsert<Key: store, Value: store>(
        map: &mut SimpleMap<Key, Value>,
        key: Key,
        value: Value
        ): (std::option::Option<Key>, std::option::Option<Value>) {
        pragma intrinsic;
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] !spec_contains_key(old(map), key) ==> option::is_none(result_1);
        ensures [abstract] !spec_contains_key(old(map), key) ==> option::is_none(result_2);
        ensures [abstract] spec_contains_key(map, key);
        ensures [abstract] spec_get(map, key) == value;
        ensures [abstract] spec_contains_key(old(map), key) ==> ((option::is_some(result_1)) && (option::spec_borrow(result_1) == key));
        ensures [abstract] spec_contains_key(old(map), key) ==> ((option::is_some(result_2)) && (option::spec_borrow(result_2) == spec_get(old(map), key)));
    }

    // Specification functions for tables
    spec native fun spec_len<K, V>(t: SimpleMap<K, V>): num;
    spec native fun spec_contains_key<K, V>(t: SimpleMap<K, V>, k: K): bool;
    spec native fun spec_set<K, V>(t: SimpleMap<K, V>, k: K, v: V): SimpleMap<K, V>;
    spec native fun spec_remove<K, V>(t: SimpleMap<K, V>, k: K): SimpleMap<K, V>;
    spec native fun spec_get<K, V>(t: SimpleMap<K, V>, k: K): V;
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/string_utils.move
================================================
/// A module for formatting move values as strings.
module aptos_std::string_utils {
    use std::string::String;

    /// The number of values in the list does not match the number of "{}" in the format string.
    const EARGS_MISMATCH: u64 = 1;
    /// The format string is not valid.
    const EINVALID_FORMAT: u64 = 2;
    /// Formatting is not possible because the value contains delayed fields such as aggregators.
    const EUNABLE_TO_FORMAT_DELAYED_FIELD: u64 = 3;

    /// Format a move value as a human readable string,
    /// eg. `to_string(&1u64) == "1"`, `to_string(&false) == "false"`, `to_string(&@0x1) == "@0x1"`.
    /// For vectors and structs the format is similar to rust, eg.
    /// `to_string(&cons(1,2)) == "Cons { car: 1, cdr: 2 }"` and `to_string(&vector[1, 2, 3]) == "[ 1, 2, 3 ]"`
    /// For vectors of u8 the output is hex encoded, eg. `to_string(&vector[1u8, 2u8, 3u8]) == "0x010203"`
    /// For std::string::String the output is the string itself including quotes, eg.
    /// `to_string(&std::string::utf8(b"My string")) == "\"My string\""`
    public fun to_string<T>(s: &T): String {
        native_format(s, false, false, true, false)
    }

    /// Format addresses as 64 zero-padded hexadecimals.
    public fun to_string_with_canonical_addresses<T>(s: &T): String {
        native_format(s, false, true, true, false)
    }

    /// Format emitting integers with types ie. 6u8 or 128u32.
    public fun to_string_with_integer_types<T>(s: &T): String {
        native_format(s, false, true, true, false)
    }

    /// Format vectors and structs with newlines and indentation.
    public fun debug_string<T>(s: &T): String {
        native_format(s, true, false, false, false)
    }

    /// Formatting with a rust-like format string, eg. `format2(&b"a = {}, b = {}", 1, 2) == "a = 1, b = 2"`.
    public fun format1<T0: drop>(fmt: &vector<u8>, a: T0): String {
        native_format_list(fmt, &list1(a))
    }
    public fun format2<T0: drop, T1: drop>(fmt: &vector<u8>, a: T0, b: T1): String {
        native_format_list(fmt, &list2(a, b))
    }
    public fun format3<T0: drop, T1: drop, T2: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2): String {
        native_format_list(fmt, &list3(a, b, c))
    }
    public fun format4<T0: drop, T1: drop, T2: drop, T3: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2, d: T3): String {
        native_format_list(fmt, &list4(a, b, c, d))
    }

    // Helper struct to allow passing a generic heterogeneous list of values to native_format_list.
    struct Cons<T, N> has copy, drop, store {
        car: T,
        cdr: N,
    }

    struct NIL has copy, drop, store {}

    // Create a pair of values.
    fun cons<T, N>(car: T, cdr: N): Cons<T, N> { Cons { car, cdr } }

    // Create a nil value.
    fun nil(): NIL { NIL {} }

    // Create a list of values.
    inline fun list1<T0>(a: T0): Cons<T0, NIL> { cons(a, nil()) }
    inline fun list2<T0, T1>(a: T0, b: T1): Cons<T0, Cons<T1, NIL>> { cons(a, list1(b)) }
    inline fun list3<T0, T1, T2>(a: T0, b: T1, c: T2): Cons<T0, Cons<T1, Cons<T2, NIL>>> { cons(a, list2(b, c)) }
    inline fun list4<T0, T1, T2, T3>(a: T0, b: T1, c: T2, d: T3): Cons<T0, Cons<T1, Cons<T2, Cons<T3, NIL>>>> { cons(a, list3(b, c, d)) }

    // Native functions
    native fun native_format<T>(s: &T, type_tag: bool, canonicalize: bool, single_line: bool, include_int_types: bool): String;
    native fun native_format_list<T>(fmt: &vector<u8>, val: &T): String;

    #[test]
    fun test_format() {
        assert!(to_string(&1u64) == std::string::utf8(b"1"), 1);
        assert!(to_string(&false) == std::string::utf8(b"false"), 2);
        assert!(to_string(&1u256) == std::string::utf8(b"1"), 3);
        assert!(to_string(&vector[1, 2, 3]) == std::string::utf8(b"[ 1, 2, 3 ]"), 4);
        assert!(to_string(&cons(std::string::utf8(b"My string"),2)) == std::string::utf8(b"Cons { car: \"My string\", cdr: 2 }"), 5);
        assert!(to_string(&std::option::none<u64>()) == std::string::utf8(b"None"), 6);
        assert!(to_string(&std::option::some(1)) == std::string::utf8(b"Some(1)"), 7);
    }

    #[test]
    fun test_format_list() {
        let s = format3(&b"a = {} b = {} c = {}", 1, 2, std::string::utf8(b"My string"));
        assert!(s == std::string::utf8(b"a = 1 b = 2 c = \"My string\""), 1);
    }

    #[test]
    #[expected_failure(abort_code = EARGS_MISMATCH)]
    fun test_format_list_to_many_vals() {
        format4(&b"a = {} b = {} c = {}", 1, 2, 3, 4);
    }

    #[test]
    #[expected_failure(abort_code = EARGS_MISMATCH)]
    fun test_format_list_not_enough_vals() {
        format2(&b"a = {} b = {} c = {}", 1, 2);
    }

    #[test]
    #[expected_failure(abort_code = EARGS_MISMATCH)]
    fun test_format_list_not_valid_nil() {
        let l = cons(1, cons(2, cons(3, 4)));
        native_format_list(&b"a = {} b = {} c = {}", &l);
    }

    /// #[test_only]
    struct FakeCons<T, N> has copy, drop, store {
        car: T,
        cdr: N,
    }

    #[test]
    #[expected_failure(abort_code = EARGS_MISMATCH)]
    fun test_format_list_not_valid_list() {
        let l = cons(1, FakeCons { car: 2, cdr: cons(3, nil())});
        native_format_list(&b"a = {} b = {} c = {}", &l);
    }

    #[test]
    #[expected_failure(abort_code = EINVALID_FORMAT)]
    fun test_format_unclosed_braces() {
        format3(&b"a = {} b = {} c = {", 1, 2 ,3);
    }

    #[test]
    #[expected_failure(abort_code = EINVALID_FORMAT)]
    fun test_format_unclosed_braces_2() {
        format3(&b"a = {} b = { c = {}", 1, 2, 3);
    }

    #[test]
    #[expected_failure(abort_code = EINVALID_FORMAT)]
    fun test_format_unopened_braces() {
        format3(&b"a = } b = {} c = {}", 1, 2, 3);
    }

    #[test]
    fun test_format_escape_braces_works() {
        let s = format3(&b"{{a = {} b = {} c = {}}}", 1, 2, 3);
        assert!(s == std::string::utf8(b"{a = 1 b = 2 c = 3}"), 1);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/string_utils.spec.move
================================================
spec aptos_std::string_utils {
    spec to_string<T>(s: &T): String {
        aborts_if false;
        ensures result == spec_native_format(s, false, false, true, false);
    }

    spec to_string_with_canonical_addresses<T>(s: &T): String {
        aborts_if false;
        ensures result == spec_native_format(s, false, true, true, false);
    }

    spec to_string_with_integer_types<T>(s: &T): String {
        aborts_if false;
        ensures result == spec_native_format(s, false, true, true, false);
    }

    spec debug_string<T>(s: &T): String {
        aborts_if false;
        ensures result == spec_native_format(s, true, false, false, false);
    }

    spec format1<T0: drop>(fmt: &vector<u8>, a: T0): String {
        aborts_if args_mismatch_or_invalid_format(fmt, list1(a));
        ensures result == spec_native_format_list(fmt, list1(a));
    }

    spec format2<T0: drop, T1: drop>(fmt: &vector<u8>, a: T0, b: T1): String {
        aborts_if args_mismatch_or_invalid_format(fmt, list2(a, b));
        ensures result == spec_native_format_list(fmt, list2(a, b));
    }

    spec format3<T0: drop, T1: drop, T2: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2): String {
        aborts_if args_mismatch_or_invalid_format(fmt, list3(a, b, c));
        ensures result == spec_native_format_list(fmt, list3(a, b, c));
    }

    spec format4<T0: drop, T1: drop, T2: drop, T3: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2, d: T3): String {
        aborts_if args_mismatch_or_invalid_format(fmt, list4(a, b, c, d));
        ensures result == spec_native_format_list(fmt, list4(a, b, c, d));
    }

    spec native_format<T>(s: &T, type_tag: bool, canonicalize: bool, single_line: bool, include_int_types: bool): String {
        pragma opaque;
        aborts_if false;
        ensures result == spec_native_format(s, type_tag, canonicalize, single_line, include_int_types);
    }

    spec native_format_list<T>(fmt: &vector<u8>, val: &T): String {
        pragma opaque;
        aborts_if args_mismatch_or_invalid_format(fmt, val);
        ensures result == spec_native_format_list(fmt, val);
    }

    spec fun spec_native_format<T>(s: T, type_tag: bool, canonicalize: bool, single_line: bool, include_int_types: bool): String;
    spec fun spec_native_format_list<T>(fmt: vector<u8>, val: T): String;
    spec fun args_mismatch_or_invalid_format<T>(fmt: vector<u8>, val: T): bool;
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/table.move
================================================
/// Type of large-scale storage tables.
/// source: https://github.com/move-language/move/blob/1b6b7513dcc1a5c866f178ca5c1e74beb2ce181e/language/extensions/move-table-extension/sources/Table.move#L1
///
/// It implements the Table type which supports individual table items to be represented by
/// separate global state items. The number of items and a unique handle are tracked on the table
/// struct itself, while the operations are implemented as native functions. No traversal is provided.

module aptos_std::table {
    friend aptos_std::table_with_length;

    /// Type of tables
    struct Table<phantom K: copy + drop, phantom V> has store {
        handle: address,
    }

    /// Create a new Table.
    public fun new<K: copy + drop, V: store>(): Table<K, V> {
        Table {
            handle: new_table_handle<K, V>(),
        }
    }

    /// Add a new entry to the table. Aborts if an entry for this
    /// key already exists. The entry itself is not stored in the
    /// table, and cannot be discovered from it.
    public fun add<K: copy + drop, V>(table: &mut Table<K, V>, key: K, val: V) {
        add_box<K, V, Box<V>>(table, key, Box { val })
    }

    /// Acquire an immutable reference to the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun borrow<K: copy + drop, V>(table: &Table<K, V>, key: K): &V {
        &borrow_box<K, V, Box<V>>(table, key).val
    }

    /// Acquire an immutable reference to the value which `key` maps to.
    /// Returns specified default value if there is no entry for `key`.
    public fun borrow_with_default<K: copy + drop, V>(table: &Table<K, V>, key: K, default: &V): &V {
        if (!contains(table, copy key)) {
            default
        } else {
            borrow(table, copy key)
        }
    }

    /// Acquire a mutable reference to the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun borrow_mut<K: copy + drop, V>(table: &mut Table<K, V>, key: K): &mut V {
        &mut borrow_box_mut<K, V, Box<V>>(table, key).val
    }

    /// Acquire a mutable reference to the value which `key` maps to.
    /// Insert the pair (`key`, `default`) first if there is no entry for `key`.
    public fun borrow_mut_with_default<K: copy + drop, V: drop>(table: &mut Table<K, V>, key: K, default: V): &mut V {
        if (!contains(table, copy key)) {
            add(table, copy key, default)
        };
        borrow_mut(table, key)
    }

    /// Insert the pair (`key`, `value`) if there is no entry for `key`.
    /// update the value of the entry for `key` to `value` otherwise
    public fun upsert<K: copy + drop, V: drop>(table: &mut Table<K, V>, key: K, value: V) {
        if (!contains(table, copy key)) {
            add(table, copy key, value)
        } else {
            let ref = borrow_mut(table, key);
            *ref = value;
        };
    }

    /// Remove from `table` and return the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun remove<K: copy + drop, V>(table: &mut Table<K, V>, key: K): V {
        let Box { val } = remove_box<K, V, Box<V>>(table, key);
        val
    }

    /// Returns true iff `table` contains an entry for `key`.
    public fun contains<K: copy + drop, V>(table: &Table<K, V>, key: K): bool {
        contains_box<K, V, Box<V>>(table, key)
    }

    #[test_only]
    /// Testing only: allows to drop a table even if it is not empty.
    public fun drop_unchecked<K: copy + drop, V>(table: Table<K, V>) {
        drop_unchecked_box<K, V, Box<V>>(table)
    }

    public(friend) fun destroy<K: copy + drop, V>(table: Table<K, V>) {
        destroy_empty_box<K, V, Box<V>>(&table);
        drop_unchecked_box<K, V, Box<V>>(table)
    }

    #[test_only]
    struct TableHolder<phantom K: copy + drop, phantom V: drop> has key {
        t: Table<K, V>
    }

    #[test(account = @0x1)]
    fun test_upsert(account: signer) {
        let t = new<u64, u8>();
        let key: u64 = 111;
        let error_code: u64 = 1;
        assert!(!contains(&t, key), error_code);
        upsert(&mut t, key, 12);
        assert!(*borrow(&t, key) == 12, error_code);
        upsert(&mut t, key, 23);
        assert!(*borrow(&t, key) == 23, error_code);

        move_to(&account, TableHolder { t });
    }

    #[test(account = @0x1)]
    fun test_borrow_with_default(account: signer) {
        let t = new<u64, u8>();
        let key: u64 = 100;
        let error_code: u64 = 1;
        assert!(!contains(&t, key), error_code);
        assert!(*borrow_with_default(&t, key, &12) == 12, error_code);
        add(&mut t, key, 1);
        assert!(*borrow_with_default(&t, key, &12) == 1, error_code);

        move_to(&account, TableHolder{ t });
    }

    // ======================================================================================================
    // Internal API

    /// Wrapper for values. Required for making values appear as resources in the implementation.
    struct Box<V> has key, drop, store {
        val: V
    }

    // Primitives which take as an additional type parameter `Box<V>`, so the implementation
    // can use this to determine serialization layout.
    native fun new_table_handle<K, V>(): address;

    native fun add_box<K: copy + drop, V, B>(table: &mut Table<K, V>, key: K, val: Box<V>);

    native fun borrow_box<K: copy + drop, V, B>(table: &Table<K, V>, key: K): &Box<V>;

    native fun borrow_box_mut<K: copy + drop, V, B>(table: &mut Table<K, V>, key: K): &mut Box<V>;

    native fun contains_box<K: copy + drop, V, B>(table: &Table<K, V>, key: K): bool;

    native fun remove_box<K: copy + drop, V, B>(table: &mut Table<K, V>, key: K): Box<V>;

    native fun destroy_empty_box<K: copy + drop, V, B>(table: &Table<K, V>);

    native fun drop_unchecked_box<K: copy + drop, V, B>(table: Table<K, V>);
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/table.spec.move
================================================
/// Specifications of the `table` module.
spec aptos_std::table {

    // Make most of the public API intrinsic. Those functions have custom specifications in the prover.

    spec Table {
        pragma intrinsic = map,
            map_new = new,
            map_destroy_empty = destroy,
            map_has_key = contains,
            map_add_no_override = add,
            map_add_override_if_exists = upsert,
            map_del_must_exist = remove,
            map_borrow = borrow,
            map_borrow_mut = borrow_mut,
            map_borrow_mut_with_default = borrow_mut_with_default,
            map_spec_get = spec_get,
            map_spec_set = spec_set,
            map_spec_del = spec_remove,
            map_spec_has_key = spec_contains;
    }

    spec new {
        pragma intrinsic;
    }

    spec destroy {
        pragma intrinsic;
    }

    spec add {
        pragma intrinsic;
    }

    spec borrow {
        pragma intrinsic;
    }

    spec borrow_mut {
        pragma intrinsic;
    }

    spec borrow_mut_with_default {
        pragma intrinsic;
    }

    spec upsert {
        pragma intrinsic;
    }

    spec remove {
        pragma intrinsic;
    }

    spec contains {
        pragma intrinsic;
    }

    // Specification functions for tables
    spec native fun spec_contains<K, V>(t: Table<K, V>, k: K): bool;
    spec native fun spec_remove<K, V>(t: Table<K, V>, k: K): Table<K, V>;
    spec native fun spec_set<K, V>(t: Table<K, V>, k: K, v: V): Table<K, V>;
    spec native fun spec_get<K, V>(t: Table<K, V>, k: K): V;
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/table_with_length.move
================================================
/// Extends Table and provides functions such as length and the ability to be destroyed

module aptos_std::table_with_length {
    use std::error;
    use aptos_std::table::{Self, Table};

    // native code raises this with error::invalid_arguments()
    const EALREADY_EXISTS: u64 = 100;
    // native code raises this with error::invalid_arguments()
    const ENOT_FOUND: u64 = 101;
    const ENOT_EMPTY: u64 = 102;

    /// Type of tables
    struct TableWithLength<phantom K: copy + drop, phantom V> has store {
        inner: Table<K, V>,
        length: u64,
    }

    /// Create a new Table.
    public fun new<K: copy + drop, V: store>(): TableWithLength<K, V> {
        TableWithLength {
            inner: table::new<K, V>(),
            length: 0,
        }
    }

    /// Destroy a table. The table must be empty to succeed.
    public fun destroy_empty<K: copy + drop, V>(table: TableWithLength<K, V>) {
        assert!(table.length == 0, error::invalid_state(ENOT_EMPTY));
        let TableWithLength { inner, length: _ } = table;
        table::destroy(inner)
    }

    /// Add a new entry to the table. Aborts if an entry for this
    /// key already exists. The entry itself is not stored in the
    /// table, and cannot be discovered from it.
    public fun add<K: copy + drop, V>(table: &mut TableWithLength<K, V>, key: K, val: V) {
        table::add(&mut table.inner, key, val);
        table.length = table.length + 1;
    }

    /// Acquire an immutable reference to the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun borrow<K: copy + drop, V>(table: &TableWithLength<K, V>, key: K): &V {
        table::borrow(&table.inner, key)
    }

    /// Acquire a mutable reference to the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun borrow_mut<K: copy + drop, V>(table: &mut TableWithLength<K, V>, key: K): &mut V {
        table::borrow_mut(&mut table.inner, key)
    }

    /// Returns the length of the table, i.e. the number of entries.
    public fun length<K: copy + drop, V>(table: &TableWithLength<K, V>): u64 {
        table.length
    }

    /// Returns true if this table is empty.
    public fun empty<K: copy + drop, V>(table: &TableWithLength<K, V>): bool {
        table.length == 0
    }

    /// Acquire a mutable reference to the value which `key` maps to.
    /// Insert the pair (`key`, `default`) first if there is no entry for `key`.
    public fun borrow_mut_with_default<K: copy + drop, V: drop>(table: &mut TableWithLength<K, V>, key: K, default: V): &mut V {
        if (table::contains(&table.inner, key)) {
            table::borrow_mut(&mut table.inner, key)
        } else {
            table::add(&mut table.inner, key, default);
            table.length = table.length + 1;
            table::borrow_mut(&mut table.inner, key)
        }
    }

    /// Insert the pair (`key`, `value`) if there is no entry for `key`.
    /// update the value of the entry for `key` to `value` otherwise
    public fun upsert<K: copy + drop, V: drop>(table: &mut TableWithLength<K, V>, key: K, value: V) {
        if (!table::contains(&table.inner, key)) {
            add(table, copy key, value)
        } else {
            let ref = table::borrow_mut(&mut table.inner, key);
            *ref = value;
        };
    }

    /// Remove from `table` and return the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun remove<K: copy + drop, V>(table: &mut TableWithLength<K, V>, key: K): V {
        let val = table::remove(&mut table.inner, key);
        table.length = table.length - 1;
        val
    }

    /// Returns true iff `table` contains an entry for `key`.
    public fun contains<K: copy + drop, V>(table: &TableWithLength<K, V>, key: K): bool {
        table::contains(&table.inner, key)
    }

    #[test_only]
    /// Drop table even if not empty, only when testing.
    public fun drop_unchecked<K: copy + drop, V>(table: TableWithLength<K, V>) {
        // Unpack table with length, dropping length count but not
        // inner table.
        let TableWithLength{inner, length: _} = table;
        table::drop_unchecked(inner); // Drop inner table.
    }

    #[test]
    /// Verify test-only drop functionality.
    fun test_drop_unchecked() {
        let table = new<bool, bool>(); // Declare new table.
        add(&mut table, true, false); // Add table entry.
        drop_unchecked(table); // Drop table.
    }

    #[test]
    fun test_upsert() {
        let t = new<u8, u8>();
        // Table should not have key 0 yet
        assert!(!contains(&t, 0), 1);
        // This should insert key 0, with value 10, and length should be 1
        upsert(&mut t, 0, 10);
        // Ensure the value is correctly set to 10
        assert!(*borrow(&t, 0) == 10, 1);
        // Ensure the length is correctly set
        assert!(length(&t) == 1, 1);
        // Lets upsert the value to something else, and verify it's correct
        upsert(&mut t, 0, 23);
        assert!(*borrow(&t, 0) == 23, 1);
        // Since key 0 already existed, the length should not have changed
        assert!(length(&t) == 1, 1);
        // If we upsert a non-existing key, the length should increase
        upsert(&mut t, 1, 7);
        assert!(length(&t) == 2, 1);

        remove(&mut t, 0);
        remove(&mut t, 1);
        destroy_empty(t);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/table_with_length.spec.move
================================================
/// Specifications of the `table_with_length` module.
spec aptos_std::table_with_length {

    // Make most of the public API intrinsic. Those functions have custom specifications in the prover.

    spec TableWithLength {
        pragma intrinsic = map,
            map_new = new,
            map_destroy_empty = destroy_empty,
            map_len = length,
            map_is_empty = empty,
            map_has_key = contains,
            map_add_no_override = add,
            map_add_override_if_exists = upsert,
            map_del_must_exist = remove,
            map_borrow = borrow,
            map_borrow_mut = borrow_mut,
            map_borrow_mut_with_default = borrow_mut_with_default,
            map_spec_get = spec_get,
            map_spec_set = spec_set,
            map_spec_del = spec_remove,
            map_spec_len = spec_len,
            map_spec_has_key = spec_contains;
    }

    spec new {
        pragma intrinsic;
    }

    spec destroy_empty {
        pragma intrinsic;
    }

    spec length {
        pragma intrinsic;
    }

    spec empty {
        pragma intrinsic;
    }

    spec add {
        pragma intrinsic;
    }

    spec borrow {
        pragma intrinsic;
    }

    spec borrow_mut {
        pragma intrinsic;
    }

    spec borrow_mut_with_default {
        aborts_if false;
        pragma intrinsic;
    }

    spec upsert {
        pragma intrinsic;
    }

    spec remove {
        pragma intrinsic;
    }

    spec contains {
        pragma intrinsic;
    }

    // Specification functions for tables
    spec native fun spec_len<K, V>(t: TableWithLength<K, V>): num;
    spec native fun spec_contains<K, V>(t: TableWithLength<K, V>, k: K): bool;
    spec native fun spec_set<K, V>(t: TableWithLength<K, V>, k: K, v: V): TableWithLength<K, V>;
    spec native fun spec_remove<K, V>(t: TableWithLength<K, V>, k: K): TableWithLength<K, V>;
    spec native fun spec_get<K, V>(t: TableWithLength<K, V>, k: K): V;
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/type_info.move
================================================
module aptos_std::type_info {
    use std::bcs;
    use std::features;
    use std::string::{Self, String};
    use std::vector;

    //
    // Error codes
    //

    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 1;

    //
    // Structs
    //

    struct TypeInfo has copy, drop, store {
        account_address: address,
        module_name: vector<u8>,
        struct_name: vector<u8>,
    }

    //
    // Public functions
    //

    public fun account_address(type_info: &TypeInfo): address {
        type_info.account_address
    }

    public fun module_name(type_info: &TypeInfo): vector<u8> {
        type_info.module_name
    }

    public fun struct_name(type_info: &TypeInfo): vector<u8> {
        type_info.struct_name
    }

    /// Returns the current chain ID, mirroring what `aptos_framework::chain_id::get()` would return, except in `#[test]`
    /// functions, where this will always return `4u8` as the chain ID, whereas `aptos_framework::chain_id::get()` will
    /// return whichever ID was passed to `aptos_framework::chain_id::initialize_for_test()`.
    public fun chain_id(): u8 {
        if (!features::aptos_stdlib_chain_id_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        chain_id_internal()
    }

    /// Return the `TypeInfo` struct containing  for the type `T`.
    public native fun type_of<T>(): TypeInfo;

    /// Return the human readable string for the type, including the address, module name, and any type arguments.
    /// Example: 0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>
    /// Or: 0x1::table::Table<0x1::string::String, 0x1::string::String>
    public native fun type_name<T>(): String;

    native fun chain_id_internal(): u8;

    /// Return the BCS size, in bytes, of value at `val_ref`.
    ///
    /// See the [BCS spec](https://github.com/diem/bcs)
    ///
    /// See `test_size_of_val()` for an analysis of common types and
    /// nesting patterns, as well as `test_size_of_val_vectors()` for an
    /// analysis of vector size dynamism.
    public fun size_of_val<T>(val_ref: &T): u64 {
        // Return vector length of vectorized BCS representation.
        vector::length(&bcs::to_bytes(val_ref))
    }

    #[test_only]
    use aptos_std::table::Table;

    #[test]
    fun test_type_of() {
        let type_info = type_of<TypeInfo>();
        assert!(account_address(&type_info) == @aptos_std, 0);
        assert!(module_name(&type_info) == b"type_info", 1);
        assert!(struct_name(&type_info) == b"TypeInfo", 2);
    }

    #[test]
    fun test_type_of_with_type_arg() {
        let type_info = type_of<Table<String, String>>();
        assert!(account_address(&type_info) == @aptos_std, 0);
        assert!(module_name(&type_info) == b"table", 1);
        assert!(struct_name(&type_info) == b"Table<0x1::string::String, 0x1::string::String>", 2);
    }

    #[test(fx = @std)]
    fun test_chain_id(fx: signer) {
        // We need to enable the feature in order for the native call to be allowed.
        features::change_feature_flags_for_testing(&fx, vector[features::get_aptos_stdlib_chain_id_feature()], vector[]);

        // The testing environment chain ID is 4u8.
        assert!(chain_id() == 4u8, 1);
    }

    #[test]
    fun test_type_name() {


        assert!(type_name<bool>() == string::utf8(b"bool"), 0);
        assert!(type_name<u8>() == string::utf8(b"u8"), 1);
        assert!(type_name<u64>() == string::utf8(b"u64"), 2);
        assert!(type_name<u128>() == string::utf8(b"u128"), 3);
        assert!(type_name<address>() == string::utf8(b"address"), 4);
        assert!(type_name<signer>() == string::utf8(b"signer"), 5);

        // vector
        assert!(type_name<vector<u8>>() == string::utf8(b"vector<u8>"), 6);
        assert!(type_name<vector<vector<u8>>>() == string::utf8(b"vector<vector<u8>>"), 7);
        assert!(type_name<vector<vector<TypeInfo>>>() == string::utf8(b"vector<vector<0x1::type_info::TypeInfo>>"), 8);


        // struct
        assert!(type_name<TypeInfo>() == string::utf8(b"0x1::type_info::TypeInfo"), 9);
        assert!(type_name<
            Table<
                TypeInfo,
                Table<u8, vector<TypeInfo>>
            >
        >() == string::utf8(b"0x1::table::Table<0x1::type_info::TypeInfo, 0x1::table::Table<u8, vector<0x1::type_info::TypeInfo>>>"), 10);
    }

    #[verify_only]
    fun verify_type_of() {
        let type_info = type_of<TypeInfo>();
        let account_address = account_address(&type_info);
        let module_name = module_name(&type_info);
        let struct_name = struct_name(&type_info);
        spec {
            assert account_address == @aptos_std;
            assert module_name == b"type_info";
            assert struct_name == b"TypeInfo";
        };
    }

    #[verify_only]
    fun verify_type_of_generic<T>() {
        let type_info = type_of<T>();
        let account_address = account_address(&type_info);
        let module_name = module_name(&type_info);
        let struct_name = struct_name(&type_info);
        spec {
            assert account_address == type_of<T>().account_address;
            assert module_name == type_of<T>().module_name;
            assert struct_name == type_of<T>().struct_name;
        };
    }
    spec verify_type_of_generic {
        aborts_if !spec_is_struct<T>();
    }

    #[test_only]
    struct CustomType has drop {}

    #[test_only]
    struct SimpleStruct has copy, drop {
        field: u8
    }

    #[test_only]
    struct ComplexStruct<T> has copy, drop {
        field_1: bool,
        field_2: u8,
        field_3: u64,
        field_4: u128,
        field_5: SimpleStruct,
        field_6: T
    }

    #[test_only]
    struct TwoBools has drop {
        bool_1: bool,
        bool_2: bool
    }

    #[test_only]
    use std::option;

    #[test(account = @0x0)]
    /// Ensure valid returns across native types and nesting schemas.
    fun test_size_of_val(
        account: &signer
    ) {
        assert!(size_of_val(&false) == 1, 0); // Bool takes 1 byte.
        assert!(size_of_val<u8>(&0) == 1, 0); // u8 takes 1 byte.
        assert!(size_of_val<u64>(&0) == 8, 0); // u64 takes 8 bytes.
        assert!(size_of_val<u128>(&0) == 16, 0); // u128 takes 16 bytes.
        // Address is a u256.
        assert!(size_of_val(&@0x0) == 32, 0);
        assert!(size_of_val(account) == 32, 0); // Signer is an address.
        // Assert custom type without fields has size 1.
        assert!(size_of_val(&CustomType{}) == 1, 0);
        // Declare a simple struct with a 1-byte field.
        let simple_struct = SimpleStruct{field: 0};
        // Assert size is indicated as 1 byte.
        assert!(size_of_val(&simple_struct) == 1, 0);
        let complex_struct = ComplexStruct<u128>{
            field_1: false,
            field_2: 0,
            field_3: 0,
            field_4: 0,
            field_5: simple_struct,
            field_6: 0
        }; // Declare a complex struct with another nested inside.
        // Assert size is bytewise sum of components.
        assert!(size_of_val(&complex_struct) == (1 + 1 + 8 + 16 + 1 + 16), 0);
        // Declare a struct with two boolean values.
        let two_bools = TwoBools{bool_1: false, bool_2: false};
        // Assert size is two bytes.
        assert!(size_of_val(&two_bools) == 2, 0);
        // Declare an empty vector of element type u64.
        let empty_vector_u64 = vector::empty<u64>();
        // Declare an empty vector of element type u128.
        let empty_vector_u128 = vector::empty<u128>();
        // Assert size is 1 byte regardless of underlying element type.
        assert!(size_of_val(&empty_vector_u64) == 1, 0);
        // Assert size is 1 byte regardless of underlying element type.
        assert!(size_of_val(&empty_vector_u128) == 1, 0);
        // Declare a bool in a vector.
        let bool_vector = vector::singleton(false);
        // Push back another bool.
        vector::push_back(&mut bool_vector, false);
        // Assert size is 3 bytes (1 per element, 1 for base vector).
        assert!(size_of_val(&bool_vector) == 3, 0);
        // Get a some option, which is implemented as a vector.
        let u64_option = option::some(0);
        // Assert size is 9 bytes (8 per element, 1 for base vector).
        assert!(size_of_val(&u64_option) == 9, 0);
        option::extract(&mut u64_option); // Remove the value inside.
        // Assert size reduces to 1 byte.
        assert!(size_of_val(&u64_option) == 1, 0);
    }

    #[test]
    /// Verify returns for base vector size at different lengths, with
    /// different underlying fixed-size elements.
    ///
    /// For a vector of length n containing fixed-size elements, the
    /// size of the vector is b + n * s bytes, where s is the size of an
    /// element in bytes, and b is a "base size" in bytes that varies
    /// with n.
    ///
    /// The base size is an artifact of vector BCS encoding, namely,
    /// with b leading bytes that declare how many elements are in the
    /// vector. Each such leading byte has a reserved control bit (e.g.
    /// is this the last leading byte?), such that 7 bits per leading
    /// byte remain for the actual element count. Hence for a single
    /// leading byte, the maximum element count that can be described is
    /// (2 ^ 7) - 1, and for b leading bytes, the maximum element count
    /// that can be described is (2 ^ 7) ^ b - 1:
    ///
    /// * b = 1,                         n < 128
    /// * b = 2,                  128 <= n < 16384
    /// * b = 3,                16384 <= n < 2097152
    /// * ...
    /// *           (2 ^ 7) ^ (b - 1) <= n < (2 ^ 7) ^ b
    /// * ...
    /// * b = 9,    72057594037927936 <= n < 9223372036854775808
    /// * b = 10, 9223372036854775808 <= n < 18446744073709551616
    ///
    /// Note that the upper bound on n for b = 10 is 2 ^ 64, rather than
    /// (2 ^ 7) ^ 10 - 1, because the former, lower figure is the
    /// maximum number of elements that can be stored in a vector in the
    /// first place, e.g. U64_MAX.
    ///
    /// In practice b > 2 is unlikely to be encountered.
    fun test_size_of_val_vectors() {
        // Declare vector base sizes.
        let (base_size_1, base_size_2, base_size_3) = (1, 2, 3);
        // A base size of 1 applies for 127 or less elements.
        let n_elems_cutoff_1 = 127; // (2 ^ 7) ^ 1 - 1.
        // A base size of 2 applies for 128 < n <= 16384 elements.
        let n_elems_cutoff_2 = 16383; // (2 ^ 7) ^ 2 - 1.
        let vector_u64 = vector::empty<u64>(); // Declare empty vector.
        let null_element = 0; // Declare a null element.
        // Get element size.
        let element_size = size_of_val(&null_element);
        // Vector size is 1 byte when length is 0.
        assert!(size_of_val(&vector_u64) == base_size_1, 0);
        let i = 0; // Declare loop counter.
        while (i < n_elems_cutoff_1) { // Iterate until first cutoff:
            // Add an element.
            vector::push_back(&mut vector_u64, null_element);
            i = i + 1; // Increment counter.
        };
        // Vector base size is still 1 byte.
        assert!(size_of_val(&vector_u64) - element_size * i == base_size_1, 0);
        // Add another element, exceeding the cutoff.
        vector::push_back(&mut vector_u64, null_element);
        i = i + 1; // Increment counter.
        // Vector base size is now 2 bytes.
        assert!(size_of_val(&vector_u64) - element_size * i == base_size_2, 0);
        while (i < n_elems_cutoff_2) { // Iterate until second cutoff:
            // Add an element.
            vector::push_back(&mut vector_u64, null_element);
            i = i + 1; // Increment counter.
        };
        // Vector base size is still 2 bytes.
        assert!(size_of_val(&vector_u64) - element_size * i == base_size_2, 0);
        // Add another element, exceeding the cutoff.
        vector::push_back(&mut vector_u64, null_element);
        i = i + 1; // Increment counter.
        // Vector base size is now 3 bytes.
        assert!(size_of_val(&vector_u64) - element_size * i == base_size_3, 0);
        // Repeat for custom struct.
        let vector_complex = vector::empty<ComplexStruct<address>>();
        // Declare a null element.
        let null_element = ComplexStruct{
            field_1: false,
            field_2: 0,
            field_3: 0,
            field_4: 0,
            field_5: SimpleStruct{field: 0},
            field_6: @0x0
        };
        element_size = size_of_val(&null_element); // Get element size.
        // Vector size is 1 byte when length is 0.
        assert!(size_of_val(&vector_complex) == base_size_1, 0);
        i = 0; // Re-initialize loop counter.
        while (i < n_elems_cutoff_1) { // Iterate until first cutoff:
            // Add an element.
            vector::push_back(&mut vector_complex, copy null_element);
            i = i + 1; // Increment counter.
        };
        assert!( // Vector base size is still 1 byte.
            size_of_val(&vector_complex) - element_size * i == base_size_1, 0);
        // Add another element, exceeding the cutoff.
        vector::push_back(&mut vector_complex, null_element);
        i = i + 1; // Increment counter.
        assert!( // Vector base size is now 2 bytes.
            size_of_val(&vector_complex) - element_size * i == base_size_2, 0);
        while (i < n_elems_cutoff_2) { // Iterate until second cutoff:
            // Add an element.
            vector::push_back(&mut vector_complex, copy null_element);
            i = i + 1; // Increment counter.
        };
        assert!( // Vector base size is still 2 bytes.
            size_of_val(&vector_complex) - element_size * i == base_size_2, 0);
        // Add another element, exceeding the cutoff.
        vector::push_back(&mut vector_complex, null_element);
        i = i + 1; // Increment counter.
        assert!( // Vector base size is now 3 bytes.
            size_of_val(&vector_complex) - element_size * i == base_size_3, 0);
    }

}


================================================
File: aptos-move/framework/aptos-stdlib/sources/type_info.spec.move
================================================
spec aptos_std::type_info {

    spec native fun spec_is_struct<T>(): bool;

    spec type_of<T>(): TypeInfo {
        // Move Prover natively supports this function.
        // This function will abort if `T` is not a struct type.
    }

    spec type_name<T>(): string::String {
        // Move Prover natively supports this function.
    }

    spec chain_id(): u8 {
        aborts_if !features::spec_is_enabled(features::APTOS_STD_CHAIN_ID_NATIVES);
        ensures result == spec_chain_id_internal();
    }

    spec chain_id_internal(): u8 {
        pragma opaque;
        aborts_if false;
        ensures result == spec_chain_id_internal();
    }

    // The chain ID is modeled as an uninterpreted function.
    spec fun spec_chain_id_internal(): u8;

    spec fun spec_size_of_val<T>(val_ref: T): u64 {
        len(std::bcs::serialize(val_ref))
    }

    spec size_of_val<T>(val_ref: &T): u64 {
        aborts_if false;
        ensures result == spec_size_of_val<T>(val_ref);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move
================================================
/// Contains functions for:
///
///     The minimum-pubkey-size variant of [Boneh-Lynn-Shacham (BLS) signatures](https://en.wikipedia.org/wiki/BLS_digital_signature),
///     where public keys are BLS12-381 elliptic-curve points in $\mathbb{G}_1$ and signatures are in $\mathbb{G}_2$,
///     as per the [IETF BLS draft standard](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature#section-2.1).

module aptos_std::bls12381 {
    use std::option::{Self, Option};
    #[test_only]
    use std::error::invalid_argument;

    /// The signature size, in bytes
    const SIGNATURE_SIZE: u64 = 96;

    /// The public key size, in bytes
    const PUBLIC_KEY_NUM_BYTES: u64 = 48;

    /// The caller was supposed to input one or more public keys.
    const EZERO_PUBKEYS: u64 = 1;

    /// One of the given inputs has the wrong size.s
    const EWRONG_SIZE: u64 = 2;

    /// The number of signers does not match the number of messages to be signed.
    const E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES: u64 = 3;

    // TODO: Performance would increase if structs in this module are implemented natively via handles (similar to Table and
    // RistrettoPoint). This will avoid unnecessary (de)serialization. We would need to allow storage of these structs too.

    #[test_only]
    struct SecretKey has copy, drop {
        bytes: vector<u8>,
    }

    /// A *validated* public key that:
    ///   (1) is a point in the prime-order subgroup of the BLS12-381 elliptic curve, and
    ///   (2) is not the identity point
    ///
    /// This struct can be used to verify a normal (non-aggregated) signature.
    ///
    /// This struct can be combined with a ProofOfPossession struct in order to create a PublicKeyWithPop struct, which
    /// can be used to verify a multisignature.
    struct PublicKey has copy, drop, store {
        bytes: vector<u8>
    }

    /// A proof-of-possession (PoP).
    /// Given such a struct and a PublicKey struct, one can construct a PublicKeyWithPoP (see below).
    struct ProofOfPossession has copy, drop, store {
        bytes: vector<u8>
    }

    /// A *validated* public key that had a successfully-verified proof-of-possession (PoP).
    ///
    /// A vector of these structs can be either:
    ///   (1) used to verify an aggregate signature
    ///   (2) aggregated with other PublicKeyWithPoP structs into an AggrPublicKeysWithPoP, which in turn can be used
    ///       to verify a multisignature
    struct PublicKeyWithPoP has copy, drop, store {
        bytes: vector<u8>
    }

    /// An aggregation of public keys with verified PoPs, which can be used to verify multisignatures.
    struct AggrPublicKeysWithPoP has copy, drop, store {
        bytes: vector<u8>
    }

    /// A BLS signature. This can be either a:
    ///   (1) normal (non-aggregated) signature
    ///   (2) signature share (for a multisignature or aggregate signature)
    struct Signature has copy, drop, store {
        bytes: vector<u8>
    }

    /// An aggregation of BLS signatures. This can be either a:
    ///   (4) aggregated signature (i.e., an aggregation of signatures s_i, each on a message m_i)
    ///   (3) multisignature (i.e., an aggregation of signatures s_i, each on the same message m)
    ///
    /// We distinguish between a Signature type and a AggrOrMultiSignature type to prevent developers from interchangeably
    /// calling `verify_multisignature` and `verify_signature_share` to verify both multisignatures and signature shares,
    /// which could create problems down the line.
    struct AggrOrMultiSignature has copy, drop, store {
        bytes: vector<u8>
    }

    /// Creates a new public key from a sequence of bytes.
    public fun public_key_from_bytes(bytes: vector<u8>): Option<PublicKey> {
        if (validate_pubkey_internal(bytes)) {
            option::some(PublicKey {
                bytes
            })
        } else {
            option::none<PublicKey>()
        }
    }

    /// Serializes a public key into 48 bytes.
    public fun public_key_to_bytes(pk: &PublicKey): vector<u8> {
        pk.bytes
    }

    /// Creates a new proof-of-possession (PoP) which can be later used to create a PublicKeyWithPoP struct,
    public fun proof_of_possession_from_bytes(bytes: vector<u8>): ProofOfPossession {
        ProofOfPossession {
            bytes
        }
    }

    /// Serializes the signature into 96 bytes.
    public fun proof_of_possession_to_bytes(pop: &ProofOfPossession): vector<u8> {
        pop.bytes
    }

    /// Creates a PoP'd public key from a normal public key and a corresponding proof-of-possession.
    public fun public_key_from_bytes_with_pop(pk_bytes: vector<u8>, pop: &ProofOfPossession): Option<PublicKeyWithPoP> {
        if (verify_proof_of_possession_internal(pk_bytes, pop.bytes)) {
            option::some(PublicKeyWithPoP {
                bytes: pk_bytes
            })
        } else {
            option::none<PublicKeyWithPoP>()
        }
    }

    /// Creates a normal public key from a PoP'd public key.
    public fun public_key_with_pop_to_normal(pkpop: &PublicKeyWithPoP): PublicKey {
        PublicKey {
            bytes: pkpop.bytes
        }
    }

    /// Serializes a PoP'd public key into 48 bytes.
    public fun public_key_with_pop_to_bytes(pk: &PublicKeyWithPoP): vector<u8> {
        pk.bytes
    }

    /// Creates a new signature from a sequence of bytes. Does not check the signature for prime-order subgroup
    /// membership since that is done implicitly during verification.
    public fun signature_from_bytes(bytes: vector<u8>): Signature {
        Signature {
            bytes
        }
    }

    /// Serializes the signature into 96 bytes.
    public fun signature_to_bytes(sig: &Signature): vector<u8> {
        sig.bytes
    }

    /// Checks that the group element that defines a signature is in the prime-order subgroup.
    /// This check is implicitly performed when verifying any signature via this module, but we expose this functionality
    /// in case it might be useful for applications to easily dismiss invalid signatures early on.
    public fun signature_subgroup_check(signature: &Signature): bool {
        signature_subgroup_check_internal(signature.bytes)
    }

    /// Given a vector of public keys with verified PoPs, combines them into an *aggregated* public key which can be used
    /// to verify multisignatures using `verify_multisignature` and aggregate signatures using `verify_aggregate_signature`.
    /// Aborts if no public keys are given as input.
    public fun aggregate_pubkeys(public_keys: vector<PublicKeyWithPoP>): AggrPublicKeysWithPoP {
        let (bytes, success) = aggregate_pubkeys_internal(public_keys);
        assert!(success, std::error::invalid_argument(EZERO_PUBKEYS));

        AggrPublicKeysWithPoP {
            bytes
        }
    }

    /// Serializes an aggregate public key into 48 bytes.
    public fun aggregate_pubkey_to_bytes(apk: &AggrPublicKeysWithPoP): vector<u8> {
        apk.bytes
    }

    /// Aggregates the input signatures into an aggregate-or-multi-signature structure, which can be later verified via
    /// `verify_aggregate_signature` or `verify_multisignature`. Returns `None` if zero signatures are given as input
    /// or if some of the signatures are not valid group elements.
    public fun aggregate_signatures(signatures: vector<Signature>): Option<AggrOrMultiSignature> {
        let (bytes, success) = aggregate_signatures_internal(signatures);
        if (success) {
            option::some(
                AggrOrMultiSignature {
                    bytes
                }
            )
        } else {
            option::none<AggrOrMultiSignature>()
        }
    }

    /// Serializes an aggregate-or-multi-signature into 96 bytes.
    public fun aggr_or_multi_signature_to_bytes(sig: &AggrOrMultiSignature): vector<u8> {
        sig.bytes
    }

    /// Deserializes an aggregate-or-multi-signature from 96 bytes.
    public fun aggr_or_multi_signature_from_bytes(bytes: vector<u8>): AggrOrMultiSignature {
        assert!(std::vector::length(&bytes) == SIGNATURE_SIZE, std::error::invalid_argument(EWRONG_SIZE));

        AggrOrMultiSignature {
            bytes
        }
    }


    /// Checks that the group element that defines an aggregate-or-multi-signature is in the prime-order subgroup.
    public fun aggr_or_multi_signature_subgroup_check(signature: &AggrOrMultiSignature): bool {
        signature_subgroup_check_internal(signature.bytes)
    }

    /// Verifies an aggregate signature, an aggregation of many signatures `s_i`, each on a different message `m_i`.
    public fun verify_aggregate_signature(
        aggr_sig: &AggrOrMultiSignature,
        public_keys: vector<PublicKeyWithPoP>,
        messages: vector<vector<u8>>,
    ): bool {
        verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages)
    }

    /// Verifies a multisignature: an aggregation of many signatures, each on the same message `m`.
    public fun verify_multisignature(
        multisig: &AggrOrMultiSignature,
        aggr_public_key: &AggrPublicKeysWithPoP,
        message: vector<u8>
    ): bool {
        verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message)
    }

    /// Verifies a normal, non-aggregated signature.
    public fun verify_normal_signature(
        signature: &Signature,
        public_key: &PublicKey,
        message: vector<u8>
    ): bool {
        verify_normal_signature_internal(signature.bytes, public_key.bytes, message)
    }

    /// Verifies a signature share in the multisignature share or an aggregate signature share.
    public fun verify_signature_share(
        signature_share: &Signature,
        public_key: &PublicKeyWithPoP,
        message: vector<u8>
    ): bool {
        verify_signature_share_internal(signature_share.bytes, public_key.bytes, message)
    }

    #[test_only]
    /// Generates a BLS key-pair: a secret key with its corresponding public key.
    public fun generate_keys(): (SecretKey, PublicKeyWithPoP) {
        let (sk_bytes, pk_bytes) = generate_keys_internal();
        let sk = SecretKey {
            bytes: sk_bytes
        };
        let pkpop = PublicKeyWithPoP {
            bytes: pk_bytes
        };
        (sk, pkpop)
    }

    #[test_only]
    /// Generates a BLS signature for a message with a signing key.
    public fun sign_arbitrary_bytes(signing_key: &SecretKey, message: vector<u8>): Signature {
        Signature {
            bytes: sign_internal(signing_key.bytes, message)
        }
    }

    #[test_only]
    /// Generates a multi-signature for a message with multiple signing keys.
    public fun multi_sign_arbitrary_bytes(signing_keys: &vector<SecretKey>, message: vector<u8>): AggrOrMultiSignature {
        let n = std::vector::length(signing_keys);
        let sigs = vector[];
        let i: u64 = 0;
        while (i < n) {
            let sig = sign_arbitrary_bytes(std::vector::borrow(signing_keys, i), message);
            std::vector::push_back(&mut sigs, sig);
            i = i + 1;
        };
        let multisig = aggregate_signatures(sigs);
        option::extract(&mut multisig)
    }

    #[test_only]
    /// Generates an aggregated signature over all messages in messages, where signing_keys[i] signs messages[i].
    public fun aggr_sign_arbitrary_bytes(signing_keys: &vector<SecretKey>, messages: &vector<vector<u8>>): AggrOrMultiSignature {
        let signing_key_count = std::vector::length(signing_keys);
        let message_count = std::vector::length(messages);
        assert!(signing_key_count == message_count, invalid_argument(E_NUM_SIGNERS_MUST_EQ_NUM_MESSAGES));
        let sigs = vector[];
        let i: u64 = 0;
        while (i < signing_key_count) {
            let sig = sign_arbitrary_bytes(std::vector::borrow(signing_keys, i), *std::vector::borrow(messages, i));
            std::vector::push_back(&mut sigs, sig);
            i = i + 1;
        };
        let aggr_sig = aggregate_signatures(sigs);
        option::extract(&mut aggr_sig)
    }

    #[test_only]
    /// Returns a mauled copy of a byte array.
    public fun maul_bytes(bytes: &vector<u8>): vector<u8> {
        let new_bytes = *bytes;
        let first_byte = std::vector::borrow_mut(&mut new_bytes, 0);
        *first_byte = *first_byte ^ 0xff;
        new_bytes
    }

    #[test_only]
    /// Returns a mauled copy of a normal signature.
    public fun maul_signature(sig: &Signature): Signature {
        Signature {
            bytes: maul_bytes(&signature_to_bytes(sig))
        }
    }

    #[test_only]
    /// Returns a mauled copy of an aggregated signature or a multi-signature.
    public fun maul_aggr_or_multi_signature(sig: &AggrOrMultiSignature): AggrOrMultiSignature {
        AggrOrMultiSignature {
            bytes: maul_bytes(&aggr_or_multi_signature_to_bytes(sig))
        }
    }

    #[test_only]
    /// Returns a mauled copy of a normal public key.
    public fun maul_public_key(pk: &PublicKey): PublicKey {
        PublicKey {
            bytes: maul_bytes(&public_key_to_bytes(pk))
        }
    }

    #[test_only]
    /// Returns a mauled copy of a PoP'd public key.
    public fun maul_public_key_with_pop(pk: &PublicKeyWithPoP): PublicKeyWithPoP {
        PublicKeyWithPoP {
            bytes: maul_bytes(&public_key_with_pop_to_bytes(pk))
        }
    }

    #[test_only]
    /// Returns a mauled copy of an aggregated public key.
    public fun maul_aggregated_public_key(pk: &AggrPublicKeysWithPoP): AggrPublicKeysWithPoP {
        AggrPublicKeysWithPoP {
            bytes: maul_bytes(&aggregate_pubkey_to_bytes(pk))
        }
    }

    #[test_only]
    /// Returns a mauled copy of a proof-of-possession.
    public fun maul_proof_of_possession(pop: &ProofOfPossession): ProofOfPossession {
        ProofOfPossession {
            bytes: maul_bytes(&proof_of_possession_to_bytes(pop))
        }
    }


    #[test_only]
    /// Generates a proof-of-possession (PoP) for the public key associated with the secret key `sk`.
    public fun generate_proof_of_possession(sk: &SecretKey): ProofOfPossession {
        ProofOfPossession {
            bytes: generate_proof_of_possession_internal(sk.bytes)
        }
    }

    //
    // Native functions
    //

    /// CRYPTOGRAPHY WARNING: This function assumes that the caller verified all public keys have a valid
    /// proof-of-possesion (PoP) using `verify_proof_of_possession`.
    ///
    /// Given a vector of serialized public keys, combines them into an aggregated public key, returning `(bytes, true)`,
    /// where `bytes` store the serialized public key.
    /// Aborts if no public keys are given as input.
    native fun aggregate_pubkeys_internal(public_keys: vector<PublicKeyWithPoP>): (vector<u8>, bool);


    /// CRYPTOGRAPHY WARNING: This function can be safely called without verifying that the input signatures are elements
    /// of the prime-order subgroup of the BLS12-381 curve.
    ///
    /// Given a vector of serialized signatures, combines them into an aggregate signature, returning `(bytes, true)`,
    /// where `bytes` store the serialized signature.
    /// Does not check the input signatures nor the final aggregated signatures for prime-order subgroup membership.
    /// Returns `(_, false)` if no signatures are given as input.
    /// Does not abort.
    native fun aggregate_signatures_internal(signatures: vector<Signature>): (vector<u8>, bool);

    /// Return `true` if the bytes in `public_key` are a valid BLS12-381 public key:
    ///  (1) it is NOT the identity point, and
    ///  (2) it is a BLS12-381 elliptic curve point, and
    ///  (3) it is a prime-order point
    /// Return `false` otherwise.
    /// Does not abort.
    native fun validate_pubkey_internal(public_key: vector<u8>): bool;

    /// Return `true` if the elliptic curve point serialized in `signature`:
    ///  (1) is NOT the identity point, and
    ///  (2) is a BLS12-381 elliptic curve point, and
    ///  (3) is a prime-order point
    /// Return `false` otherwise.
    /// Does not abort.
    native fun signature_subgroup_check_internal(signature: vector<u8>): bool;

    /// CRYPTOGRAPHY WARNING: First, this function assumes all public keys have a valid proof-of-possesion (PoP).
    /// This prevents both small-subgroup attacks and rogue-key attacks. Second, this function can be safely called
    /// without verifying that the aggregate signature is in the prime-order subgroup of the BLS12-381 curve.
    ///
    /// Returns `true` if the aggregate signature `aggsig` on `messages` under `public_keys` verifies (where `messages[i]`
    /// should be signed by `public_keys[i]`).
    ///
    /// Returns `false` if either:
    /// - no public keys or messages are given as input,
    /// - number of messages does not equal number of public keys
    /// - `aggsig` (1) is the identity point, or (2) is NOT a BLS12-381 elliptic curve point, or (3) is NOT a
    ///   prime-order point
    /// Does not abort.
    native fun verify_aggregate_signature_internal(
        aggsig: vector<u8>,
        public_keys: vector<PublicKeyWithPoP>,
        messages: vector<vector<u8>>,
    ): bool;

    /// CRYPTOGRAPHY WARNING: This function assumes verified proofs-of-possesion (PoP) for the public keys used in
    /// computing the aggregate public key. This prevents small-subgroup attacks and rogue-key attacks.
    ///
    /// Return `true` if the BLS `multisignature` on `message` verifies against the BLS aggregate public key `agg_public_key`.
    /// Returns `false` otherwise.
    /// Does not abort.
    native fun verify_multisignature_internal(
        multisignature: vector<u8>,
        agg_public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    /// CRYPTOGRAPHY WARNING: This function WILL check that the public key is a prime-order point, in order to prevent
    /// library users from misusing the library by forgetting to validate public keys before giving them as arguments to
    /// this function.
    ///
    /// Returns `true` if the `signature` on `message` verifies under `public key`.
    /// Returns `false` otherwise.
    /// Does not abort.
    native fun verify_normal_signature_internal(
        signature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    /// Return `true` if the bytes in `public_key` are a valid bls12381 public key (as per `validate_pubkey`)
    /// *and* this public key has a valid proof-of-possesion (PoP).
    /// Return `false` otherwise.
    /// Does not abort.
    native fun verify_proof_of_possession_internal(
        public_key: vector<u8>,
        proof_of_possesion: vector<u8>
    ): bool;

    /// CRYPTOGRAPHY WARNING: Assumes the public key has a valid proof-of-possesion (PoP). This prevents rogue-key
    /// attacks later on during signature aggregation.
    ///
    /// Returns `true` if the `signature_share` on `message` verifies under `public key`.
    /// Returns `false` otherwise, similar to `verify_multisignature`.
    /// Does not abort.
    native fun verify_signature_share_internal(
        signature_share: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    #[test_only]
    native fun generate_keys_internal(): (vector<u8>, vector<u8>);

    #[test_only]
    native fun sign_internal(sk: vector<u8>, msg: vector<u8>): vector<u8>;

    #[test_only]
    native fun generate_proof_of_possession_internal(sk: vector<u8>): vector<u8>;

    //
    // Constants and helpers for tests
    //

    /// Random signature generated by running `cargo test -- bls12381_sample_signature --nocapture --include-ignored` in `crates/aptos-crypto`.
    /// The message signed is "Hello Aptos!" and the associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.
    const RANDOM_SIGNATURE: vector<u8> = x"a01a65854f987d3434149b7f08f70730e30b241984e8712bc2aca885d632aafced4c3f661209debb6b1c8601326623cc16ca2f6c9edc53b7b88b7435fb6b05ddece418d2c34dc6aca2f5a11a79e67774582c14084a01dcb7820e4cb4bad0ea8d";

    /// Random signature generated by running `cargo test -- bls12381_sample_signature --nocapture --include-ignored` in `crates/aptos-crypto`.
    /// The associated SK is 07416693b6b32c84abe45578728e2379f525729e5b94762435a31e65ecc728da.
    const RANDOM_PK: vector<u8> = x"8a53e7ae5270e3e765cd8a4032c2e77c6f7e87a44ebb85bf28a4d7865565698f975346714262f9e47c6f3e0d5d951660";

    //
    // Tests
    //

    #[test_only]
    fun get_random_aggsig(): AggrOrMultiSignature {
        assert!(signature_subgroup_check_internal(RANDOM_SIGNATURE), 1);

        AggrOrMultiSignature { bytes: RANDOM_SIGNATURE }
    }

    #[test_only]
    fun get_random_pk_with_pop(): PublicKeyWithPoP {
        assert!(validate_pubkey_internal(RANDOM_PK), 1);

        PublicKeyWithPoP {
            bytes: RANDOM_PK
        }
    }

    #[test]
    fun test_pubkey_validation() {
        // test low order points (in group for PK)
        assert!(option::is_none(&public_key_from_bytes(x"ae3cd9403b69c20a0d455fd860e977fe6ee7140a7f091f26c860f2caccd3e0a7a7365798ac10df776675b3a67db8faa0")), 1);
        assert!(option::is_none(&public_key_from_bytes(x"928d4862a40439a67fd76a9c7560e2ff159e770dcf688ff7b2dd165792541c88ee76c82eb77dd6e9e72c89cbf1a56a68")), 1);
        assert!(option::is_some(&public_key_from_bytes(x"b3e4921277221e01ed71284be5e3045292b26c7f465a6fcdba53ee47edd39ec5160da3b229a73c75671024dcb36de091")), 1);
    }

    #[test]
    #[expected_failure(abort_code = 65537, location = Self)]
    fun test_empty_pubkey_aggregation() {
        // First, make sure if no inputs are given, the function returns None
        // assert!(aggregate_pop_verified_pubkeys(vector::empty()) == option::none(), 1);
        aggregate_pubkeys(std::vector::empty());
    }

    #[test]
    fun test_pubkey_aggregation() {
        // Second, try some test-cases generated by running the following command in `crates/aptos-crypto`:
        //  $ cargo test -- sample_aggregate_pk_and_multisig --nocapture --include-ignored
        let pks = vector[
            PublicKeyWithPoP { bytes: x"92e201a806af246f805f460fbdc6fc90dd16a18d6accc236e85d3578671d6f6690dde22134d19596c58ce9d63252410a" },
            PublicKeyWithPoP { bytes: x"ab9df801c6f96ade1c0490c938c87d5bcc2e52ccb8768e1b5d14197c5e8bfa562783b96711b702dda411a1a9f08ebbfa" },
            PublicKeyWithPoP { bytes: x"b698c932cf7097d99c17bd6e9c9dc4eeba84278c621700a8f80ec726b1daa11e3ab55fc045b4dbadefbeef05c4182494" },
            PublicKeyWithPoP { bytes: x"934706a8b876d47a996d427e1526ce52c952d5ec0858d49cd262efb785b62b1972d06270b0a7adda1addc98433ad1843" },
            PublicKeyWithPoP { bytes: x"a4cd352daad3a0651c1998dfbaa7a748e08d248a54347544bfedd51a197e016bb6008e9b8e45a744e1a030cc3b27d2da" },
        ];

        // agg_pks[i] = \sum_{j <= i}  pk[j]
        let agg_pks = vector[
            AggrPublicKeysWithPoP { bytes: x"92e201a806af246f805f460fbdc6fc90dd16a18d6accc236e85d3578671d6f6690dde22134d19596c58ce9d63252410a" },
            AggrPublicKeysWithPoP { bytes: x"b79ad47abb441d7eda9b220a626df2e4e4910738c5f777947f0213398ecafae044ec0c20d552d1348347e9abfcf3eca1" },
            AggrPublicKeysWithPoP { bytes: x"b5f5eb6153ab5388a1a76343d714e4a2dcf224c5d0722d1e8e90c6bcead05c573fffe986460bd4000645a655bf52bc60" },
            AggrPublicKeysWithPoP { bytes: x"b922006ec14c183572a8864c31dc6632dccffa9f9c86411796f8b1b5a93a2457762c8e2f5ef0a2303506c4bca9a4e0bf" },
            AggrPublicKeysWithPoP { bytes: x"b53df1cfee2168f59e5792e710bf22928dc0553e6531dae5c7656c0a66fc12cb82fbb04863938c953dc901a5a79cc0f3" },
        ];

        let i = 0;
        let accum_pk = std::vector::empty<PublicKeyWithPoP>();
        while (i < std::vector::length(&pks)) {
            std::vector::push_back(&mut accum_pk, *std::vector::borrow(&pks, i));

            let apk = aggregate_pubkeys(accum_pk);

            // Make sure PKs were aggregated correctly
            assert!(apk == *std::vector::borrow(&agg_pks, i), 1);
            assert!(validate_pubkey_internal(apk.bytes), 1);

            i = i + 1;
        };
    }

    #[test]
    fun test_pubkey_validation_against_invalid_keys() {
        let (_sk, pk) = generate_keys();
        let pk_bytes = public_key_with_pop_to_bytes(&pk);
        assert!(option::is_some(&public_key_from_bytes(pk_bytes)), 1);
        assert!(option::is_none(&public_key_from_bytes(maul_bytes(&pk_bytes))), 1);
    }

    #[test]
    fun test_signature_aggregation() {
        // First, test empty aggregation
        assert!(option::is_none(&mut aggregate_signatures(vector[])), 1);

        // Second, try some test-cases generated by running the following command in `crates/aptos-crypto`:
        //  $ cargo test -- sample_aggregate_sigs --nocapture --include-ignored

        // Signatures of each signer i
        let sigs = vector[
            signature_from_bytes(x"a55ac2d64b4c1d141b15d876d3e54ad1eea07ee488e8287cce7cdf3eec551458ab5795ab196f8c112590346f7bc7c97e0053cd5be0f9bd74b93a87cd44458e98d125d6d5c6950ea5e62666beb34422ead79121f8cb0815dae41a986688d03eaf"),
            signature_from_bytes(x"90a639a44491191c46379a843266c293de3a46197714ead2ad3886233dd5c2b608b6437fa32fbf9d218b20f1cbfa7970182663beb9c148e2e9412b148e16abf283ffa51b8a536c0e55d61b2e5c849edc49f636c0ef07cb99f125cbcf602e22bb"),
            signature_from_bytes(x"9527d81aa15863ef3a3bf96bea6d58157d5063a93a6d0eb9d8b4f4bbda3b31142ec4586cb519da2cd7600941283d1bad061b5439703fd584295b44037a969876962ae1897dcc7cadf909d06faae213c4fef8e015dfb33ec109af02ab0c3f6833"),
            signature_from_bytes(x"a54d264f5cab9654b1744232c4650c42b29adf2b19bd00bbdaf4a4d792ee4dfd40a1fe1b067f298bcfd8ae4fdc8250660a2848bd4a80d96585afccec5c6cfa617033dd7913c9acfdf98a72467e8a5155d4cad589a72d6665be7cb410aebc0068"),
            signature_from_bytes(x"8d22876bdf73e6ad36ed98546018f6258cd47e45904b87c071e774a6ef4b07cac323258cb920b2fe2b07cca1f2b24bcb0a3194ec76f32edb92391ed2c39e1ada8919f8ea755c5e39873d33ff3a8f4fba21b1261c1ddb9d1688c2b40b77e355d1"),
        ];

        // multisigs[i] is a signature on "Hello, Aptoverse!" from signers 1 through i (inclusive)
        let multisigs = vector[
            AggrOrMultiSignature { bytes: x"a55ac2d64b4c1d141b15d876d3e54ad1eea07ee488e8287cce7cdf3eec551458ab5795ab196f8c112590346f7bc7c97e0053cd5be0f9bd74b93a87cd44458e98d125d6d5c6950ea5e62666beb34422ead79121f8cb0815dae41a986688d03eaf" },
            AggrOrMultiSignature { bytes: x"8f1949a06b95c3cb62898d861f889350c0d2cb740da513bfa195aa0ab8fa006ea2efe004a7bbbd9bb363637a279aed20132efd0846f520e7ee0e8ed847a1c6969bb986ad2239bcc9af561b6c2aa6d3016e1c722146471f1e28313de189fe7ebc" },
            AggrOrMultiSignature { bytes: x"ab5ad42bb8f350f8a6b4ae897946a05dbe8f2b22db4f6c37eff6ff737aebd6c5d75bd1abdfc99345ac8ec38b9a449700026f98647752e1c99f69bb132340f063b8a989728e0a3d82a753740bf63e5d8f51e413ebd9a36f6acbe1407a00c4b3e7" },
            AggrOrMultiSignature { bytes: x"ae307a0d055d3ba55ad6ec7094adef27ed821bdcf735fb509ab2c20b80952732394bc67ea1fd8c26ea963540df7448f8102509f7b8c694e4d75f30a43c455f251b6b3fd8b580b9228ffeeb9039834927aacefccd3069bef4b847180d036971cf" },
            AggrOrMultiSignature { bytes: x"8284e4e3983f29cb45020c3e2d89066df2eae533a01cb6ca2c4d466b5e02dd22467f59640aa120db2b9cc49e931415c3097e3d54ff977fd9067b5bc6cfa1c885d9d8821aef20c028999a1d97e783ae049d8fa3d0bbac36ce4ca8e10e551d3461" },
        ];

        let i = 0;
        let accum_sigs = std::vector::empty<Signature>();
        while (i < std::vector::length(&sigs)) {
            std::vector::push_back(&mut accum_sigs, *std::vector::borrow(&sigs, i));

            let multisig = option::extract(&mut aggregate_signatures(accum_sigs));

            // Make sure sigs were aggregated correctly
            assert!(multisig == *std::vector::borrow(&multisigs, i), 1);
            assert!(signature_subgroup_check_internal(multisig.bytes), 1);

            i = i + 1;
        };
    }

    #[test]
    fun test_empty_signature_aggregation() {
        assert!(option::is_none(&mut aggregate_signatures(vector[])), 1);
    }

    #[test]
    fun test_verify_multisig() {
        // Second, try some test-cases generated by running the following command in `crates/aptos-crypto`:
        //  $ cargo test -- sample_aggregate_pk_and_multisig --nocapture --include-ignored
        let pks = vector[
            PublicKeyWithPoP { bytes: x"92e201a806af246f805f460fbdc6fc90dd16a18d6accc236e85d3578671d6f6690dde22134d19596c58ce9d63252410a" },
            PublicKeyWithPoP { bytes: x"ab9df801c6f96ade1c0490c938c87d5bcc2e52ccb8768e1b5d14197c5e8bfa562783b96711b702dda411a1a9f08ebbfa" },
            PublicKeyWithPoP { bytes: x"b698c932cf7097d99c17bd6e9c9dc4eeba84278c621700a8f80ec726b1daa11e3ab55fc045b4dbadefbeef05c4182494" },
            PublicKeyWithPoP { bytes: x"934706a8b876d47a996d427e1526ce52c952d5ec0858d49cd262efb785b62b1972d06270b0a7adda1addc98433ad1843" },
            PublicKeyWithPoP { bytes: x"a4cd352daad3a0651c1998dfbaa7a748e08d248a54347544bfedd51a197e016bb6008e9b8e45a744e1a030cc3b27d2da" },
        ];

        // agg_pks[i] = \sum_{j <= i}  pk[j]
        let agg_pks = vector[
            AggrPublicKeysWithPoP { bytes: x"92e201a806af246f805f460fbdc6fc90dd16a18d6accc236e85d3578671d6f6690dde22134d19596c58ce9d63252410a" },
            AggrPublicKeysWithPoP { bytes: x"b79ad47abb441d7eda9b220a626df2e4e4910738c5f777947f0213398ecafae044ec0c20d552d1348347e9abfcf3eca1" },
            AggrPublicKeysWithPoP { bytes: x"b5f5eb6153ab5388a1a76343d714e4a2dcf224c5d0722d1e8e90c6bcead05c573fffe986460bd4000645a655bf52bc60" },
            AggrPublicKeysWithPoP { bytes: x"b922006ec14c183572a8864c31dc6632dccffa9f9c86411796f8b1b5a93a2457762c8e2f5ef0a2303506c4bca9a4e0bf" },
            AggrPublicKeysWithPoP { bytes: x"b53df1cfee2168f59e5792e710bf22928dc0553e6531dae5c7656c0a66fc12cb82fbb04863938c953dc901a5a79cc0f3" },
        ];

        // multisigs[i] is a signature on "Hello, Aptoverse!" under agg_pks[i]
        let multisigs = vector[
            AggrOrMultiSignature { bytes: x"ade45c67bff09ae57e0575feb0be870f2d351ce078e8033d847615099366da1299c69497027b77badb226ff1708543cd062597030c3f1553e0aef6c17e7af5dd0de63c1e4f1f9da68c966ea6c1dcade2cdc646bd5e8bcd4773931021ec5be3fd" },
            AggrOrMultiSignature { bytes: x"964af3d83436f6a9a382f34590c0c14e4454dc1de536af205319ce1ed417b87a2374863d5df7b7d5ed900cf91dffa7a105d3f308831d698c0d74fb2259d4813434fb86425db0ded664ae8f85d02ec1d31734910317d4155cbf69017735900d4d" },
            AggrOrMultiSignature { bytes: x"b523a31813e771e55aa0fc99a48db716ecc1085f9899ccadb64e759ecb481a2fb1cdcc0b266f036695f941361de773081729311f6a1bca9d47393f5359c8c87dc34a91f5dae335590aacbff974076ad1f910dd81750553a72ccbcad3c8cc0f07" },
            AggrOrMultiSignature { bytes: x"a945f61699df58617d37530a85e67bd1181349678b89293951ed29d1fb7588b5c12ebb7917dfc9d674f3f4fde4d062740b85a5f4927f5a4f0091e46e1ac6e41bbd650a74dd49e91445339d741e3b10bdeb9bc8bba46833e0011ff91fa5c77bd2" },
            AggrOrMultiSignature { bytes: x"b627b2cfd8ae59dcf5e58cc6c230ae369985fd096e1bc3be38da5deafcbed7d939f07cccc75383539940c56c6b6453db193f563f5b6e4fe54915afd9e1baea40a297fa7eda74abbdcd4cc5c667d6db3b9bd265782f7693798894400f2beb4637" },
        ];

        let i = 0;
        let accum_pk = std::vector::empty<PublicKeyWithPoP>();
        while (i < std::vector::length(&pks)) {
            std::vector::push_back(&mut accum_pk, *std::vector::borrow(&pks, i));

            let apk = aggregate_pubkeys(accum_pk);

            assert!(apk == *std::vector::borrow(&agg_pks, i), 1);

            assert!(verify_multisignature(std::vector::borrow(&multisigs, i), &apk, b"Hello, Aptoverse!"), 1);

            i = i + 1;
        };
    }

    #[test]
    fun test_verify_multisignature_randomized() {
        let signer_count = 1;
        let max_signer_count = 5;
        let msg = b"hello world";
        while (signer_count <= max_signer_count) {
            // Generate key pairs.
            let signing_keys = vector[];
            let public_keys = vector[];
            let i = 0;
            while (i < signer_count) {
                let (sk, pk) = generate_keys();
                std::vector::push_back(&mut signing_keys, sk);
                std::vector::push_back(&mut public_keys, pk);
                i = i + 1;
            };

            // Generate multi-signature.
            let aggr_pk = aggregate_pubkeys(public_keys);
            let multisig = multi_sign_arbitrary_bytes(&signing_keys, msg);

            // Test signature verification.
            assert!(verify_multisignature(&multisig, &aggr_pk, msg), 1);
            assert!(!verify_multisignature(&maul_aggr_or_multi_signature(&multisig), &aggr_pk, msg), 1);
            assert!(!verify_multisignature(&multisig, &maul_aggregated_public_key(&aggr_pk), msg), 1);
            assert!(!verify_multisignature(&multisig, &aggr_pk, maul_bytes(&msg)), 1);

            // Also test signature aggregation.
            let signatures = vector[];
            let i = 0;
            while (i < signer_count) {
                let sk = std::vector::borrow(&signing_keys, i);
                let sig = sign_arbitrary_bytes(sk, msg);
                std::vector::push_back(&mut signatures, sig);
                i = i + 1;
            };
            let aggregated_signature = option::extract(&mut aggregate_signatures(signatures));
            assert!(aggr_or_multi_signature_subgroup_check(&aggregated_signature), 1);
            assert!(aggr_or_multi_signature_to_bytes(&aggregated_signature) == aggr_or_multi_signature_to_bytes(&multisig), 1);

            signer_count = signer_count + 1;
        }
    }

    #[test]
    fun test_verify_aggsig() {
        assert!(aggr_or_multi_signature_to_bytes(&aggr_or_multi_signature_from_bytes(RANDOM_SIGNATURE)) == RANDOM_SIGNATURE, 1);

        // First, make sure verification returns None when no inputs are given or |pks| != |msgs|
        assert!(verify_aggregate_signature(&get_random_aggsig(), vector[], vector[]) == false, 1);

        assert!(verify_aggregate_signature(
            &get_random_aggsig(),
            vector[ get_random_pk_with_pop() ],
            vector[]) == false, 1);

        assert!(verify_aggregate_signature(
            &get_random_aggsig(),
            vector[],
            vector[ x"ab" ]) == false, 1);

        assert!(verify_aggregate_signature(
            &get_random_aggsig(),
            vector[ get_random_pk_with_pop() ],
            vector[
                x"cd", x"ef"
            ]) == false, 1);

        assert!(verify_aggregate_signature(
            &get_random_aggsig(),
            vector[
                get_random_pk_with_pop(),
                get_random_pk_with_pop(),
                get_random_pk_with_pop(),
            ],
            vector[
                x"cd", x"ef"
            ]) == false, 1);

        // Second, try some test-cases generated by running the following command in `crates/aptos-crypto`:
        //  $ cargo test -- bls12381_sample_aggregate_pk_and_aggsig --nocapture --ignored

        // The signed messages are "Hello, Aptos <i>!", where <i> \in {1, ..., 5}
        let msgs = vector[
            x"48656c6c6f2c204170746f73203121",
            x"48656c6c6f2c204170746f73203221",
            x"48656c6c6f2c204170746f73203321",
            x"48656c6c6f2c204170746f73203421",
            x"48656c6c6f2c204170746f73203521",
        ];

        // Public key of signer i
        let pks = vector[
            PublicKeyWithPoP { bytes: x"b93d6aabb2b83e52f4b8bda43c24ea920bbced87a03ffc80f8f70c814a8b3f5d69fbb4e579ca76ee008d61365747dbc6" },
            PublicKeyWithPoP { bytes: x"b45648ceae3a983bcb816a96db599b5aef3b688c5753fa20ce36ac7a4f2c9ed792ab20af6604e85e42dab746398bb82c" },
            PublicKeyWithPoP { bytes: x"b3e4921277221e01ed71284be5e3045292b26c7f465a6fcdba53ee47edd39ec5160da3b229a73c75671024dcb36de091" },
            PublicKeyWithPoP { bytes: x"8463b8671c9775a7dbd98bf76d3deba90b5a90535fc87dc8c13506bb5c7bbd99be4d257e60c548140e1e30b107ff5822" },
            PublicKeyWithPoP { bytes: x"a79e3d0e9d04587a3b27d05efe5717da05fd93485dc47978c866dc70a01695c2efd247d1dd843a011a4b6b24079d7384" },
        ];

        // aggsigs[i] = \sum_{j <= i}  sigs[j], where sigs[j] is a signature on msgs[j] under pks[j]
        let aggsigs = vector[
            AggrOrMultiSignature { bytes: x"a2bc8bdebe6215ba74b5b53c5ed2aa0c68221a4adf868989ccdcfb62bb0eecc6537def9ee686a7960169c5917d25e5220177ed1c5e95ecfd68c09694062e76efcb00759beac874e4f9a715fd144210883bf9bb272f156b0a1fa15d0e9460f01f" },
            AggrOrMultiSignature { bytes: x"a523aa3c3f1f1074d968ffecf017c7b93ae5243006bf0abd2e45c036ddbec99302984b650ebe5ba306cda4071d281ba50a99ef0e66c3957fab94163296f9d673fc58a36de4276f82bfb1d9180b591df93b5c2804d40dd68cf0f72cd92f86442e" },
            AggrOrMultiSignature { bytes: x"abed10f464de74769121fc09715e59a3ac96a5054a43a9d43cc890a2d4d332614c74c7fb4cceef6d25f85c65dee337330f062f89f23fec9ecf7ce3193fbba2c886630d753be6a4513a4634428904b767af2f230c5cadbcb53a451dd9c7d977f6" },
            AggrOrMultiSignature { bytes: x"8362871631ba822742a31209fa4abce6dc94b741ac4725995459da2951324b51efbbf6bc3ab4681e547ebfbadd80e0360dc078c04188198f0acea26c12645ace9107a4a23cf8db46abc7a402637f16a0477c72569fc9966fe804ef4dc0e5e758" },
            AggrOrMultiSignature { bytes: x"a44d967935fbe63a763ce2dd2b16981f967ecd31e20d3266eef5517530cdc233c8a18273b6d9fd7f61dd39178826e3f115df4e7b304f2de17373a95ea0c9a14293dcfd6f0ef416e06fa23f6a3c850d638e4d8f97ab4562ef55d49a96a50baa13" },
        ];

        let i = 0;
        let msg_subset = std::vector::empty<vector<u8>>();
        let pk_subset = std::vector::empty<PublicKeyWithPoP>();
        while (i < std::vector::length(&pks)) {
            let aggsig = *std::vector::borrow(&aggsigs, i);

            std::vector::push_back(&mut pk_subset, *std::vector::borrow(&pks, i));
            std::vector::push_back(&mut msg_subset, *std::vector::borrow(&msgs, i));

            assert!(verify_aggregate_signature(&aggsig, pk_subset, msg_subset), 1);

            i = i + 1;
        };
    }

    #[test]
    fun test_verify_aggregated_signature_randomized() {
        let signer_count = 1;
        let max_signer_count = 5;
        while (signer_count <= max_signer_count) {
            // Generate key pairs and messages.
            let signing_keys = vector[];
            let public_keys = vector[];
            let messages: vector<vector<u8>> = vector[];
            let i = 0;
            while (i < signer_count) {
                let (sk, pk) = generate_keys();
                std::vector::push_back(&mut signing_keys, sk);
                std::vector::push_back(&mut public_keys, pk);
                let msg: vector<u8> = vector[104, 101, 108, 108, 111, 32, 97, 112, 116, 111, 115, 32, 117, 115, 101, 114, 32, 48+(i as u8)]; //"hello aptos user {i}"
                std::vector::push_back(&mut messages, msg);
                i = i + 1;
            };

            // Maul messages and public keys.
            let mauled_public_keys = vector[maul_public_key_with_pop(std::vector::borrow(&public_keys, 0))];
            let mauled_messages = vector[maul_bytes(std::vector::borrow(&messages, 0))];
            let i = 1;
            while (i < signer_count) {
                let pk = std::vector::borrow(&public_keys, i);
                let msg = std::vector::borrow(&messages, i);
                std::vector::push_back(&mut mauled_public_keys, *pk);
                std::vector::push_back(&mut mauled_messages, *msg);
                i = i + 1;
            };

            // Generate aggregated signature.
            let aggrsig = aggr_sign_arbitrary_bytes(&signing_keys, &messages);

            // Test signature verification.
            assert!(verify_aggregate_signature(&aggrsig, public_keys, messages), 1);
            assert!(!verify_aggregate_signature(&maul_aggr_or_multi_signature(&aggrsig), public_keys, messages), 1);
            assert!(!verify_aggregate_signature(&aggrsig, mauled_public_keys, messages), 1);
            assert!(!verify_aggregate_signature(&aggrsig, public_keys, mauled_messages), 1);

            // Also test signature aggregation.
            let signatures = vector[];
            let i = 0;
            while (i < signer_count) {
                let sk = std::vector::borrow(&signing_keys, i);
                let msg = std::vector::borrow(&messages, i);
                let sig = sign_arbitrary_bytes(sk, *msg);
                std::vector::push_back(&mut signatures, sig);
                i = i + 1;
            };
            let aggrsig_another = option::extract(&mut aggregate_signatures(signatures));
            assert!(aggr_or_multi_signature_to_bytes(&aggrsig_another) == aggr_or_multi_signature_to_bytes(&aggrsig), 1);

            signer_count = signer_count + 1;
        }
    }

    #[test]
    /// Tests verification of a random BLS signature created using sk = x""
    fun test_verify_normal_and_verify_sigshare() {
        // Test case generated by running `cargo test -- bls12381_sample_signature --nocapture --include-ignored` in
        // `crates/aptos-crypto`
        // =============================================================================================================
        // SK:        077c8a56f26259215a4a245373ab6ddf328ac6e00e5ea38d8700efa361bdc58d

        let message = b"Hello Aptos!";

        // First, test signatures that verify
        let ok = verify_normal_signature(
            &signature_from_bytes(x"b01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7"),
            &option::extract(&mut public_key_from_bytes(x"94209a296b739577cb076d3bfb1ca8ee936f29b69b7dae436118c4dd1cc26fd43dcd16249476a006b8b949bf022a7858")),
            message,
        );
        assert!(ok == true, 1);

        let pk = option::extract(&mut public_key_from_bytes(x"94209a296b739577cb076d3bfb1ca8ee936f29b69b7dae436118c4dd1cc26fd43dcd16249476a006b8b949bf022a7858"));
        let pk_with_pop = PublicKeyWithPoP { bytes: pk.bytes };

        let ok = verify_signature_share(
            &signature_from_bytes(x"b01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7"),
            &pk_with_pop,
            message,
        );
        assert!(ok == true, 1);

        // Second, test signatures that do NOT verify
        let sigs = vector[
            Signature { bytes: x"a01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7" },
            Signature { bytes: x"b01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7" },
            Signature { bytes: x"b01ce4632e94d8c611736e96aa2ad8e0528a02f927a81a92db8047b002a8c71dc2d6bfb94729d0973790c10b6ece446817e4b7543afd7ca9a17c75de301ae835d66231c26a003f11ae26802b98d90869a9e73788c38739f7ac9d52659e1f7cf7" },
        ];
        let pks = vector[
            x"94209a296b739577cb076d3bfb1ca8ee936f29b69b7dae436118c4dd1cc26fd43dcd16249476a006b8b949bf022a7858",
            x"ae4851bb9e7782027437ed0e2c026dd63b77a972ddf4bd9f72bcc218e327986568317e3aa9f679c697a2cb7cebf992f3",
            x"82ed7bb5528303a2e306775040a7309e0bd597b70d9949d8c6198a01a7be0b00079320ebfeaf7bbd5bfe86809940d252",
        ];
        let messages = vector[
            b"Hello Aptos!",
            b"Hello Aptos!",
            b"Bello Aptos!",
        ];

        let i = 0;
        while (i < std::vector::length(&pks)) {
            let sig = std::vector::borrow(&sigs, i);
            let pk = *std::vector::borrow(&pks, i);
            let msg = *std::vector::borrow(&messages, i);

            let pk = option::extract(&mut public_key_from_bytes(pk));

            let notok = verify_normal_signature(
                sig,
                &pk,
                msg,
            );
            assert!(notok == false, 1);

            let notok = verify_signature_share(
                sig,
                &PublicKeyWithPoP { bytes: pk.bytes },
                msg,
            );
            assert!(notok == false, 1);

            i = i + 1;
        }
    }

    #[test]
    fun test_verify_normal_signature_or_signature_share_randomized() {
        let (sk, pkpop) = generate_keys();
        let pk = public_key_with_pop_to_normal(&pkpop);

        let msg = b"hello world";
        let sig = sign_arbitrary_bytes(&sk, msg);
        assert!(verify_normal_signature(&sig, &pk, msg), 1);
        assert!(!verify_normal_signature(&maul_signature(&sig), &pk, msg), 1);
        assert!(!verify_normal_signature(&sig, &maul_public_key(&pk), msg), 1);
        assert!(!verify_normal_signature(&sig, &pk, maul_bytes(&msg)), 1);

        assert!(verify_signature_share(&sig, &pkpop, msg), 1);
        assert!(!verify_signature_share(&maul_signature(&sig), &pkpop, msg), 1);
        assert!(!verify_signature_share(&sig, &maul_public_key_with_pop(&pkpop), msg), 1);
        assert!(!verify_signature_share(&sig, &pkpop, maul_bytes(&msg)), 1);
    }

    #[test]
    /// Tests verification of random BLS proofs-of-possession (PoPs)
    fun test_verify_pop() {
        // Test case generated by running `cargo test -- sample_pop --nocapture --include-ignored` in `crates/aptos-crypto`
        // =============================================================================================================

        let pks = vector[
            x"808864c91ae7a9998b3f5ee71f447840864e56d79838e4785ff5126c51480198df3d972e1e0348c6da80d396983e42d7",
            x"8843843c76d167c02842a214c21277bad0bfd83da467cb5cf2d3ee67b2dcc7221b9fafa6d430400164012580e0c34d27",
            x"a23b524d4308d46e43ee8cbbf57f3e1c20c47061ad9c3f915212334ea6532451dd5c01d3d3ada6bea10fe180b2c3b450",
            x"a2aaa3eae1df3fc36365491afa1da5181acbb03801afd1430f04bb3b3eb18036f8b756b3508e4caee04beff50d455d1c",
            x"84985b7e983dbdaddfca1f0b7dad9660bb39fff660e329acec15f69ac48c75dfa5d2df9f0dc320e4e7b7658166e0ac1c",
        ];

        let pops = vector[
            proof_of_possession_from_bytes(x"ab42afff92510034bf1232a37a0d31bc8abfc17e7ead9170d2d100f6cf6c75ccdcfedbd31699a112b4464a06fd636f3f190595863677d660b4c5d922268ace421f9e86e3a054946ee34ce29e1f88c1a10f27587cf5ec528d65ba7c0dc4863364"),
            proof_of_possession_from_bytes(x"a6da5f2bc17df70ce664cff3e3a3e09d17162e47e652032b9fedc0c772fd5a533583242cba12095602e422e579c5284b1735009332dbdd23430bbcf61cc506ae37e41ff9a1fc78f0bc0d99b6bc7bf74c8f567dfb59079a035842bdc5fa3a0464"),
            proof_of_possession_from_bytes(x"b8eef236595e2eab34d3c1abdab65971f5cfa1988c731ef62bd63c9a9ad3dfc9259f4f183bfffbc8375a38ba62e1c41a11173209705996ce889859bcbb3ddd7faa3c4ea3d8778f30a9ff814fdcfea1fb163d745c54dfb4dcc5a8cee092ee0070"),
            proof_of_possession_from_bytes(x"a03a12fab68ad59d85c15dd1528560eff2c89250070ad0654ba260fda4334da179811d2ecdaca57693f80e9ce977d62011e3b1ee7bb4f7e0eb9b349468dd758f10fc35d54e0d0b8536ca713a77a301944392a5c192b6adf2a79ae2b38912dc98"),
            proof_of_possession_from_bytes(x"8899b294f3c066e6dfb59bc0843265a1ccd6afc8f0f38a074d45ded8799c39d25ee0376cd6d6153b0d4d2ff8655e578b140254f1287b9e9df4e2aecc5b049d8556a4ab07f574df68e46348fd78e5298b7913377cf5bb3cf4796bfc755902bfdd"),
        ];

        assert!(std::vector::length(&pks) == std::vector::length(&pops), 1);

        let i = 0;
        while (i < std::vector::length(&pks)) {
            let opt_pk = public_key_from_bytes_with_pop(*std::vector::borrow(&pks, i), std::vector::borrow(&pops, i));
            assert!(option::is_some(&opt_pk), 1);

            i = i + 1;
        };

        // assert first PK's PoP does not verify against modifed PK' = 0xa0 | PK[1:]
        let opt_pk = public_key_from_bytes_with_pop(
            x"a08864c91ae7a9998b3f5ee71f447840864e56d79838e4785ff5126c51480198df3d972e1e0348c6da80d396983e42d7",
            &proof_of_possession_from_bytes(x"ab42afff92510034bf1232a37a0d31bc8abfc17e7ead9170d2d100f6cf6c75ccdcfedbd31699a112b4464a06fd636f3f190595863677d660b4c5d922268ace421f9e86e3a054946ee34ce29e1f88c1a10f27587cf5ec528d65ba7c0dc4863364"));
        assert!(option::is_none(&opt_pk), 1);

        // assert first PK's PoP does not verify if modifed as pop' = 0xb0 | pop[1:]
        let opt_pk = public_key_from_bytes_with_pop(
            x"808864c91ae7a9998b3f5ee71f447840864e56d79838e4785ff5126c51480198df3d972e1e0348c6da80d396983e42d7",
            &proof_of_possession_from_bytes(x"bb42afff92510034bf1232a37a0d31bc8abfc17e7ead9170d2d100f6cf6c75ccdcfedbd31699a112b4464a06fd636f3f190595863677d660b4c5d922268ace421f9e86e3a054946ee34ce29e1f88c1a10f27587cf5ec528d65ba7c0dc4863364"));
        assert!(option::is_none(&opt_pk), 1);
    }

    #[test]
    fun test_verify_pop_randomized() {
        let (sk, pk) = generate_keys();
        let pk_bytes = public_key_with_pop_to_bytes(&pk);
        let pop = generate_proof_of_possession(&sk);
        assert!(option::is_some(&public_key_from_bytes_with_pop(pk_bytes, &pop)), 1);
        assert!(option::is_none(&public_key_from_bytes_with_pop(pk_bytes, &maul_proof_of_possession(&pop))), 1);
        assert!(option::is_none(&public_key_from_bytes_with_pop(maul_bytes(&pk_bytes), &pop)), 1);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.spec.move
================================================
spec aptos_std::bls12381 {

    spec public_key_from_bytes {
        aborts_if false;
        ensures spec_validate_pubkey_internal(bytes) ==> (std::option::spec_is_some(result) && std::option::spec_borrow(result).bytes == bytes);
        ensures !spec_validate_pubkey_internal(bytes) ==> std::option::spec_is_none(result);
    }

    spec public_key_from_bytes_with_pop {
        pragma opaque;
        aborts_if false;
        ensures spec_verify_proof_of_possession_internal(pk_bytes, pop.bytes) ==> (std::option::spec_is_some(result) && std::option::spec_borrow(result).bytes == pk_bytes);
        ensures !spec_verify_proof_of_possession_internal(pk_bytes, pop.bytes) ==> std::option::spec_is_none(result);
        ensures [abstract] result == spec_public_key_from_bytes_with_pop(pk_bytes, pop);
    }

    spec aggregate_pubkeys {
        let bytes = spec_aggregate_pubkeys_internal_1(public_keys);
        let success = spec_aggregate_pubkeys_internal_2(public_keys);
        aborts_if !success;
        ensures result.bytes == bytes;
    }

    spec aggregate_pubkeys_internal {
        pragma opaque;
        aborts_if [abstract] false; //TODO: check the aborts_if condition in the native implementation
        ensures result_1 == spec_aggregate_pubkeys_internal_1(public_keys);
        ensures result_2 == spec_aggregate_pubkeys_internal_2(public_keys);
    }

    spec aggregate_signatures {
        aborts_if false;
        let bytes = spec_aggregate_signatures_internal_1(signatures);
        let success = spec_aggregate_signatures_internal_2(signatures);
        ensures success ==> (std::option::spec_is_some(result) && std::option::spec_borrow(result).bytes == bytes);
        ensures !success ==> std::option::spec_is_none(result);
    }

    spec aggregate_signatures_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result_1 == spec_aggregate_signatures_internal_1(signatures);
        ensures result_2 == spec_aggregate_signatures_internal_2(signatures);
    }

    spec aggr_or_multi_signature_from_bytes {
        aborts_if len(bytes) != SIGNATURE_SIZE;
        ensures result.bytes == bytes;
    }

    spec validate_pubkey_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_validate_pubkey_internal(public_key);
    }

    spec aggr_or_multi_signature_subgroup_check {
        aborts_if false;
        ensures result == spec_signature_subgroup_check_internal(signature.bytes);
    }

    spec signature_subgroup_check_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_signature_subgroup_check_internal(signature);
    }

    spec verify_aggregate_signature {
        aborts_if false;
        ensures result == spec_verify_aggregate_signature_internal(aggr_sig.bytes, public_keys, messages);
    }

    spec verify_aggregate_signature_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_verify_aggregate_signature_internal(aggsig, public_keys, messages);
    }

    spec verify_multisignature {
        aborts_if false;
        ensures result == spec_verify_multisignature_internal(multisig.bytes, aggr_public_key.bytes, message);
    }

    spec verify_multisignature_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_verify_multisignature_internal(multisignature, agg_public_key, message);
    }

    spec verify_normal_signature {
        aborts_if false;
        ensures result == spec_verify_normal_signature_internal(signature.bytes, public_key.bytes, message);
    }

    spec verify_normal_signature_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_verify_normal_signature_internal(signature, public_key, message);
    }

    spec verify_proof_of_possession_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_verify_proof_of_possession_internal(public_key, proof_of_possesion);
    }

    spec verify_signature_share {
        aborts_if false;
        ensures result == spec_verify_signature_share_internal(signature_share.bytes, public_key.bytes, message);
    }

    spec verify_signature_share_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_verify_signature_share_internal(signature_share, public_key, message);
    }

    /// # Helper functions

    spec fun spec_aggregate_pubkeys_internal_1(public_keys: vector<PublicKeyWithPoP>): vector<u8>;

    spec fun spec_public_key_from_bytes_with_pop(pk_bytes: vector<u8>, pop: ProofOfPossession): Option<PublicKeyWithPoP>;

    spec fun spec_aggregate_pubkeys_internal_2(public_keys: vector<PublicKeyWithPoP>): bool;

    spec fun spec_aggregate_signatures_internal_1(signatures: vector<Signature>): vector<u8>;

    spec fun spec_aggregate_signatures_internal_2(signatures: vector<Signature>): bool;

    spec fun spec_validate_pubkey_internal(public_key: vector<u8>): bool;

    spec fun spec_signature_subgroup_check_internal(signature: vector<u8>): bool;

    spec fun spec_verify_aggregate_signature_internal(
        aggsig: vector<u8>,
        public_keys: vector<PublicKeyWithPoP>,
        messages: vector<vector<u8>>,
    ): bool;

    spec fun spec_verify_multisignature_internal(
        multisignature: vector<u8>,
        agg_public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    spec fun spec_verify_normal_signature_internal(
        signature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    spec fun spec_verify_proof_of_possession_internal(
        public_key: vector<u8>,
        proof_of_possesion: vector<u8>
    ): bool;

    spec fun spec_verify_signature_share_internal(
        signature_share: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;


}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move
================================================
/// This module provides generic structs/functions for operations of algebraic structures (e.g. fields and groups),
/// which can be used to build generic cryptographic schemes atop.
/// E.g., a Groth16 ZK proof verifier can be built to work over any pairing supported in this module.
///
/// In general, every structure implements basic operations like (de)serialization, equality check, random sampling.
///
/// A group may also implement the following operations. (Additive group notation is assumed.)
/// - `order()` for getting the group order.
/// - `zero()` for getting the group identity.
/// - `one()` for getting the group generator (if exists).
/// - `neg()` for group element inversion.
/// - `add()` for group operation (i.e., a group addition).
/// - `sub()` for group element subtraction.
/// - `double()` for efficient doubling.
/// - `scalar_mul()` for group scalar multiplication.
/// - `multi_scalar_mul()` for efficient group multi-scalar multiplication.
/// - `hash_to()` for hash-to-group.
///
/// A field may also implement the following operations.
/// - `zero()` for getting the field additive identity.
/// - `one()` for getting the field multiplicative identity.
/// - `add()` for field addition.
/// - `sub()` for field subtraction.
/// - `mul()` for field multiplication.
/// - `div()` for field division.
/// - `neg()` for field negation.
/// - `inv()` for field inversion.
/// - `sqr()` for efficient field element squaring.
/// - `from_u64()` for quick conversion from u64 to field element.
///
/// For 3 groups that admit a bilinear map, `pairing()` and `multi_pairing()` may be implemented.
///
/// For a subset/superset relationship between 2 structures, `upcast()` and `downcast()` may be implemented.
/// E.g., in BLS12-381 pairing, since `Gt` is a subset of `Fq12`,
/// `upcast<Gt, Fq12>()` and `downcast<Fq12, Gt>()` will be supported.
///
/// See `*_algebra.move` for currently implemented algebraic structures.
module aptos_std::crypto_algebra {
    use std::option::{Option, some, none};
    use std::features;

    const E_NOT_IMPLEMENTED: u64 = 1;
    const E_NON_EQUAL_LENGTHS: u64 = 2;
    const E_TOO_MUCH_MEMORY_USED: u64 = 3;

    /// This struct represents an element of a structure `S`.
    struct Element<phantom S> has copy, drop {
        handle: u64
    }

    //
    // Public functions begin.
    //

    /// Check if `x == y` for elements `x` and `y` of a structure `S`.
    public fun eq<S>(x: &Element<S>, y: &Element<S>): bool {
        abort_unless_cryptography_algebra_natives_enabled();
        eq_internal<S>(x.handle, y.handle)
    }

    /// Convert a u64 to an element of a structure `S`.
    public fun from_u64<S>(value: u64): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: from_u64_internal<S>(value)
        }
    }

    /// Return the additive identity of field `S`, or the identity of group `S`.
    public fun zero<S>(): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: zero_internal<S>()
        }
    }

    /// Return the multiplicative identity of field `S`, or a fixed generator of group `S`.
    public fun one<S>(): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: one_internal<S>()
        }
    }

    /// Compute `-x` for an element `x` of a structure `S`.
    public fun neg<S>(x: &Element<S>): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: neg_internal<S>(x.handle)
        }
    }

    /// Compute `x + y` for elements `x` and `y` of structure `S`.
    public fun add<S>(x: &Element<S>, y: &Element<S>): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: add_internal<S>(x.handle, y.handle)
        }
    }

    /// Compute `x - y` for elements `x` and `y` of a structure `S`.
    public fun sub<S>(x: &Element<S>, y: &Element<S>): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: sub_internal<S>(x.handle, y.handle)
        }
    }

    /// Compute `x * y` for elements `x` and `y` of a structure `S`.
    public fun mul<S>(x: &Element<S>, y: &Element<S>): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: mul_internal<S>(x.handle, y.handle)
        }
    }

    /// Try computing `x / y` for elements `x` and `y` of a structure `S`.
    /// Return none if `y` does not have a multiplicative inverse in the structure `S`
    /// (e.g., when `S` is a field, and `y` is zero).
    public fun div<S>(x: &Element<S>, y: &Element<S>): Option<Element<S>> {
        abort_unless_cryptography_algebra_natives_enabled();
        let (succ, handle) = div_internal<S>(x.handle, y.handle);
        if (succ) {
            some(Element<S> { handle })
        } else {
            none()
        }
    }

    /// Compute `x^2` for an element `x` of a structure `S`. Faster and cheaper than `mul(x, x)`.
    public fun sqr<S>(x: &Element<S>): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: sqr_internal<S>(x.handle)
        }
    }

    /// Try computing `x^(-1)` for an element `x` of a structure `S`.
    /// Return none if `x` does not have a multiplicative inverse in the structure `S`
    /// (e.g., when `S` is a field, and `x` is zero).
    public fun inv<S>(x: &Element<S>): Option<Element<S>> {
        abort_unless_cryptography_algebra_natives_enabled();
        let (succeeded, handle) = inv_internal<S>(x.handle);
        if (succeeded) {
            let scalar = Element<S> { handle };
            some(scalar)
        } else {
            none()
        }
    }

    /// Compute `2*P` for an element `P` of a structure `S`. Faster and cheaper than `add(P, P)`.
    public fun double<S>(element_p: &Element<S>): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: double_internal<S>(element_p.handle)
        }
    }

    /// Compute `k[0]*P[0]+...+k[n-1]*P[n-1]`, where
    /// `P[]` are `n` elements of group `G` represented by parameter `elements`, and
    /// `k[]` are `n` elements of the scalarfield `S` of group `G` represented by parameter `scalars`.
    ///
    /// Abort with code `std::error::invalid_argument(E_NON_EQUAL_LENGTHS)` if the sizes of `elements` and `scalars` do not match.
    public fun multi_scalar_mul<G, S>(elements: &vector<Element<G>>, scalars: &vector<Element<S>>): Element<G> {
        let element_handles = handles_from_elements(elements);
        let scalar_handles = handles_from_elements(scalars);
        Element<G> {
            handle: multi_scalar_mul_internal<G, S>(element_handles, scalar_handles)
        }
    }

    /// Compute `k*P`, where `P` is an element of a group `G` and `k` is an element of the scalar field `S` associated to the group `G`.
    public fun scalar_mul<G, S>(element_p: &Element<G>, scalar_k: &Element<S>): Element<G> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<G> {
            handle: scalar_mul_internal<G, S>(element_p.handle, scalar_k.handle)
        }
    }

    /// Efficiently compute `e(P[0],Q[0])+...+e(P[n-1],Q[n-1])`,
    /// where `e: (G1,G2) -> (Gt)` is the pairing function from groups `(G1,G2)` to group `Gt`,
    /// `P[]` are `n` elements of group `G1` represented by parameter `g1_elements`, and
    /// `Q[]` are `n` elements of group `G2` represented by parameter `g2_elements`.
    ///
    /// Abort with code `std::error::invalid_argument(E_NON_EQUAL_LENGTHS)` if the sizes of `g1_elements` and `g2_elements` do not match.
    ///
    /// NOTE: we are viewing the target group `Gt` of the pairing as an additive group,
    /// rather than a multiplicative one (which is typically the case).
    public fun multi_pairing<G1,G2,Gt>(g1_elements: &vector<Element<G1>>, g2_elements: &vector<Element<G2>>): Element<Gt> {
        abort_unless_cryptography_algebra_natives_enabled();
        let g1_handles = handles_from_elements(g1_elements);
        let g2_handles = handles_from_elements(g2_elements);
        Element<Gt> {
            handle: multi_pairing_internal<G1,G2,Gt>(g1_handles, g2_handles)
        }
    }

    /// Compute the pairing function (a.k.a., bilinear map) on a `G1` element and a `G2` element.
    /// Return an element in the target group `Gt`.
    public fun pairing<G1,G2,Gt>(element_1: &Element<G1>, element_2: &Element<G2>): Element<Gt> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<Gt> {
            handle: pairing_internal<G1,G2,Gt>(element_1.handle, element_2.handle)
        }
    }

    /// Try deserializing a byte array to an element of an algebraic structure `S` using a given serialization format `F`.
    /// Return none if the deserialization failed.
    public fun deserialize<S, F>(bytes: &vector<u8>): Option<Element<S>> {
        abort_unless_cryptography_algebra_natives_enabled();
        let (succeeded, handle) = deserialize_internal<S, F>(bytes);
        if (succeeded) {
            some(Element<S> { handle })
        } else {
            none()
        }
    }

    /// Serialize an element of an algebraic structure `S` to a byte array using a given serialization format `F`.
    public fun serialize<S, F>(element: &Element<S>): vector<u8> {
        abort_unless_cryptography_algebra_natives_enabled();
        serialize_internal<S, F>(element.handle)
    }

    /// Get the order of structure `S`, a big integer little-endian encoded as a byte array.
    public fun order<S>(): vector<u8> {
        abort_unless_cryptography_algebra_natives_enabled();
        order_internal<S>()
    }

    /// Cast an element of a structure `S` to a parent structure `L`.
    public fun upcast<S,L>(element: &Element<S>): Element<L> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<L> {
            handle: upcast_internal<S,L>(element.handle)
        }
    }

    /// Try casting an element `x` of a structure `L` to a sub-structure `S`.
    /// Return none if `x` is not a member of `S`.
    ///
    /// NOTE: Membership check in `S` is performed inside, which can be expensive, depending on the structures `L` and `S`.
    public fun downcast<L,S>(element_x: &Element<L>): Option<Element<S>> {
        abort_unless_cryptography_algebra_natives_enabled();
        let (succ, new_handle) = downcast_internal<L,S>(element_x.handle);
        if (succ) {
            some(Element<S> { handle: new_handle })
        } else {
            none()
        }
    }

    /// Hash an arbitrary-length byte array `msg` into structure `S` with a domain separation tag `dst`
    /// using the given hash-to-structure suite `H`.
    ///
    /// NOTE: some hashing methods do not accept a `dst` and will abort if a non-empty one is provided.
    public fun hash_to<S, H>(dst: &vector<u8>, msg: &vector<u8>): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element {
            handle: hash_to_internal<S, H>(dst, msg)
        }
    }

    #[test_only]
    /// Generate a random element of an algebraic structure `S`.
    public fun rand_insecure<S>(): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: rand_insecure_internal<S>()
        }
    }

    //
    // (Public functions end here.)
    // Private functions begin.
    //

    fun abort_unless_cryptography_algebra_natives_enabled() {
        if (features::cryptography_algebra_enabled()) return;
        abort(std::error::not_implemented(0))
    }

    #[test_only]
    public fun enable_cryptography_algebra_natives(fx: &signer) {
        std::features::change_feature_flags_for_testing(fx, vector[std::features::get_cryptography_algebra_natives_feature()], vector[]);
    }

    fun handles_from_elements<S>(elements: &vector<Element<S>>): vector<u64> {
        let num_elements = std::vector::length(elements);
        let element_handles = std::vector::empty();
        let i = 0;
        while ({
            spec {
                invariant len(element_handles) == i;
                invariant forall k in 0..i: element_handles[k] == elements[k].handle;
            };
            i < num_elements
        }) {
            std::vector::push_back(&mut element_handles, std::vector::borrow(elements, i).handle);
            i = i + 1;
        };
        element_handles
    }

    //
    // (Private functions end here.)
    // Native functions begin.
    //

    native fun add_internal<S>(handle_1: u64, handle_2: u64): u64;
    native fun deserialize_internal<S, F>(bytes: &vector<u8>): (bool, u64);
    native fun div_internal<F>(handle_1: u64, handle_2: u64): (bool, u64);
    native fun double_internal<G>(element_handle: u64): u64;
    native fun downcast_internal<L,S>(handle: u64): (bool, u64);
    native fun from_u64_internal<S>(value: u64): u64;
    native fun eq_internal<S>(handle_1: u64, handle_2: u64): bool;
    native fun hash_to_internal<S, H>(dst: &vector<u8>, bytes: &vector<u8>): u64;
    native fun inv_internal<F>(handle: u64): (bool, u64);
    #[test_only]
    native fun rand_insecure_internal<S>(): u64;
    native fun mul_internal<F>(handle_1: u64, handle_2: u64): u64;
    native fun multi_pairing_internal<G1,G2,Gt>(g1_handles: vector<u64>, g2_handles: vector<u64>): u64;
    native fun multi_scalar_mul_internal<G, S>(element_handles: vector<u64>, scalar_handles: vector<u64>): u64;
    native fun neg_internal<F>(handle: u64): u64;
    native fun one_internal<S>(): u64;
    native fun order_internal<G>(): vector<u8>;
    native fun pairing_internal<G1,G2,Gt>(g1_handle: u64, g2_handle: u64): u64;
    native fun scalar_mul_internal<G, S>(element_handle: u64, scalar_handle: u64): u64;
    native fun serialize_internal<S, F>(handle: u64): vector<u8>;
    native fun sqr_internal<G>(handle: u64): u64;
    native fun sub_internal<G>(handle_1: u64, handle_2: u64): u64;
    native fun upcast_internal<S,L>(handle: u64): u64;
    native fun zero_internal<S>(): u64;

    //
    // (Native functions end here.)
    // Tests begin.
    //

    #[test_only]
    struct MysteriousGroup {}

    #[test(fx = @std)]
    #[expected_failure(abort_code = 0x0c0001, location = Self)]
    fun test_generic_operation_should_abort_with_unsupported_structures(fx: signer) {
        enable_cryptography_algebra_natives(&fx);
        let _ = order<MysteriousGroup>();
    }
    // Tests end.
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.spec.move
================================================
spec aptos_std::crypto_algebra {

    spec handles_from_elements<S>(elements: &vector<Element<S>>): vector<u64> {
        aborts_if false;
        ensures forall i in 0..len(elements): result[i] == elements[i].handle;
    }

    spec add_internal<S>(handle_1: u64, handle_2: u64): u64 {
        pragma opaque;
    }

    spec deserialize_internal<S, F>(bytes: &vector<u8>): (bool, u64) {
        pragma opaque;
    }

    spec div_internal<F>(handle_1: u64, handle_2: u64): (bool, u64) {
        pragma opaque;
    }

    spec double_internal<G>(element_handle: u64): u64 {
        pragma opaque;
    }

    spec downcast_internal<L,S>(handle: u64): (bool, u64) {
        pragma opaque;
    }

    spec from_u64_internal<S>(value: u64): u64 {
        pragma opaque;
    }

    spec eq_internal<S>(handle_1: u64, handle_2: u64): bool {
        pragma opaque;
    }

    spec hash_to_internal<S, H>(dst: &vector<u8>, bytes: &vector<u8>): u64 {
        pragma opaque;
    }

    spec inv_internal<F>(handle: u64): (bool, u64) {
        pragma opaque;
    }

    spec mul_internal<F>(handle_1: u64, handle_2: u64): u64 {
        pragma opaque;
    }

    spec multi_pairing_internal<G1,G2,Gt>(g1_handles: vector<u64>, g2_handles: vector<u64>): u64 {
        pragma opaque;
    }

    spec multi_scalar_mul_internal<G, S>(element_handles: vector<u64>, scalar_handles: vector<u64>): u64 {
        pragma opaque;
    }

    spec neg_internal<F>(handle: u64): u64 {
        pragma opaque;
    }

    spec one_internal<S>(): u64 {
        pragma opaque;
    }

    spec order_internal<G>(): vector<u8> {
        pragma opaque;
    }

    spec pairing_internal<G1,G2,Gt>(g1_handle: u64, g2_handle: u64): u64 {
        pragma opaque;
    }

    spec scalar_mul_internal<G, S>(element_handle: u64, scalar_handle: u64): u64 {
        pragma opaque;
    }

    spec serialize_internal<S, F>(handle: u64): vector<u8> {
        pragma opaque;
    }

    spec sqr_internal<G>(handle: u64): u64 {
        pragma opaque;
    }

    spec sub_internal<G>(handle_1: u64, handle_2: u64): u64 {
        pragma opaque;
    }

    spec upcast_internal<S,L>(handle: u64): u64 {
        pragma opaque;
    }

    spec zero_internal<S>(): u64 {
        pragma opaque;
    }

}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move
================================================
/// Contains functions for:
///
///  1. [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) digital signatures: i.e., EdDSA signatures over Edwards25519 curves with co-factor 8
///
module aptos_std::ed25519 {
    use std::bcs;
    use aptos_std::type_info::{Self, TypeInfo};
    use std::option::{Self, Option};

    //
    // Error codes
    //

    /// Wrong number of bytes were given as input when deserializing an Ed25519 public key.
    const E_WRONG_PUBKEY_SIZE: u64 = 1;

    /// Wrong number of bytes were given as input when deserializing an Ed25519 signature.
    const E_WRONG_SIGNATURE_SIZE: u64 = 2;

    //
    // Constants
    //

    /// The identifier of the Ed25519 signature scheme, which is used when deriving Aptos authentication keys by hashing
    /// it together with an Ed25519 public key.
    const SIGNATURE_SCHEME_ID: u8 = 0;

    /// The size of a serialized public key, in bytes.
    const PUBLIC_KEY_NUM_BYTES: u64 = 32;

    /// The size of a serialized signature, in bytes.
    const SIGNATURE_NUM_BYTES: u64 = 64;

    //
    // Structs
    //

    #[test_only]
    /// This struct holds an Ed25519 secret key that can be used to generate Ed25519 signatures during testing.
    struct SecretKey has drop {
        bytes: vector<u8>
    }

    /// A BCS-serializable message, which one can verify signatures on via `signature_verify_strict_t`
    struct SignedMessage<MessageType> has drop {
        type_info: TypeInfo,
        inner: MessageType,
    }

    /// An *unvalidated* Ed25519 public key: not necessarily an elliptic curve point, just a sequence of 32 bytes
    struct UnvalidatedPublicKey has copy, drop, store {
        bytes: vector<u8>
    }

    /// A *validated* Ed25519 public key: not necessarily a prime-order point, could be mixed-order, but will never be
    /// a small-order point.
    ///
    /// For now, this struct is not used in any verification functions, but it might be in the future.
    struct ValidatedPublicKey has copy, drop, store {
        bytes: vector<u8>
    }

    /// A purported Ed25519 signature that can be verified via `signature_verify_strict` or `signature_verify_strict_t`.
    struct Signature has copy, drop, store {
        bytes: vector<u8>
    }

    //
    // Functions
    //

    /// Parses the input 32 bytes as an *unvalidated* Ed25519 public key.
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        assert!(std::vector::length(&bytes) == PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        UnvalidatedPublicKey { bytes }
    }

    /// Parses the input 32 bytes as a *validated* Ed25519 public key.
    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {
        if (public_key_validate_internal(bytes)) {
            option::some(ValidatedPublicKey {
                bytes
            })
        } else {
            option::none<ValidatedPublicKey>()
        }
    }

    /// Parses the input 64 bytes as a purported Ed25519 signature.
    public fun new_signature_from_bytes(bytes: vector<u8>): Signature {
        assert!(std::vector::length(&bytes) == SIGNATURE_NUM_BYTES, std::error::invalid_argument(E_WRONG_SIGNATURE_SIZE));
        Signature { bytes }
    }

    /// Converts a ValidatedPublicKey to an UnvalidatedPublicKey, which can be used in the strict verification APIs.
    public fun public_key_to_unvalidated(pk: &ValidatedPublicKey): UnvalidatedPublicKey {
        UnvalidatedPublicKey {
            bytes: pk.bytes
        }
    }

    /// Moves a ValidatedPublicKey into an UnvalidatedPublicKey, which can be used in the strict verification APIs.
    public fun public_key_into_unvalidated(pk: ValidatedPublicKey): UnvalidatedPublicKey {
        UnvalidatedPublicKey {
            bytes: pk.bytes
        }
    }

    /// Serializes an UnvalidatedPublicKey struct to 32-bytes.
    public fun unvalidated_public_key_to_bytes(pk: &UnvalidatedPublicKey): vector<u8> {
        pk.bytes
    }

    /// Serializes an ValidatedPublicKey struct to 32-bytes.
    public fun validated_public_key_to_bytes(pk: &ValidatedPublicKey): vector<u8> {
        pk.bytes
    }

    /// Serializes a Signature struct to 64-bytes.
    public fun signature_to_bytes(sig: &Signature): vector<u8> {
        sig.bytes
    }

    /// Takes in an *unvalidated* public key and attempts to validate it.
    /// Returns `Some(ValidatedPublicKey)` if successful and `None` otherwise.
    public fun public_key_validate(pk: &UnvalidatedPublicKey): Option<ValidatedPublicKey> {
        new_validated_public_key_from_bytes(pk.bytes)
    }

    /// Verifies a purported Ed25519 `signature` under an *unvalidated* `public_key` on the specified `message`.
    /// This call will validate the public key by checking it is NOT in the small subgroup.
    public fun signature_verify_strict(
        signature: &Signature,
        public_key: &UnvalidatedPublicKey,
        message: vector<u8>
    ): bool {
        signature_verify_strict_internal(signature.bytes, public_key.bytes, message)
    }

    /// This function is used to verify a signature on any BCS-serializable type T. For now, it is used to verify the
    /// proof of private key ownership when rotating authentication keys.
    public fun signature_verify_strict_t<T: drop>(signature: &Signature, public_key: &UnvalidatedPublicKey, data: T): bool {
        let encoded = SignedMessage {
            type_info: type_info::type_of<T>(),
            inner: data,
        };

        signature_verify_strict_internal(signature.bytes, public_key.bytes, bcs::to_bytes(&encoded))
    }

    /// Helper method to construct a SignedMessage struct.
    public fun new_signed_message<T: drop>(data: T): SignedMessage<T> {
        SignedMessage {
            type_info: type_info::type_of<T>(),
            inner: data,
        }
    }

    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.
    public fun unvalidated_public_key_to_authentication_key(pk: &UnvalidatedPublicKey): vector<u8> {
        public_key_bytes_to_authentication_key(pk.bytes)
    }

    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.
    public fun validated_public_key_to_authentication_key(pk: &ValidatedPublicKey): vector<u8> {
        public_key_bytes_to_authentication_key(pk.bytes)
    }

    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.
    fun public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8> {
        std::vector::push_back(&mut pk_bytes, SIGNATURE_SCHEME_ID);
        std::hash::sha3_256(pk_bytes)
    }

    #[test_only]
    /// Generates an Ed25519 key pair.
    public fun generate_keys(): (SecretKey, ValidatedPublicKey) {
        let (sk_bytes, pk_bytes) = generate_keys_internal();
        let sk = SecretKey {
            bytes: sk_bytes
        };
        let pk = ValidatedPublicKey {
            bytes: pk_bytes
        };
        (sk,pk)
    }

    #[test_only]
    /// Generates an Ed25519 signature for a given byte array using a given signing key.
    public fun sign_arbitrary_bytes(sk: &SecretKey, msg: vector<u8>): Signature {
        Signature {
            bytes: sign_internal(sk.bytes, msg)
        }
    }

    #[test_only]
    /// Generates an Ed25519 signature for given structured data using a given signing key.
    public fun sign_struct<T:drop>(sk: &SecretKey, data: T): Signature {
        let encoded = new_signed_message(data);
        Signature {
            bytes: sign_internal(sk.bytes, bcs::to_bytes(&encoded))
        }
    }

    //
    // Native functions
    //

    /// Return `true` if the bytes in `public_key` can be parsed as a valid Ed25519 public key: i.e., it passes
    /// points-on-curve and not-in-small-subgroup checks.
    /// Returns `false` otherwise.
    native fun public_key_validate_internal(bytes: vector<u8>): bool;

    /// Return true if the Ed25519 `signature` on `message` verifies against the Ed25519 `public_key`.
    /// Returns `false` if either:
    /// - `signature` or `public key` are of wrong sizes
    /// - `public_key` does not pass points-on-curve or not-in-small-subgroup checks,
    /// - `signature` does not pass points-on-curve or not-in-small-subgroup checks,
    /// - the signature on `message` does not verify.
    native fun signature_verify_strict_internal(
        signature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    #[test_only]
    /// Generates an Ed25519 key pair.
    native fun generate_keys_internal(): (vector<u8>, vector<u8>);

    #[test_only]
    /// Generates an Ed25519 signature for a given byte array using a given signing key.
    native fun sign_internal(sk: vector<u8>, msg: vector<u8>): vector<u8>;

    //
    // Tests
    //

    #[test_only]
    struct TestMessage has copy, drop {
        title: vector<u8>,
        content: vector<u8>,
    }

    #[test]
    fun test_gen_sign_verify_combo() {
        let (sk, vpk) = generate_keys();
        let pk = public_key_into_unvalidated(vpk);

        let msg1: vector<u8> = x"0123456789abcdef";
        let sig1 = sign_arbitrary_bytes(&sk, msg1);
        assert!(signature_verify_strict(&sig1, &pk, msg1), std::error::invalid_state(1));

        let msg2 = TestMessage {
            title: b"Some Title",
            content: b"That is it.",
        };
        let sig2 = sign_struct(&sk, copy msg2);
        assert!(signature_verify_strict_t(&sig2, &pk, copy msg2), std::error::invalid_state(2));
    }


}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.spec.move
================================================
spec aptos_std::ed25519 {

    // -----------------------
    // Function specifications
    // -----------------------

    spec new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        include NewUnvalidatedPublicKeyFromBytesAbortsIf;
        ensures result == UnvalidatedPublicKey { bytes };
    }
    spec schema NewUnvalidatedPublicKeyFromBytesAbortsIf {
        bytes: vector<u8>;
        aborts_if len(bytes) != PUBLIC_KEY_NUM_BYTES;
    }

    spec new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {
        aborts_if false;
        let cond = spec_public_key_validate_internal(bytes);
        ensures cond ==> result == option::spec_some(ValidatedPublicKey{bytes});
        ensures !cond ==> result == option::spec_none<ValidatedPublicKey>();
    }

    spec new_signature_from_bytes(bytes: vector<u8>): Signature {
        include NewSignatureFromBytesAbortsIf;
        ensures result == Signature { bytes };
    }
    spec schema NewSignatureFromBytesAbortsIf {
        bytes: vector<u8>;
        aborts_if len(bytes) != SIGNATURE_NUM_BYTES;
    }

    spec public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if false;
        ensures [abstract] result == spec_public_key_bytes_to_authentication_key(pk_bytes);
    }


    // ----------------
    // Native functions
    // ----------------

    spec public_key_validate_internal(bytes: vector<u8>): bool {
        pragma opaque;
        aborts_if false;
        ensures result == spec_public_key_validate_internal(bytes);
    }

    spec signature_verify_strict_internal(
        signature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>)
    : bool {
        pragma opaque;
        aborts_if false;
        ensures result == spec_signature_verify_strict_internal(signature, public_key, message);
    }

    /// # Helper functions

    spec fun spec_signature_verify_strict_internal(
        signature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    spec fun spec_public_key_validate_internal(bytes: vector<u8>): bool;

    spec fun spec_public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8>;

    spec fun spec_signature_verify_strict_t<T>(signature: Signature, public_key: UnvalidatedPublicKey, data: T): bool {
        let encoded = SignedMessage<T> {
            type_info: type_info::type_of<T>(),
            inner: data,
        };
        let message = bcs::serialize(encoded);
        spec_signature_verify_strict_internal(signature.bytes, public_key.bytes, message)
    }

}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/multi_ed25519.move
================================================
/// Exports MultiEd25519 multi-signatures in Move.
/// This module has the exact same interface as the Ed25519 module.

module aptos_std::multi_ed25519 {
    use std::bcs;
    use std::error;
    use std::features;
    use std::option::{Self, Option};
    use std::vector;
    use aptos_std::ed25519;

    //
    // Error codes
    //

    /// Wrong number of bytes were given as input when deserializing an Ed25519 public key.
    const E_WRONG_PUBKEY_SIZE: u64 = 1;

    /// Wrong number of bytes were given as input when deserializing an Ed25519 signature.
    const E_WRONG_SIGNATURE_SIZE: u64 = 2;

    /// The threshold must be in the range `[1, n]`, where n is the total number of signers.
    const E_INVALID_THRESHOLD_OR_NUMBER_OF_SIGNERS: u64 = 3;

    /// The native functions have not been rolled out yet.
    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 4;

    //
    // Constants
    //

    /// The identifier of the MultiEd25519 signature scheme, which is used when deriving Aptos authentication keys by hashing
    /// it together with an MultiEd25519 public key.
    const SIGNATURE_SCHEME_ID: u8 = 1;

    /// The size of an individual Ed25519 public key, in bytes.
    /// (A MultiEd25519 public key consists of several of these, plus the threshold.)
    const INDIVIDUAL_PUBLIC_KEY_NUM_BYTES: u64 = 32;

    /// The size of an individual Ed25519 signature, in bytes.
    /// (A MultiEd25519 signature consists of several of these, plus the signer bitmap.)
    const INDIVIDUAL_SIGNATURE_NUM_BYTES: u64 = 64;

    /// When serializing a MultiEd25519 public key, the threshold k will be encoded using this many bytes.
    const THRESHOLD_SIZE_BYTES: u64 = 1;

    /// When serializing a MultiEd25519 signature, the bitmap that indicates the signers will be encoded using this many
    /// bytes.
    const BITMAP_NUM_OF_BYTES: u64 = 4;

    /// Max number of ed25519 public keys allowed in multi-ed25519 keys
    const MAX_NUMBER_OF_PUBLIC_KEYS: u64 = 32;

    //
    // Structs
    //
    #[test_only]
    struct SecretKey has drop {
        bytes: vector<u8>,
    }

    /// An *unvalidated*, k out of n MultiEd25519 public key. The `bytes` field contains (1) several chunks of
    /// `ed25519::PUBLIC_KEY_NUM_BYTES` bytes, each encoding a Ed25519 PK, and (2) a single byte encoding the threshold k.
    /// *Unvalidated* means there is no guarantee that the underlying PKs are valid elliptic curve points of non-small
    /// order.
    struct UnvalidatedPublicKey has copy, drop, store {
        bytes: vector<u8>
    }

    /// A *validated* k out of n MultiEd25519 public key. *Validated* means that all the underlying PKs will be
    /// elliptic curve points that are NOT of small-order. It does not necessarily mean they will be prime-order points.
    /// This struct encodes the public key exactly as `UnvalidatedPublicKey`.
    ///
    /// For now, this struct is not used in any verification functions, but it might be in the future.
    struct ValidatedPublicKey has copy, drop, store {
        bytes: vector<u8>
    }

    /// A purported MultiEd25519 multi-signature that can be verified via `signature_verify_strict` or
    /// `signature_verify_strict_t`. The `bytes` field contains (1) several chunks of `ed25519::SIGNATURE_NUM_BYTES`
    /// bytes, each encoding a Ed25519 signature, and (2) a `BITMAP_NUM_OF_BYTES`-byte bitmap encoding the signer
    /// identities.
    struct Signature has copy, drop, store {
        bytes: vector<u8>
    }

    //
    // Functions
    //

    #[test_only]
    public fun generate_keys(threshold: u8, n: u8): (SecretKey, ValidatedPublicKey) {
        assert!(1 <= threshold && threshold <= n, error::invalid_argument(E_INVALID_THRESHOLD_OR_NUMBER_OF_SIGNERS));
        let (sk_bytes, pk_bytes) = generate_keys_internal(threshold, n);
        let sk = SecretKey {
            bytes: sk_bytes
        };
        let pk = ValidatedPublicKey {
            bytes: pk_bytes
        };
        (sk, pk)
    }

    #[test_only]
    public fun sign_arbitrary_bytes(sk: &SecretKey, msg: vector<u8>) : Signature {
        Signature {
            bytes: sign_internal(sk.bytes, msg)
        }
    }

    #[test_only]
    public fun sign_struct<T: drop>(sk: &SecretKey, data: T) : Signature {
        let encoded = ed25519::new_signed_message(data);
        Signature {
            bytes: sign_internal(sk.bytes, bcs::to_bytes(&encoded)),
        }
    }

    /// Parses the input 32 bytes as an *unvalidated* MultiEd25519 public key.
    ///
    /// NOTE: This function could have also checked that the # of sub-PKs is > 0, but it did not. However, since such
    /// invalid PKs are rejected during signature verification  (see `bugfix_unvalidated_pk_from_zero_subpks`) they
    /// will not cause problems.
    ///
    /// We could fix this API by adding a new one that checks the # of sub-PKs is > 0, but it is likely not a good idea
    /// to reproduce the PK validation logic in Move. We should not have done so in the first place. Instead, we will
    /// leave it as is and continue assuming `UnvalidatedPublicKey` objects could be invalid PKs that will safely be
    /// rejected during signature verification.
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        let len = vector::length(&bytes);
        let num_sub_pks = len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;

        assert!(num_sub_pks <= MAX_NUMBER_OF_PUBLIC_KEYS, error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        assert!(len % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES == THRESHOLD_SIZE_BYTES, error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        UnvalidatedPublicKey { bytes }
    }

    /// DEPRECATED: Use `new_validated_public_key_from_bytes_v2` instead. See `public_key_validate_internal` comments.
    ///
    /// (Incorrectly) parses the input bytes as a *validated* MultiEd25519 public key.
    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {
        // Note that `public_key_validate_internal` will check that `vector::length(&bytes) / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES <= MAX_NUMBER_OF_PUBLIC_KEYS`.
        if (vector::length(&bytes) % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES == THRESHOLD_SIZE_BYTES &&
            public_key_validate_internal(bytes)) {
            option::some(ValidatedPublicKey {
                bytes
            })
        } else {
            option::none<ValidatedPublicKey>()
        }
    }

    /// Parses the input bytes as a *validated* MultiEd25519 public key (see `public_key_validate_internal_v2`).
    public fun new_validated_public_key_from_bytes_v2(bytes: vector<u8>): Option<ValidatedPublicKey> {
        if (!features::multi_ed25519_pk_validate_v2_enabled()) {
            abort(error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        if (public_key_validate_v2_internal(bytes)) {
            option::some(ValidatedPublicKey {
                bytes
            })
        } else {
            option::none<ValidatedPublicKey>()
        }
    }

    /// Parses the input bytes as a purported MultiEd25519 multi-signature.
    public fun new_signature_from_bytes(bytes: vector<u8>): Signature {
        assert!(vector::length(&bytes) % INDIVIDUAL_SIGNATURE_NUM_BYTES == BITMAP_NUM_OF_BYTES, error::invalid_argument(E_WRONG_SIGNATURE_SIZE));
        Signature { bytes }
    }

    /// Converts a ValidatedPublicKey to an UnvalidatedPublicKey, which can be used in the strict verification APIs.
    public fun public_key_to_unvalidated(pk: &ValidatedPublicKey): UnvalidatedPublicKey {
        UnvalidatedPublicKey {
            bytes: pk.bytes
        }
    }

    /// Moves a ValidatedPublicKey into an UnvalidatedPublicKey, which can be used in the strict verification APIs.
    public fun public_key_into_unvalidated(pk: ValidatedPublicKey): UnvalidatedPublicKey {
        UnvalidatedPublicKey {
            bytes: pk.bytes
        }
    }

    /// Serializes an UnvalidatedPublicKey struct to 32-bytes.
    public fun unvalidated_public_key_to_bytes(pk: &UnvalidatedPublicKey): vector<u8> {
        pk.bytes
    }

    /// Serializes a ValidatedPublicKey struct to 32-bytes.
    public fun validated_public_key_to_bytes(pk: &ValidatedPublicKey): vector<u8> {
        pk.bytes
    }

    /// Serializes a Signature struct to 64-bytes.
    public fun signature_to_bytes(sig: &Signature): vector<u8> {
        sig.bytes
    }

    /// DEPRECATED: Use `public_key_validate_v2` instead. See `public_key_validate_internal` comments.
    ///
    /// Takes in an *unvalidated* public key and attempts to validate it.
    /// Returns `Some(ValidatedPublicKey)` if successful and `None` otherwise.
    public fun public_key_validate(pk: &UnvalidatedPublicKey): Option<ValidatedPublicKey> {
        new_validated_public_key_from_bytes(pk.bytes)
    }

    /// Takes in an *unvalidated* public key and attempts to validate it.
    /// Returns `Some(ValidatedPublicKey)` if successful and `None` otherwise.
    public fun public_key_validate_v2(pk: &UnvalidatedPublicKey): Option<ValidatedPublicKey> {
        new_validated_public_key_from_bytes_v2(pk.bytes)
    }

    /// Verifies a purported MultiEd25519 `multisignature` under an *unvalidated* `public_key` on the specified `message`.
    /// This call will validate the public key by checking it is NOT in the small subgroup.
    public fun signature_verify_strict(
        multisignature: &Signature,
        public_key: &UnvalidatedPublicKey,
        message: vector<u8>
    ): bool {
        signature_verify_strict_internal(multisignature.bytes, public_key.bytes, message)
    }

    /// This function is used to verify a multi-signature on any BCS-serializable type T. For now, it is used to verify the
    /// proof of private key ownership when rotating authentication keys.
    public fun signature_verify_strict_t<T: drop>(multisignature: &Signature, public_key: &UnvalidatedPublicKey, data: T): bool {
        let encoded = ed25519::new_signed_message(data);

        signature_verify_strict_internal(multisignature.bytes, public_key.bytes, bcs::to_bytes(&encoded))
    }

    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.
    public fun unvalidated_public_key_to_authentication_key(pk: &UnvalidatedPublicKey): vector<u8> {
        public_key_bytes_to_authentication_key(pk.bytes)
    }

    /// Returns the number n of sub-PKs in an unvalidated t-out-of-n MultiEd25519 PK.
    /// If this `UnvalidatedPublicKey` would pass validation in `public_key_validate`, then the returned # of sub-PKs
    /// can be relied upon as correct.
    ///
    /// We provide this API as a cheaper alternative to calling `public_key_validate` and then `validated_public_key_num_sub_pks`
    /// when the input `pk` is known to be valid.
    public fun unvalidated_public_key_num_sub_pks(pk: &UnvalidatedPublicKey): u8 {
        let len = vector::length(&pk.bytes);

        ((len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES) as u8)
    }

    /// Returns the number t of sub-PKs in an unvalidated t-out-of-n MultiEd25519 PK (i.e., the threshold) or `None`
    /// if `bytes` does not correctly encode such a PK.
    public fun unvalidated_public_key_threshold(pk: &UnvalidatedPublicKey): Option<u8> {
        check_and_get_threshold(pk.bytes)
    }

    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.
    public fun validated_public_key_to_authentication_key(pk: &ValidatedPublicKey): vector<u8> {
        public_key_bytes_to_authentication_key(pk.bytes)
    }

    /// Returns the number n of sub-PKs in a validated t-out-of-n MultiEd25519 PK.
    /// Since the format of this PK has been validated, the returned # of sub-PKs is guaranteed to be correct.
    public fun validated_public_key_num_sub_pks(pk: &ValidatedPublicKey): u8 {
        let len = vector::length(&pk.bytes);

        ((len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES) as u8)
    }

    /// Returns the number t of sub-PKs in a validated t-out-of-n MultiEd25519 PK (i.e., the threshold).
    public fun validated_public_key_threshold(pk: &ValidatedPublicKey): u8 {
        let len = vector::length(&pk.bytes);
        let threshold_byte = *vector::borrow(&pk.bytes, len - 1);

        threshold_byte
    }

    /// Checks that the serialized format of a t-out-of-n MultiEd25519 PK correctly encodes 1 <= n <= 32 sub-PKs.
    /// (All `ValidatedPublicKey` objects are guaranteed to pass this check.)
    /// Returns the threshold t <= n of the PK.
    public fun check_and_get_threshold(bytes: vector<u8>): Option<u8> {
        let len = vector::length(&bytes);
        if (len == 0) {
            return option::none<u8>()
        };

        let threshold_num_of_bytes = len % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;
        let num_of_keys = len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;
        let threshold_byte = *vector::borrow(&bytes, len - 1);

        if (num_of_keys == 0 || num_of_keys > MAX_NUMBER_OF_PUBLIC_KEYS || threshold_num_of_bytes != 1) {
            return option::none<u8>()
        } else if (threshold_byte == 0 || threshold_byte > (num_of_keys as u8)) {
            return option::none<u8>()
        } else {
            return option::some(threshold_byte)
        }
    }

    /// Derives the Aptos-specific authentication key of the given Ed25519 public key.
    fun public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8> {
        vector::push_back(&mut pk_bytes, SIGNATURE_SCHEME_ID);
        std::hash::sha3_256(pk_bytes)
    }

    //
    // Native functions
    //

    /// DEPRECATED: Use `public_key_validate_internal_v2` instead. This function was NOT correctly implemented:
    ///
    ///  1. It does not check that the # of sub public keys is > 0, which leads to invalid `ValidatedPublicKey` objects
    ///     against which no signature will verify, since `signature_verify_strict_internal` will reject such invalid PKs.
    ///     This is not a security issue, but a correctness issue. See `bugfix_validated_pk_from_zero_subpks`.
    ///  2. It charges too much gas: if the first sub-PK is invalid, it will charge for verifying all remaining sub-PKs.
    ///
    /// DEPRECATES:
    ///  - new_validated_public_key_from_bytes
    ///  - public_key_validate
    ///
    /// Return `true` if the bytes in `public_key` can be parsed as a valid MultiEd25519 public key: i.e., all underlying
    /// PKs pass point-on-curve and not-in-small-subgroup checks.
    /// Returns `false` otherwise.
    native fun public_key_validate_internal(bytes: vector<u8>): bool;

    /// Return `true` if the bytes in `public_key` can be parsed as a valid MultiEd25519 public key: i.e., all underlying
    /// sub-PKs pass point-on-curve and not-in-small-subgroup checks.
    /// Returns `false` otherwise.
    native fun public_key_validate_v2_internal(bytes: vector<u8>): bool;

    /// Return true if the MultiEd25519 `multisignature` on `message` verifies against the MultiEd25519 `public_key`.
    /// Returns `false` if either:
    /// - The PKs in `public_key` do not all pass points-on-curve or not-in-small-subgroup checks,
    /// - The signatures in `multisignature` do not all pass points-on-curve or not-in-small-subgroup checks,
    /// - the `multisignature` on `message` does not verify.
    native fun signature_verify_strict_internal(
        multisignature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    #[test_only]
    native fun generate_keys_internal(threshold: u8, n: u8): (vector<u8>,vector<u8>);

    #[test_only]
    native fun sign_internal(sk: vector<u8>, message: vector<u8>): vector<u8>;

    //
    // Tests
    //

    #[test_only]
    struct TestMessage has copy, drop {
        foo: vector<u8>,
        bar: u64,
    }

    #[test_only]
    public fun maul_first_signature(sig: &mut Signature) {
        let first_sig_byte = vector::borrow_mut(&mut sig.bytes, 0);
        *first_sig_byte = *first_sig_byte ^ 0xff;
    }


    #[test(fx = @std)]
    fun bugfix_validated_pk_from_zero_subpks(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::multi_ed25519_pk_validate_v2_feature()], vector[]);
        let bytes = vector<u8>[1u8];
        assert!(vector::length(&bytes) == 1, 1);

        // Try deserializing a MultiEd25519 `ValidatedPublicKey` with 0 Ed25519 sub-PKs and 1 threshold byte.
        // This would ideally NOT succeed, but it currently does. Regardless, such invalid PKs will be safely dismissed
        // during signature verification.
        let some = new_validated_public_key_from_bytes(bytes);
        assert!(option::is_none(&check_and_get_threshold(bytes)), 1);   // ground truth
        assert!(option::is_some(&some), 2);                             // incorrect

        // In contrast, the v2 API will fail deserializing, as it should.
        let none = new_validated_public_key_from_bytes_v2(bytes);
        assert!(option::is_none(&none), 3);
    }

    #[test(fx = @std)]
    fun test_validated_pk_without_threshold_byte(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::multi_ed25519_pk_validate_v2_feature()], vector[]);

        let (_, subpk) = ed25519::generate_keys();
        let bytes = ed25519::validated_public_key_to_bytes(&subpk);
        assert!(vector::length(&bytes) == INDIVIDUAL_PUBLIC_KEY_NUM_BYTES, 1);

        // Try deserializing a MultiEd25519 `ValidatedPublicKey` with 1 Ed25519 sub-PKs but no threshold byte, which
        // will not succeed,
        let none = new_validated_public_key_from_bytes(bytes);
        assert!(option::is_none(&check_and_get_threshold(bytes)), 1);   // ground truth
        assert!(option::is_none(&none), 2);                             // correct

        // Similarly, the v2 API will also fail deserializing.
        let none = new_validated_public_key_from_bytes_v2(bytes);
        assert!(option::is_none(&none), 3);                             // also correct
    }

    #[test(fx = @std)]
    fun test_validated_pk_from_small_order_subpk(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::multi_ed25519_pk_validate_v2_feature()], vector[]);
        let torsion_point_with_threshold_1 = vector<u8>[
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1,
        ];

        assert!(option::extract(&mut check_and_get_threshold(torsion_point_with_threshold_1)) == 1, 1);

        // Try deserializing a MultiEd25519 `ValidatedPublicKey` with 1 Ed25519 sub-PKs and 1 threshold byte, as it should,
        // except the sub-PK is of small order. This should not succeed,
        let none = new_validated_public_key_from_bytes(torsion_point_with_threshold_1);
        assert!(option::is_none(&none), 2);

        // Similarly, the v2 API will also fail deserializing.
        let none = new_validated_public_key_from_bytes_v2(torsion_point_with_threshold_1);
        assert!(option::is_none(&none), 3);
    }

    #[test]
    fun test_gen_sign_verify() {
        let thresholds = vector[1, 1, 2, 2, 3, 15,]; // the thresholds, implicitly encoded in the public keys
        let party_counts = vector[1, 2, 2, 3, 10, 32,];
        let test_case_count = vector::length(&party_counts);
        let test_case_idx = 0;

        while (test_case_idx < test_case_count) {
            let threshold = *vector::borrow(&thresholds, test_case_idx);
            let group_size = *vector::borrow(&party_counts, test_case_idx);

            let (sk, pk) = generate_keys(threshold, group_size);
            assert!(validated_public_key_threshold(&pk) == threshold, 1);
            assert!(validated_public_key_num_sub_pks(&pk) == group_size, 2);
            assert!(public_key_validate_v2_internal(pk.bytes), 3);

            let upk = public_key_into_unvalidated(pk);
            assert!(option::extract(&mut unvalidated_public_key_threshold(&upk)) == threshold, 4);
            assert!(unvalidated_public_key_num_sub_pks(&upk) == group_size, 5);

            let msg1 = b"Hello Aptos!";
            let sig1 = sign_arbitrary_bytes(&sk, msg1);
            assert!(signature_verify_strict(&sig1, &upk, msg1), 6);

            let obj2 = TestMessage {
                foo: b"Hello Move!",
                bar: 64,
            };
            let sig2 = sign_struct(&sk, copy obj2);
            assert!(signature_verify_strict_t(&sig2, &upk, copy obj2), 7);

            test_case_idx = test_case_idx + 1;
        }
    }

    #[test]
    fun test_threshold_not_met_rejection() {
        let (sk,pk) = generate_keys(4, 5);
        assert!(validated_public_key_threshold(&pk) == 4, 1);
        assert!(validated_public_key_num_sub_pks(&pk) == 5, 2);
        assert!(public_key_validate_v2_internal(pk.bytes), 3);

        let upk = public_key_into_unvalidated(pk);
        assert!(option::extract(&mut unvalidated_public_key_threshold(&upk)) == 4, 4);
        assert!(unvalidated_public_key_num_sub_pks(&upk) == 5, 5);

        let msg1 = b"Hello Aptos!";
        let sig1 = sign_arbitrary_bytes(&sk, msg1);
        maul_first_signature(&mut sig1);
        assert!(!signature_verify_strict(&sig1, &upk, msg1), 6);

        let obj2 = TestMessage {
            foo: b"Hello Move!",
            bar: 64,
        };
        let sig2 = sign_struct(&sk, copy obj2);
        maul_first_signature(&mut sig2);
        assert!(!signature_verify_strict_t(&sig2, &upk, copy obj2), 7);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/multi_ed25519.spec.move
================================================
spec aptos_std::multi_ed25519 {

    // -----------------------
    // Function specifications
    // -----------------------

    spec new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        include NewUnvalidatedPublicKeyFromBytesAbortsIf;
        ensures result == UnvalidatedPublicKey { bytes };
    }
    spec schema NewUnvalidatedPublicKeyFromBytesAbortsIf {
        bytes: vector<u8>;
        let length = len(bytes);
        aborts_if length / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES > MAX_NUMBER_OF_PUBLIC_KEYS;
        aborts_if length % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES != THRESHOLD_SIZE_BYTES;
    }

    spec new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {
        aborts_if false;
        let cond = len(bytes) % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES == THRESHOLD_SIZE_BYTES
            && spec_public_key_validate_internal(bytes);
        ensures cond ==> result == option::spec_some(ValidatedPublicKey{bytes});
        ensures !cond ==> result == option::spec_none<ValidatedPublicKey>();
    }

    spec new_validated_public_key_from_bytes_v2(bytes: vector<u8>): Option<ValidatedPublicKey> {
        let cond = spec_public_key_validate_v2_internal(bytes);
        ensures cond ==> result == option::spec_some(ValidatedPublicKey{bytes});
        ensures !cond ==> result == option::spec_none<ValidatedPublicKey>();
    }

    spec new_signature_from_bytes(bytes: vector<u8>): Signature {
        include NewSignatureFromBytesAbortsIf;
        ensures result == Signature { bytes };
    }
    spec schema NewSignatureFromBytesAbortsIf {
        bytes: vector<u8>;
        aborts_if len(bytes) % INDIVIDUAL_SIGNATURE_NUM_BYTES != BITMAP_NUM_OF_BYTES;
    }

    spec check_and_get_threshold(bytes: vector<u8>): Option<u8> {
        aborts_if false;
        ensures result == spec_check_and_get_threshold(bytes);
    }

    spec schema PkDivision {
        bytes: vector<u8>;
        result: u8;
        aborts_if len(bytes) / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES > MAX_U8;
        ensures result == len(bytes) / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;
    }

    spec unvalidated_public_key_num_sub_pks(pk: &UnvalidatedPublicKey): u8 {
        let bytes = pk.bytes;
        include PkDivision;
    }

    spec validated_public_key_num_sub_pks(pk: &ValidatedPublicKey): u8 {
        let bytes = pk.bytes;
        include PkDivision;
    }

    spec unvalidated_public_key_threshold(pk: &UnvalidatedPublicKey): Option<u8> {
        aborts_if false;
        ensures result == spec_check_and_get_threshold(pk.bytes);
    }

    spec validated_public_key_threshold(pk: &ValidatedPublicKey): u8 {
        aborts_if len(pk.bytes) == 0;
        ensures result == pk.bytes[len(pk.bytes) - 1];
    }

    spec public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8> {
        pragma opaque;
        aborts_if false;
        ensures [abstract] result == spec_public_key_bytes_to_authentication_key(pk_bytes);
    }

    // ----------------
    // Native functions
    // ----------------

    spec public_key_validate_internal(bytes: vector<u8>): bool {
        pragma opaque;
        aborts_if false;
        ensures (len(bytes) / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES > MAX_NUMBER_OF_PUBLIC_KEYS) ==> (result == false);
        ensures result == spec_public_key_validate_internal(bytes);
    }

    spec public_key_validate_v2_internal(bytes: vector<u8>): bool {
        pragma opaque;
        ensures result == spec_public_key_validate_v2_internal(bytes);
    }

    spec signature_verify_strict_internal(
        multisignature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool {
        pragma opaque;
        aborts_if false;
        ensures result == spec_signature_verify_strict_internal(multisignature, public_key, message);
    }

    /// # Helper functions

    spec fun spec_check_and_get_threshold(bytes: vector<u8>): Option<u8> {
        let len = len(bytes);
        if (len == 0) {
            option::none<u8>()
        } else {
            let threshold_num_of_bytes = len % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;
            let num_of_keys = len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;
            let threshold_byte = bytes[len - 1];
            if (num_of_keys == 0 || num_of_keys > MAX_NUMBER_OF_PUBLIC_KEYS || len % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES != 1) {
                option::none<u8>()
            } else if (threshold_byte == 0 || threshold_byte > (num_of_keys as u8)) {
                option::none<u8>()
            } else {
                option::spec_some(threshold_byte)
            }
        }
    }

    spec fun spec_signature_verify_strict_internal(
        multisignature: vector<u8>,
        public_key: vector<u8>,
        message: vector<u8>
    ): bool;

    spec fun spec_public_key_validate_internal(bytes: vector<u8>): bool;

    spec fun spec_public_key_validate_v2_internal(bytes: vector<u8>): bool;

    spec fun spec_public_key_bytes_to_authentication_key(pk_bytes: vector<u8>): vector<u8>;

    spec fun spec_signature_verify_strict_t<T>(signature: Signature, public_key: UnvalidatedPublicKey, data: T): bool {
        let encoded = ed25519::new_signed_message<T>(data);
        let message = bcs::serialize(encoded);
        spec_signature_verify_strict_internal(signature.bytes, public_key.bytes, message)
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.move
================================================
/// This module contains functions for Ristretto255 curve arithmetic, assuming addition as the group operation.
///
/// The order of the Ristretto255 elliptic curve group is $\ell = 2^252 + 27742317777372353535851937790883648493$, same
/// as the order of the prime-order subgroup of Curve25519.
///
/// This module provides two structs for encoding Ristretto elliptic curves to the developer:
///
///  - First, a 32-byte-sized CompressedRistretto struct, which is used to persist points in storage.
///
///  - Second, a larger, in-memory, RistrettoPoint struct, which is decompressable from a CompressedRistretto struct. This
/// larger struct can be used for fast arithmetic operations (additions, multiplications, etc.). The results can be saved
/// back into storage by compressing RistrettoPoint structs back to CompressedRistretto structs.
///
/// This module also provides a Scalar struct for persisting scalars in storage and doing fast arithmetic on them.
///
/// One invariant maintained by this module is that all CompressedRistretto structs store a canonically-encoded point,
/// which can always be decompressed into a valid point on the curve as a RistrettoPoint struct. Unfortunately, due to
/// limitations in our underlying curve25519-dalek elliptic curve library, this decompression will unnecessarily verify
/// the validity of the point and thus slightly decrease performance.
///
/// Similarly, all Scalar structs store a canonically-encoded scalar, which can always be safely operated on using
/// arithmetic operations.
///
/// In the future, we might support additional features:
///
/// * For scalars:
///    - batch_invert()
///
///  * For points:
///    - double()
///      + The challenge is that curve25519-dalek does NOT export double for Ristretto points (nor for Edwards)
///
///    - double_and_compress_batch()
///
///    - fixed-base, variable-time via optional_mixed_multiscalar_mul() in VartimePrecomputedMultiscalarMul
///      + This would require a storage-friendly RistrettoBasepointTable and an in-memory variant of it too
///      + Similar to the CompressedRistretto and RistrettoPoint structs in this module
///      + The challenge is that curve25519-dalek's RistrettoBasepointTable is not serializable

module aptos_std::ristretto255 {
    use std::features;
    use std::option::Option;

    #[test_only]
    use std::option;

    //
    // Constants
    //

    /// The order of the Ristretto255 group and its scalar field, in little-endian.
    const ORDER_ELL: vector<u8> = x"edd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010";

    /// `ORDER_ELL` - 1: i.e., the "largest", reduced scalar in the field
    const L_MINUS_ONE: vector<u8> = x"ecd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010";

    /// The maximum size in bytes of a canonically-encoded Scalar is 32 bytes.
    const MAX_SCALAR_NUM_BYTES: u64 = 32u64;

    /// The maximum size in bits of a canonically-encoded Scalar is 256 bits.
    const MAX_SCALAR_NUM_BITS: u64 = 256u64;

    /// The maximum size in bytes of a canonically-encoded Ristretto255 point is 32 bytes.
    const MAX_POINT_NUM_BYTES: u64 = 32u64;

    /// The basepoint (generator) of the Ristretto255 group
    const BASE_POINT: vector<u8> = x"e2f2ae0a6abc4e71a884a961c500515f58e30b6aa582dd8db6a65945e08d2d76";

    /// The hash of the basepoint of the Ristretto255 group using SHA3_512
    const HASH_BASE_POINT: vector<u8> = x"8c9240b456a9e6dc65c377a1048d745f94a08cdb7f44cbcd7b46f34048871134";

    //
    // Reasons for error codes
    //

    /// The number of scalars does not match the number of points.
    const E_DIFFERENT_NUM_POINTS_AND_SCALARS: u64 = 1;
    /// Expected more than zero points as input.
    const E_ZERO_POINTS: u64 = 2;
    /// Expected more than zero scalars as input.
    const E_ZERO_SCALARS: u64 = 3;
    /// Too many points have been created in the current transaction execution.
    const E_TOO_MANY_POINTS_CREATED: u64 = 4;
    /// The native function has not been deployed yet.
    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 5;

    //
    // Scalar and point structs
    //

    /// This struct represents a scalar as a little-endian byte encoding of an integer in $\mathbb{Z}_\ell$, which is
    /// stored in `data`. Here, \ell denotes the order of the scalar field (and the underlying elliptic curve group).
    struct Scalar has copy, store, drop {
        data: vector<u8>
    }

    /// This struct represents a serialized point on the Ristretto255 curve, in 32 bytes.
    /// This struct can be decompressed from storage into an in-memory RistrettoPoint, on which fast curve arithmetic
    /// can be performed.
    struct CompressedRistretto has copy, store, drop {
        data: vector<u8>
    }

    /// This struct represents an in-memory Ristretto255 point and supports fast curve arithmetic.
    ///
    /// An important invariant: There will never be two RistrettoPoint's constructed with the same handle. One can have
    /// immutable references to the same RistrettoPoint, of course.
    struct RistrettoPoint has drop {
        handle: u64
    }

    //
    // Functions for arithmetic on points
    //

    /// Returns the identity point as a CompressedRistretto.
    public fun point_identity_compressed(): CompressedRistretto {
        CompressedRistretto {
            data: x"0000000000000000000000000000000000000000000000000000000000000000"
        }
    }

    /// Returns the identity point as a CompressedRistretto.
    public fun point_identity(): RistrettoPoint {
        RistrettoPoint {
            handle: point_identity_internal()
        }
    }

    /// Returns the basepoint (generator) of the Ristretto255 group as a compressed point
    public fun basepoint_compressed(): CompressedRistretto {
        CompressedRistretto {
            data: BASE_POINT
        }
    }

    /// Returns the hash-to-point result of serializing the basepoint of the Ristretto255 group.
    /// For use as the random value basepoint in Pedersen commitments
    public fun hash_to_point_base(): RistrettoPoint {
        let comp_res = CompressedRistretto { data: HASH_BASE_POINT };
        point_decompress(&comp_res)
    }

    /// Returns the basepoint (generator) of the Ristretto255 group
    public fun basepoint(): RistrettoPoint {
        let (handle, _) = point_decompress_internal(BASE_POINT);

        RistrettoPoint {
            handle
        }
    }

    /// Multiplies the basepoint (generator) of the Ristretto255 group by a scalar and returns the result.
    /// This call is much faster than `point_mul(&basepoint(), &some_scalar)` because of precomputation tables.
    public fun basepoint_mul(a: &Scalar): RistrettoPoint {
        RistrettoPoint {
            handle: basepoint_mul_internal(a.data)
        }
    }

    /// Creates a new CompressedRistretto point from a sequence of 32 bytes. If those bytes do not represent a valid
    /// point, returns None.
    public fun new_compressed_point_from_bytes(bytes: vector<u8>): Option<CompressedRistretto> {
        if (point_is_canonical_internal(bytes)) {
            std::option::some(CompressedRistretto {
                data: bytes
            })
        } else {
            std::option::none<CompressedRistretto>()
        }
    }

    /// Creates a new RistrettoPoint from a sequence of 32 bytes. If those bytes do not represent a valid point,
    /// returns None.
    public fun new_point_from_bytes(bytes: vector<u8>): Option<RistrettoPoint> {
        let (handle, is_canonical) = point_decompress_internal(bytes);
        if (is_canonical) {
            std::option::some(RistrettoPoint { handle })
        } else {
            std::option::none<RistrettoPoint>()
        }
    }

    /// Given a compressed ristretto point `point`, returns the byte representation of that point
    public fun compressed_point_to_bytes(point: CompressedRistretto): vector<u8> {
        point.data
    }

    /// DEPRECATED: Use the more clearly-named `new_point_from_sha2_512`
    ///
    /// Hashes the input to a uniformly-at-random RistrettoPoint via SHA512.
    public fun new_point_from_sha512(sha2_512_input: vector<u8>): RistrettoPoint {
        new_point_from_sha2_512(sha2_512_input)
    }

    /// Hashes the input to a uniformly-at-random RistrettoPoint via SHA2-512.
    public fun new_point_from_sha2_512(sha2_512_input: vector<u8>): RistrettoPoint {
        RistrettoPoint {
            handle: new_point_from_sha512_internal(sha2_512_input)
        }
    }

    /// Samples a uniformly-at-random RistrettoPoint given a sequence of 64 uniformly-at-random bytes. This function
    /// can be used to build a collision-resistant hash function that maps 64-byte messages to RistrettoPoint's.
    public fun new_point_from_64_uniform_bytes(bytes: vector<u8>): Option<RistrettoPoint> {
        if (std::vector::length(&bytes) == 64) {
            std::option::some(RistrettoPoint {
                handle: new_point_from_64_uniform_bytes_internal(bytes)
            })
        } else {
            std::option::none<RistrettoPoint>()
        }
    }

    /// Decompresses a CompressedRistretto from storage into a RistrettoPoint which can be used for fast arithmetic.
    public fun point_decompress(point: &CompressedRistretto): RistrettoPoint {
        // NOTE: Our CompressedRistretto invariant assures us that every CompressedRistretto in storage is a valid
        // RistrettoPoint
        let (handle, _) = point_decompress_internal(point.data);
        RistrettoPoint { handle }
    }

    /// Clones a RistrettoPoint.
    public fun point_clone(point: &RistrettoPoint): RistrettoPoint {
        if(!features::bulletproofs_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        RistrettoPoint {
            handle: point_clone_internal(point.handle)
        }
    }

    /// Compresses a RistrettoPoint to a CompressedRistretto which can be put in storage.
    public fun point_compress(point: &RistrettoPoint): CompressedRistretto {
        CompressedRistretto {
            data: point_compress_internal(point)
        }
    }

    /// Returns the sequence of bytes representin this Ristretto point.
    /// To convert a RistrettoPoint 'p' to bytes, first compress it via `c = point_compress(&p)`, and then call this
    /// function on `c`.
    public fun point_to_bytes(point: &CompressedRistretto): vector<u8> {
        point.data
    }

    /// Returns a * point.
    public fun point_mul(point: &RistrettoPoint, a: &Scalar): RistrettoPoint {
        RistrettoPoint {
            handle: point_mul_internal(point, a.data, false)
        }
    }

    /// Sets a *= point and returns 'a'.
    public fun point_mul_assign(point: &mut RistrettoPoint, a: &Scalar): &mut RistrettoPoint {
        point_mul_internal(point, a.data, true);
        point
    }

    /// Returns (a * a_base + b * base_point), where base_point is the Ristretto basepoint encoded in `BASE_POINT`.
    public fun basepoint_double_mul(a: &Scalar, a_base: &RistrettoPoint, b: &Scalar): RistrettoPoint {
        RistrettoPoint {
            handle: basepoint_double_mul_internal(a.data, a_base, b.data)
        }
    }

    /// Returns a + b
    public fun point_add(a: &RistrettoPoint, b: &RistrettoPoint): RistrettoPoint {
        RistrettoPoint {
            handle: point_add_internal(a, b, false)
        }
    }

    /// Sets a += b and returns 'a'.
    public fun point_add_assign(a: &mut RistrettoPoint, b: &RistrettoPoint): &mut RistrettoPoint {
        point_add_internal(a, b, true);
        a
    }

    /// Returns a - b
    public fun point_sub(a: &RistrettoPoint, b: &RistrettoPoint): RistrettoPoint {
        RistrettoPoint {
            handle: point_sub_internal(a, b, false)
        }
    }

    /// Sets a -= b and returns 'a'.
    public fun point_sub_assign(a: &mut RistrettoPoint, b: &RistrettoPoint): &mut RistrettoPoint {
        point_sub_internal(a, b, true);
        a
    }

    /// Returns -a
    public fun point_neg(a: &RistrettoPoint): RistrettoPoint {
        RistrettoPoint {
            handle: point_neg_internal(a, false)
        }
    }

    /// Sets a = -a, and returns 'a'.
    public fun point_neg_assign(a: &mut RistrettoPoint): &mut RistrettoPoint {
        point_neg_internal(a, true);
        a
    }

    /// Returns true if the two RistrettoPoints are the same points on the elliptic curve.
    native public fun point_equals(g: &RistrettoPoint, h: &RistrettoPoint): bool;

    /// Computes a double-scalar multiplication, returning a_1 p_1 + a_2 p_2
    /// This function is much faster than computing each a_i p_i using `point_mul` and adding up the results using `point_add`.
    public fun double_scalar_mul(scalar1: &Scalar, point1: &RistrettoPoint, scalar2: &Scalar, point2: &RistrettoPoint): RistrettoPoint {
        if(!features::bulletproofs_enabled()) {
            abort(std::error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE))
        };

        RistrettoPoint {
            handle: double_scalar_mul_internal(point1.handle, point2.handle, scalar1.data, scalar2.data)
        }
    }

    /// Computes a multi-scalar multiplication, returning a_1 p_1 + a_2 p_2 + ... + a_n p_n.
    /// This function is much faster than computing each a_i p_i using `point_mul` and adding up the results using `point_add`.
    public fun multi_scalar_mul(points: &vector<RistrettoPoint>, scalars: &vector<Scalar>): RistrettoPoint {
        assert!(!std::vector::is_empty(points), std::error::invalid_argument(E_ZERO_POINTS));
        assert!(!std::vector::is_empty(scalars), std::error::invalid_argument(E_ZERO_SCALARS));
        assert!(std::vector::length(points) == std::vector::length(scalars), std::error::invalid_argument(E_DIFFERENT_NUM_POINTS_AND_SCALARS));

        RistrettoPoint {
            handle: multi_scalar_mul_internal<RistrettoPoint, Scalar>(points, scalars)
        }
    }

    //
    // Functions for arithmetic on Scalars
    //

    /// Given a sequence of 32 bytes, checks if they canonically-encode a Scalar and return it.
    /// Otherwise, returns None.
    public fun new_scalar_from_bytes(bytes: vector<u8>): Option<Scalar> {
        if (scalar_is_canonical_internal(bytes)) {
            std::option::some(Scalar {
                data: bytes
            })
        } else {
            std::option::none<Scalar>()
        }
    }

    /// DEPRECATED: Use the more clearly-named `new_scalar_from_sha2_512`
    ///
    /// Hashes the input to a uniformly-at-random Scalar via SHA2-512
    public fun new_scalar_from_sha512(sha2_512_input: vector<u8>): Scalar {
        new_scalar_from_sha2_512(sha2_512_input)
    }

    /// Hashes the input to a uniformly-at-random Scalar via SHA2-512
    public fun new_scalar_from_sha2_512(sha2_512_input: vector<u8>): Scalar {
        Scalar {
            data: scalar_from_sha512_internal(sha2_512_input)
        }
    }

    /// Creates a Scalar from an u8.
    public fun new_scalar_from_u8(byte: u8): Scalar {
        let s = scalar_zero();
        let byte_zero = std::vector::borrow_mut(&mut s.data, 0);
        *byte_zero = byte;

        s
    }

    /// Creates a Scalar from an u32.
    public fun new_scalar_from_u32(four_bytes: u32): Scalar {
        Scalar {
            data: scalar_from_u64_internal((four_bytes as u64))
        }
    }

    /// Creates a Scalar from an u64.
    public fun new_scalar_from_u64(eight_bytes: u64): Scalar {
        Scalar {
            data: scalar_from_u64_internal(eight_bytes)
        }
    }

    /// Creates a Scalar from an u128.
    public fun new_scalar_from_u128(sixteen_bytes: u128): Scalar {
        Scalar {
            data: scalar_from_u128_internal(sixteen_bytes)
        }
    }

    /// Creates a Scalar from 32 bytes by reducing the little-endian-encoded number in those bytes modulo $\ell$.
    public fun new_scalar_reduced_from_32_bytes(bytes: vector<u8>): Option<Scalar> {
        if (std::vector::length(&bytes) == 32) {
            std::option::some(Scalar {
                data: scalar_reduced_from_32_bytes_internal(bytes)
            })
        } else {
            std::option::none()
        }
    }

    /// Samples a scalar uniformly-at-random given 64 uniform-at-random bytes as input by reducing the little-endian-encoded number
    /// in those bytes modulo $\ell$.
    public fun new_scalar_uniform_from_64_bytes(bytes: vector<u8>): Option<Scalar> {
        if (std::vector::length(&bytes) == 64) {
            std::option::some(Scalar {
                data: scalar_uniform_from_64_bytes_internal(bytes)
            })
        } else {
            std::option::none()
        }
    }

    /// Returns 0 as a Scalar.
    public fun scalar_zero(): Scalar {
        Scalar {
            data: x"0000000000000000000000000000000000000000000000000000000000000000"
        }
    }

    /// Returns true if the given Scalar equals 0.
    public fun scalar_is_zero(s: &Scalar): bool {
        s.data == x"0000000000000000000000000000000000000000000000000000000000000000"
    }

    /// Returns 1 as a Scalar.
    public fun scalar_one(): Scalar {
        Scalar {
            data: x"0100000000000000000000000000000000000000000000000000000000000000"
        }
    }

    /// Returns true if the given Scalar equals 1.
    public fun scalar_is_one(s: &Scalar): bool {
        s.data == x"0100000000000000000000000000000000000000000000000000000000000000"
    }

    /// Returns true if the two scalars are equal.
    public fun scalar_equals(lhs: &Scalar, rhs: &Scalar): bool {
        lhs.data == rhs.data
    }

    /// Returns the inverse s^{-1} mod \ell of a scalar s.
    /// Returns None if s is zero.
    public fun scalar_invert(s: &Scalar): Option<Scalar> {
        if (scalar_is_zero(s)) {
            std::option::none<Scalar>()
        } else {
            std::option::some(Scalar {
                data: scalar_invert_internal(s.data)
            })
        }
    }

    /// Returns the product of the two scalars.
    public fun scalar_mul(a: &Scalar, b: &Scalar): Scalar {
        Scalar {
            data: scalar_mul_internal(a.data, b.data)
        }
    }

    /// Computes the product of 'a' and 'b' and assigns the result to 'a'.
    /// Returns 'a'.
    public fun scalar_mul_assign(a: &mut Scalar, b: &Scalar): &mut Scalar {
        a.data = scalar_mul(a, b).data;
        a
    }

    /// Returns the sum of the two scalars.
    public fun scalar_add(a: &Scalar, b: &Scalar): Scalar {
        Scalar {
            data: scalar_add_internal(a.data, b.data)
        }
    }

    /// Computes the sum of 'a' and 'b' and assigns the result to 'a'
    /// Returns 'a'.
    public fun scalar_add_assign(a: &mut Scalar, b: &Scalar): &mut Scalar {
        a.data = scalar_add(a, b).data;
        a
    }

    /// Returns the difference of the two scalars.
    public fun scalar_sub(a: &Scalar, b: &Scalar): Scalar {
        Scalar {
            data: scalar_sub_internal(a.data, b.data)
        }
    }

    /// Subtracts 'b' from 'a' and assigns the result to 'a'.
    /// Returns 'a'.
    public fun scalar_sub_assign(a: &mut Scalar, b: &Scalar): &mut Scalar {
        a.data = scalar_sub(a, b).data;
        a
    }

    /// Returns the negation of 'a': i.e., $(0 - a) \mod \ell$.
    public fun scalar_neg(a: &Scalar): Scalar {
        Scalar {
            data: scalar_neg_internal(a.data)
        }
    }

    /// Replaces 'a' by its negation.
    ///  Returns 'a'.
    public fun scalar_neg_assign(a: &mut Scalar): &mut Scalar {
        a.data = scalar_neg(a).data;
        a
    }

    /// Returns the byte-representation of the scalar.
    public fun scalar_to_bytes(s: &Scalar): vector<u8> {
        s.data
    }

    //
    // Only used internally for implementing CompressedRistretto and RistrettoPoint
    //

    // NOTE: This was supposed to be more clearly named with *_sha2_512_*.
    native fun new_point_from_sha512_internal(sha2_512_input: vector<u8>): u64;

    native fun new_point_from_64_uniform_bytes_internal(bytes: vector<u8>): u64;

    native fun point_is_canonical_internal(bytes: vector<u8>): bool;

    native fun point_identity_internal(): u64;

    native fun point_decompress_internal(maybe_non_canonical_bytes: vector<u8>): (u64, bool);

    native fun point_clone_internal(point_handle: u64): u64;
    native fun point_compress_internal(point: &RistrettoPoint): vector<u8>;

    native fun point_mul_internal(point: &RistrettoPoint, a: vector<u8>, in_place: bool): u64;

    native fun basepoint_mul_internal(a: vector<u8>): u64;

    native fun basepoint_double_mul_internal(a: vector<u8>, some_point: &RistrettoPoint, b: vector<u8>): u64;

    native fun point_add_internal(a: &RistrettoPoint, b: &RistrettoPoint, in_place: bool): u64;

    native fun point_sub_internal(a: &RistrettoPoint, b: &RistrettoPoint, in_place: bool): u64;

    native fun point_neg_internal(a: &RistrettoPoint, in_place: bool): u64;

    native fun double_scalar_mul_internal(point1: u64, point2: u64, scalar1: vector<u8>, scalar2: vector<u8>): u64;

    /// The generic arguments are needed to deal with some Move VM peculiarities which prevent us from borrowing the
    /// points (or scalars) inside a &vector in Rust.
    ///
    /// WARNING: This function can only be called with P = RistrettoPoint and S = Scalar.
    native fun multi_scalar_mul_internal<P, S>(points: &vector<P>, scalars: &vector<S>): u64;

    //
    // Only used internally for implementing Scalar.
    //

    native fun scalar_is_canonical_internal(s: vector<u8>): bool;

    native fun scalar_from_u64_internal(num: u64): vector<u8>;

    native fun scalar_from_u128_internal(num: u128): vector<u8>;

    native fun scalar_reduced_from_32_bytes_internal(bytes: vector<u8>): vector<u8>;

    native fun scalar_uniform_from_64_bytes_internal(bytes: vector<u8>): vector<u8>;

    native fun scalar_invert_internal(bytes: vector<u8>): vector<u8>;

    // NOTE: This was supposed to be more clearly named with *_sha2_512_*.
    native fun scalar_from_sha512_internal(sha2_512_input: vector<u8>): vector<u8>;

    native fun scalar_mul_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    native fun scalar_add_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    native fun scalar_sub_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    native fun scalar_neg_internal(a_bytes: vector<u8>): vector<u8>;

    #[test_only]
    native fun random_scalar_internal(): vector<u8>;

    //
    // Test-only functions
    //

    #[test_only]
    public fun random_scalar(): Scalar {
        Scalar {
            data: random_scalar_internal()
        }
    }

    #[test_only]
    public fun random_point(): RistrettoPoint {
        let s = random_scalar();

        basepoint_mul(&s)
    }

    //
    // Testing constants
    //

    // The scalar 2
    #[test_only]
    const TWO_SCALAR: vector<u8> = x"0200000000000000000000000000000000000000000000000000000000000000";

    // Non-canonical scalar: the order \ell of the group + 1
    #[test_only]
    const L_PLUS_ONE: vector<u8> = x"eed3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010";

    // Non-canonical scalar: the order \ell of the group + 2
    #[test_only]
    const L_PLUS_TWO: vector<u8> = x"efd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010";

    // Some random scalar denoted by X
    #[test_only]
    const X_SCALAR: vector<u8> = x"4e5ab4345d4708845913b4641bc27d5252a585101bcc4244d449f4a879d9f204";

    // X^{-1} = 1/X = 6859937278830797291664592131120606308688036382723378951768035303146619657244
    // 0x1CDC17FCE0E9A5BBD9247E56BB016347BBBA31EDD5A9BB96D50BCD7A3F962A0F
    #[test_only]
    const X_INV_SCALAR: vector<u8> = x"1cdc17fce0e9a5bbd9247e56bb016347bbba31edd5a9bb96d50bcd7a3f962a0f";

    // Some random scalar Y = 2592331292931086675770238855846338635550719849568364935475441891787804997264
    #[test_only]
    const Y_SCALAR: vector<u8> = x"907633fe1c4b66a4a28d2dd7678386c353d0de5455d4fc9de8ef7ac31f35bb05";

    // X * Y = 5690045403673944803228348699031245560686958845067437804563560795922180092780
    #[test_only]
    const X_TIMES_Y_SCALAR: vector<u8> = x"6c3374a1894f62210aaa2fe186a6f92ce0aa75c2779581c295fc08179a73940c";

    // X + 2^256 * X \mod \ell
    #[test_only]
    const REDUCED_X_PLUS_2_TO_256_TIMES_X_SCALAR: vector<u8> = x"d89ab38bd279024745639ed817ad3f64cc005b32db9939f91c521fc564a5c008";

    // sage: l = 2^252 + 27742317777372353535851937790883648493
    // sage: big = 2^256 - 1
    // sage: repr((big % l).digits(256))
    #[test_only]
    const REDUCED_2_256_MINUS_1_SCALAR: vector<u8> = x"1c95988d7431ecd670cf7d73f45befc6feffffffffffffffffffffffffffff0f";

    #[test_only]
    const NON_CANONICAL_ALL_ONES: vector<u8> = x"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";

    #[test_only]
    const A_SCALAR: vector<u8> = x"1a0e978a90f6622d3747023f8ad8264da758aa1b88e040d1589e7b7f2376ef09";

    // Generated in curve25519-dalek via:
    // ```
    //     let mut hasher = sha2::Sha512::default();
    //     hasher.update(b"bello!");
    //     let s = Scalar::from_hash(hasher);
    //     println!("scalar: {:x?}", s.to_bytes());
    // ```
    #[test_only]
    const B_SCALAR: vector<u8> = x"dbfd97afd38a06f0138d0527efb28ead5b7109b486465913bf3aa472a8ed4e0d";

    #[test_only]
    const A_TIMES_B_SCALAR: vector<u8> = x"2ab50e383d7c210f74d5387330735f18315112d10dfb98fcce1e2620c0c01402";

    #[test_only]
    const A_PLUS_B_SCALAR: vector<u8> = x"083839dd491e57c5743710c39a91d6e502cab3cf0e279ae417d91ff2cb633e07";

    #[test_only]
    /// A_SCALAR * BASE_POINT, computed by modifying a test in curve25519-dalek in src/edwards.rs to do:
    /// ```
    ///     let comp = RistrettoPoint(A_TIMES_BASEPOINT.decompress().unwrap()).compress();
    ///     println!("hex: {:x?}", comp.to_bytes());
    /// ```
    const A_TIMES_BASE_POINT: vector<u8> = x"96d52d9262ee1e1aae79fbaee8c1d9068b0d01bf9a4579e618090c3d1088ae10";

    #[test_only]
    const A_POINT: vector<u8> = x"e87feda199d72b83de4f5b2d45d34805c57019c6c59c42cb70ee3d19aa996f75";
    #[test_only]
    const B_POINT: vector<u8> = x"fa0b3624b081c62f364d0b2839dcc76d7c3ab0e27e31beb2b9ed766575f28e76";
    #[test_only]
    const A_PLUS_B_POINT: vector<u8> = x"70cf3753475b9ff33e2f84413ed6b5052073bccc0a0a81789d3e5675dc258056";

    //    const NON_CANONICAL_LARGEST_ED25519_S: vector<u8> = x"f8ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f";
    //    const CANONICAL_LARGEST_ED25519_S_PLUS_ONE: vector<u8> = x"7e344775474a7f9723b63a8be92ae76dffffffffffffffffffffffffffffff0f";
    //    const CANONICAL_LARGEST_ED25519_S_MINUS_ONE: vector<u8> = x"7c344775474a7f9723b63a8be92ae76dffffffffffffffffffffffffffffff0f";

    //
    // Tests
    //

    #[test]
    fun test_point_decompression() {
        let compressed = new_compressed_point_from_bytes(A_POINT);
        assert!(std::option::is_some(&compressed), 1);

        let point = new_point_from_bytes(A_POINT);
        assert!(std::option::is_some(&point), 1);

        let point = std::option::extract(&mut point);
        let compressed = std::option::extract(&mut compressed);
        let same_point = point_decompress(&compressed);

        assert!(point_equals(&point, &same_point), 1);
    }

    #[test]
    fun test_point_equals() {
        let g = basepoint();
        let same_g = std::option::extract(&mut new_point_from_bytes(BASE_POINT));
        let ag = std::option::extract(&mut new_point_from_bytes(A_TIMES_BASE_POINT));

        assert!(point_equals(&g, &same_g), 1);
        assert!(!point_equals(&g, &ag), 1);
    }

    #[test]
    fun test_point_mul() {
        // fetch g
        let g = basepoint();
        // fetch a
        let a = std::option::extract(&mut new_scalar_from_bytes(A_SCALAR));
        // fetch expected a*g
        let ag = std::option::extract(&mut new_point_from_bytes(A_TIMES_BASE_POINT));

        // compute a*g
        let p = point_mul(&g, &a);

        // sanity-check the handles
        assert!(g.handle == 0, 1);
        assert!(ag.handle == 1, 1);
        assert!(p.handle == 2, 1);

        assert!(!point_equals(&g, &ag), 1);     // make sure input g remains unmodifed
        assert!(point_equals(&p, &ag), 1);   // make sure output a*g is correct
    }

    #[test]
    fun test_point_mul_assign() {
        let g = basepoint();
        assert!(g.handle == 0, 1);

        let a = std::option::extract(&mut new_scalar_from_bytes(A_SCALAR));

        let ag = std::option::extract(&mut new_point_from_bytes(A_TIMES_BASE_POINT));
        assert!(ag.handle == 1, 1);
        assert!(!point_equals(&g, &ag), 1);

        {
            // NOTE: new_g is just a mutable reference to g
            let upd_g = point_mul_assign(&mut g, &a);

            // in a mul_assign the returned &mut RistrettoPoint reference should have the same handle as 'g'
            assert!(upd_g.handle == 0, 1);

            assert!(point_equals(upd_g, &ag), 1);
        };

        assert!(point_equals(&g, &ag), 1);
    }

    #[test]
    fun test_point_add() {
        // fetch a
        let a = std::option::extract(&mut new_point_from_bytes(A_POINT));

        // fetch b
        let b = std::option::extract(&mut new_point_from_bytes(B_POINT));

        // fetch expected a + b
        let a_plus_b = std::option::extract(&mut new_point_from_bytes(A_PLUS_B_POINT));

        // compute a*g
        let result = point_add(&a, &b);

        assert!(!point_equals(&a, &b), 1);

        // sanity-check the handles
        assert!(a.handle == 0, 1);
        assert!(b.handle == 1, 1);
        assert!(a_plus_b.handle == 2, 1);
        assert!(result.handle == 3, 1);

        assert!(!point_equals(&a, &result), 1);     // make sure input a remains unmodifed
        assert!(!point_equals(&b, &result), 1);     // make sure input b remains unmodifed
        assert!(point_equals(&a_plus_b, &result), 1);   // make sure output a+b is correct
    }

    #[test]
    fun test_point_add_assign_0_0() {
        test_point_add_assign_internal(0, 0);
    }

    #[test]
    fun test_point_add_assign_1_0() {
        test_point_add_assign_internal(1, 0);
    }

    #[test]
    fun test_point_add_assign_0_1() {
        test_point_add_assign_internal(0, 1);
    }

    #[test]
    fun test_point_add_assign_3_7() {
        test_point_add_assign_internal(3, 7);
    }

    #[test_only]
    fun test_point_add_assign_internal(before_a_gap: u64, before_b_gap: u64) {
        // create extra RistrettoPoints here, so as to generate different PointStore layouts inside the native Rust implementation
        let c = before_a_gap;
        while (c > 0) {
            let _ignore = std::option::extract(&mut new_point_from_bytes(BASE_POINT));

            c = c - 1;
        };

        // fetch a
        let a = std::option::extract(&mut new_point_from_bytes(A_POINT));

        // create extra RistrettoPoints here, so as to generate different PointStore layouts inside the native Rust implementation
        let c = before_b_gap;
        while (c > 0) {
            let _ignore = std::option::extract(&mut new_point_from_bytes(BASE_POINT));

            c = c - 1;
        };
        // fetch b
        let b = std::option::extract(&mut new_point_from_bytes(B_POINT));

        let a_plus_b = std::option::extract(&mut new_point_from_bytes(A_PLUS_B_POINT));

        // sanity-check the handles
        assert!(a.handle == before_a_gap, 1);
        assert!(b.handle == 1 + before_a_gap + before_b_gap, 1);
        assert!(a_plus_b.handle == 2 + before_a_gap + before_b_gap, 1);

        assert!(!point_equals(&a, &b), 1);
        assert!(!point_equals(&a, &a_plus_b), 1);

        {
            // NOTE: new_h is just a mutable reference to g
            let upd_a = point_add_assign(&mut a, &b);

            // in a add_assign the returned &mut RistrettoPoint reference should have the same handle as 'a'
            assert!(upd_a.handle == before_a_gap, 1);

            assert!(point_equals(upd_a, &a_plus_b), 1);
        };

        assert!(point_equals(&a, &a_plus_b), 1);
    }

    #[test]
    fun test_point_sub() {
        // fetch a
        let a = std::option::extract(&mut new_point_from_bytes(A_POINT));

        // fetch b
        let b = std::option::extract(&mut new_point_from_bytes(B_POINT));

        // fetch expected a + b
        let a_plus_b = std::option::extract(&mut new_point_from_bytes(A_PLUS_B_POINT));

        // compute a*g
        let result = point_sub(&a_plus_b, &b);

        assert!(!point_equals(&a, &b), 1);

        // sanity-check the handles
        assert!(a.handle == 0, 1);
        assert!(b.handle == 1, 1);
        assert!(a_plus_b.handle == 2, 1);
        assert!(result.handle == 3, 1);

        assert!(!point_equals(&a_plus_b, &result), 1);     // make sure input a_plus_b remains unmodifed
        assert!(!point_equals(&b, &result), 1);     // make sure input b remains unmodifed
        assert!(point_equals(&a, &result), 1);   // make sure output 'a+b-b' is correct
    }

    #[test]
    fun test_point_neg() {
        let a = std::option::extract(&mut new_point_from_bytes(A_POINT));

        let neg_a = point_neg(&a);

        assert!(a.handle != neg_a.handle, 1);
        assert!(!point_equals(&a, &neg_a), 1);
        assert!(!point_equals(&point_add(&point_identity(), &a), &neg_a), 1);
        assert!(point_equals(&point_add(&a, &neg_a), &point_identity()), 1);

        let handle = a.handle;
        let neg_a_ref = point_neg_assign(&mut a);
        assert!(handle == neg_a_ref.handle, 1);
        assert!(point_equals(neg_a_ref, &neg_a), 1);
    }

    #[test]
    fun test_basepoint_mul() {
        let a = Scalar { data: A_SCALAR };
        let basepoint = basepoint();
        let expected = point_mul(&basepoint, &a);
        assert!(point_equals(&expected, &basepoint_mul(&a)), 1);
    }

    #[test(fx = @std)]
    fun test_basepoint_double_mul(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);

        let expected = option::extract(&mut new_point_from_bytes(x"be5d615d8b8f996723cdc6e1895b8b6d312cc75d1ffb0259873b99396a38c05a"));

        let a = Scalar { data: A_SCALAR };
        let a_point = option::extract(&mut new_point_from_bytes(A_POINT));
        let b = Scalar { data: B_SCALAR };
        let actual = basepoint_double_mul(&a, &a_point, &b);

        assert!(point_equals(&expected, &actual), 1);

        let expected = double_scalar_mul(&a, &a_point, &b, &basepoint());
        assert!(point_equals(&expected, &actual), 1);
    }

    #[test]
    #[expected_failure]
    fun test_multi_scalar_mul_aborts_empty_scalars() {
        multi_scalar_mul(&vector[ basepoint() ], &vector[]);
    }

    #[test]
    #[expected_failure]
    fun test_multi_scalar_mul_aborts_empty_points() {
        multi_scalar_mul(&vector[ ], &vector[ Scalar { data: A_SCALAR } ]);
    }

    #[test]
    #[expected_failure]
    fun test_multi_scalar_mul_aborts_empty_all() {
        multi_scalar_mul(&vector[ ], &vector[ ]);
    }

    #[test]
    #[expected_failure]
    fun test_multi_scalar_mul_aborts_different_sizes() {
        multi_scalar_mul(&vector[ basepoint() ], &vector[ Scalar { data: A_SCALAR }, Scalar { data: B_SCALAR }  ]);
    }

    #[test]
    fun test_multi_scalar_mul_single() {
        // Test single exp
        let points = vector[
            basepoint(),
        ];

        let scalars = vector[
            Scalar { data: A_SCALAR },
        ];

        let result = multi_scalar_mul(&points, &scalars);
        let expected = std::option::extract(&mut new_point_from_bytes(A_TIMES_BASE_POINT));

        assert!(point_equals(&result, &expected), 1);
    }

    #[test]
    fun test_multi_scalar_mul_double() {
        // Test double exp
        let points = vector[
            basepoint(),
            basepoint(),
        ];

        let scalars = vector[
            Scalar { data: A_SCALAR },
            Scalar { data: B_SCALAR },
        ];

        let result = multi_scalar_mul(&points, &scalars);
        let expected = basepoint_double_mul(
            std::vector::borrow(&scalars, 0),
            &basepoint(),
            std::vector::borrow(&scalars, 1));

        assert!(point_equals(&result, &expected), 1);
    }

    #[test]
    fun test_multi_scalar_mul_many() {
        let scalars = vector[
            new_scalar_from_sha2_512(b"1"),
            new_scalar_from_sha2_512(b"2"),
            new_scalar_from_sha2_512(b"3"),
            new_scalar_from_sha2_512(b"4"),
            new_scalar_from_sha2_512(b"5"),
        ];

        let points = vector[
            new_point_from_sha2_512(b"1"),
            new_point_from_sha2_512(b"2"),
            new_point_from_sha2_512(b"3"),
            new_point_from_sha2_512(b"4"),
            new_point_from_sha2_512(b"5"),
        ];

        let expected = std::option::extract(&mut new_point_from_bytes(x"c4a98fbe6bd0f315a0c150858aec8508be397443093e955ef982e299c1318928"));
        let result = multi_scalar_mul(&points, &scalars);

        assert!(point_equals(&expected, &result), 1);
    }

    #[test]
    fun test_new_point_from_sha2_512() {
        let msg = b"To really appreciate architecture, you may even need to commit a murder";
        let expected = option::extract(&mut new_point_from_bytes(x"baaa91eb43e5e2f12ffc96347e14bc458fdb1772b2232b08977ee61ea9f84e31"));

        assert!(point_equals(&expected, &new_point_from_sha2_512(msg)), 1);
    }

    #[test]
    fun test_new_point_from_64_uniform_bytes() {
        let bytes_64 = x"baaa91eb43e5e2f12ffc96347e14bc458fdb1772b2232b08977ee61ea9f84e31e87feda199d72b83de4f5b2d45d34805c57019c6c59c42cb70ee3d19aa996f75";
        let expected = option::extract(&mut new_point_from_bytes(x"4a8e429f906478654232d7ae180ad60854754944ac67f38e20d8fa79e4b7d71e"));

        let point = option::extract(&mut new_point_from_64_uniform_bytes(bytes_64));
        assert!(point_equals(&expected, &point), 1);
    }

    #[test]
    fun test_scalar_basic_viability() {
        // Test conversion from u8
        let two = Scalar { data: TWO_SCALAR };
        assert!(scalar_equals(&new_scalar_from_u8(2u8), &two), 1);

        // Test conversion from u64
        assert!(scalar_equals(&new_scalar_from_u64(2u64), &two), 1);

        // Test conversion from u128
        assert!(scalar_equals(&new_scalar_from_u128(2u128), &two), 1);

        // Test (0 - 1) % order = order - 1
        assert!(scalar_equals(&scalar_sub(&scalar_zero(), &scalar_one()), &Scalar { data: L_MINUS_ONE }), 1);
    }

    #[test]
    /// Tests deserializing a Scalar from a sequence of canonical bytes
    fun test_scalar_from_canonical_bytes() {
        // Too few bytes
        assert!(std::option::is_none(&new_scalar_from_bytes(x"00")), 1);

        // 32 zero bytes are canonical
        assert!(std::option::is_some(&new_scalar_from_bytes(x"0000000000000000000000000000000000000000000000000000000000000000")), 1);

        // Non-canonical because unreduced
        assert!(std::option::is_none(&new_scalar_from_bytes(x"1010101010101010101010101010101010101010101010101010101010101010")), 1);

        // Canonical because \ell - 1
        assert!(std::option::is_some(&new_scalar_from_bytes(L_MINUS_ONE)), 1);

        // Non-canonical because \ell
        assert!(std::option::is_none(&new_scalar_from_bytes(ORDER_ELL)), 1);

        // Non-canonical because \ell+1
        assert!(std::option::is_none(&new_scalar_from_bytes(L_PLUS_ONE)), 1);

        // Non-canonical because \ell+2
        assert!(std::option::is_none(&new_scalar_from_bytes(L_PLUS_TWO)), 1);

        // Non-canonical because high bit is set
        let non_canonical_highbit = vector[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128];
        let non_canonical_highbit_hex = x"0000000000000000000000000000000000000000000000000000000000000080";
        assert!(non_canonical_highbit == non_canonical_highbit_hex, 1);
        assert!(std::option::is_none(&new_scalar_from_bytes(non_canonical_highbit)), 1);
    }

    #[test]
    fun test_scalar_zero() {
        // 0 == 0
        assert!(scalar_is_zero(&scalar_zero()), 1);
        assert!(scalar_is_zero(&new_scalar_from_u8(0u8)), 1);

        // 0 != 1
        assert!(scalar_is_zero(&scalar_one()) == false, 1);

        // Pick a random scalar by hashing from some "random" bytes
        let s = new_scalar_from_sha2_512(x"deadbeef");

        // Technically, there is a negligible probability (i.e., 1/2^\ell) that the hashed s is zero or one
        assert!(scalar_is_zero(&s) == false, 1);
        assert!(scalar_is_one(&s) == false, 1);

        // Multiply 0 with a random scalar and make sure you get zero
        assert!(scalar_is_zero(&scalar_mul(&scalar_zero(), &s)), 1);
        assert!(scalar_is_zero(&scalar_mul(&s, &scalar_zero())), 1);
    }

    #[test]
    fun test_scalar_one() {
        // 1 == 1
        assert!(scalar_is_one(&scalar_one()), 1);
        assert!(scalar_is_one(&new_scalar_from_u8(1u8)), 1);

        // 1 != 0
        assert!(scalar_is_one(&scalar_zero()) == false, 1);

        // Pick a random scalar by hashing from some "random" bytes
        let s = new_scalar_from_sha2_512(x"deadbeef");
        let inv = scalar_invert(&s);

        // Technically, there is a negligible probability (i.e., 1/2^\ell) that s was zero and the call above returned None
        assert!(std::option::is_some(&inv), 1);

        let inv = std::option::extract(&mut inv);

        // Multiply s with s^{-1} and make sure you get one
        assert!(scalar_is_one(&scalar_mul(&s, &inv)), 1);
        assert!(scalar_is_one(&scalar_mul(&inv, &s)), 1);
    }

    #[test]
    fun test_scalar_from_sha2_512() {
        // Test a specific message hashes correctly to the field
        let str: vector<u8> = vector[];
        std::vector::append(&mut str, b"To really appreciate architecture, you may even need to commit a murder.");
        std::vector::append(&mut str, b"While the programs used for The Manhattan Transcripts are of the most extreme");
        std::vector::append(&mut str, b"nature, they also parallel the most common formula plot: the archetype of");
        std::vector::append(&mut str, b"murder. Other phantasms were occasionally used to underline the fact that");
        std::vector::append(&mut str, b"perhaps all architecture, rather than being about functional standards, is");
        std::vector::append(&mut str, b"about love and death.");

        let s = new_scalar_from_sha2_512(str);

        let expected: vector<u8> = vector[
            21, 88, 208, 252, 63, 122, 210, 152,
            154, 38, 15, 23, 16, 167, 80, 150,
            192, 221, 77, 226, 62, 25, 224, 148,
            239, 48, 176, 10, 185, 69, 168, 11
        ];

        assert!(s.data == expected, 1)
    }

    #[test]
    fun test_scalar_invert() {
        // Cannot invert zero
        assert!(std::option::is_none(&scalar_invert(&scalar_zero())), 1);

        // One's inverse is one
        let one = scalar_invert(&scalar_one());
        assert!(std::option::is_some(&one), 1);

        let one = std::option::extract(&mut one);
        assert!(scalar_is_one(&one), 1);

        // Test a random point X's inverse is correct
        let x = Scalar { data: X_SCALAR };
        let xinv = scalar_invert(&x);
        assert!(std::option::is_some(&xinv), 1);

        let xinv = std::option::extract(&mut xinv);
        let xinv_expected = Scalar { data: X_INV_SCALAR };

        assert!(scalar_equals(&xinv, &xinv_expected), 1)
    }

    #[test]
    fun test_scalar_neg() {
        // -(-X) == X
        let x = Scalar { data: X_SCALAR };

        let x_neg = scalar_neg(&x);
        let x_neg_neg = scalar_neg(&x_neg);

        assert!(scalar_equals(&x, &x_neg_neg), 1);
    }

    #[test]
    fun test_scalar_neg_assign() {
        let x = Scalar { data: X_SCALAR };
        let x_copy = x;

        scalar_neg_assign(&mut x);
        assert!(!scalar_equals(&x, &x_copy), 1);
        scalar_neg_assign(&mut x);
        assert!(scalar_equals(&x, &x_copy), 1);

        assert!(scalar_equals(scalar_neg_assign(scalar_neg_assign(&mut x)), &x_copy), 1);
    }

    #[test]
    fun test_scalar_mul() {
        // X * 1 == X
        let x = Scalar { data: X_SCALAR };
        assert!(scalar_equals(&x, &scalar_mul(&x, &scalar_one())), 1);

        // Test multiplication of two random scalars
        let y = Scalar { data: Y_SCALAR };
        let x_times_y = Scalar { data: X_TIMES_Y_SCALAR };
        assert!(scalar_equals(&scalar_mul(&x, &y), &x_times_y), 1);

        // A * B
        assert!(scalar_equals(&scalar_mul(&Scalar { data: A_SCALAR }, &Scalar { data: B_SCALAR }), &Scalar { data: A_TIMES_B_SCALAR }), 1);
    }

    #[test]
    fun test_scalar_mul_assign() {
        let x = Scalar { data: X_SCALAR };
        let y = Scalar { data: Y_SCALAR };
        let x_times_y = Scalar { data: X_TIMES_Y_SCALAR };

        scalar_mul_assign(&mut x, &y);

        assert!(scalar_equals(&x, &x_times_y), 1);
    }

    #[test]
    fun test_scalar_add() {
        // Addition reduces: \ell-1 + 1 = \ell = 0
        let ell_minus_one = Scalar { data: L_MINUS_ONE };
        assert!(scalar_is_zero(&scalar_add(&ell_minus_one, &scalar_one())), 1);

        // 1 + 1 = 2
        let two = Scalar { data: TWO_SCALAR };
        assert!(scalar_equals(&scalar_add(&scalar_one(), &scalar_one()), &two), 1);

        // A + B
        assert!(scalar_equals(&scalar_add(&Scalar { data: A_SCALAR }, &Scalar { data: B_SCALAR }), &Scalar { data: A_PLUS_B_SCALAR }), 1);
    }

    #[test]
    fun test_scalar_sub() {
        // Subtraction reduces: 0 - 1 = \ell - 1
        let ell_minus_one = Scalar { data: L_MINUS_ONE };
        assert!(scalar_equals(&scalar_sub(&scalar_zero(), &scalar_one()), &ell_minus_one), 1);

        // 2 - 1 = 1
        let two = Scalar { data: TWO_SCALAR };
        assert!(scalar_is_one(&scalar_sub(&two, &scalar_one())), 1);

        // 1 - 2 = -1 = \ell - 1
        let ell_minus_one = Scalar { data: L_MINUS_ONE };
        assert!(scalar_equals(&scalar_sub(&scalar_one(), &two), &ell_minus_one), 1);
    }

    #[test]
    fun test_scalar_reduced_from_32_bytes() {
        // \ell + 2 = 0 + 2 = 2 (modulo \ell)
        let s = std::option::extract(&mut new_scalar_reduced_from_32_bytes(L_PLUS_TWO));
        let two = Scalar { data: TWO_SCALAR };
        assert!(scalar_equals(&s, &two), 1);

        // Reducing the all 1's bit vector yields $(2^256 - 1) \mod \ell$
        let biggest = std::option::extract(&mut new_scalar_reduced_from_32_bytes(NON_CANONICAL_ALL_ONES));
        assert!(scalar_equals(&biggest, &Scalar { data: REDUCED_2_256_MINUS_1_SCALAR }), 1);
    }

    #[test]
    fun test_scalar_from_64_uniform_bytes() {
        // Test X + 2^256 * X reduces correctly
        let x_plus_2_to_256_times_x: vector<u8> = vector[];

        std::vector::append(&mut x_plus_2_to_256_times_x, X_SCALAR);
        std::vector::append(&mut x_plus_2_to_256_times_x, X_SCALAR);

        let reduced = std::option::extract(&mut new_scalar_uniform_from_64_bytes(x_plus_2_to_256_times_x));
        let expected = Scalar { data: REDUCED_X_PLUS_2_TO_256_TIMES_X_SCALAR };
        assert!(scalar_equals(&reduced, &expected), 1)
    }

    #[test]
    fun test_scalar_to_bytes() {
        // zero is canonical
        assert!(scalar_is_canonical_internal(scalar_zero().data), 1);

        // ...but if we maul it and set the high bit to 1, it is non-canonical
        let non_can = scalar_zero();
        let last_byte = std::vector::borrow_mut(&mut non_can.data, 31);
        *last_byte = 128;
        assert!(!scalar_is_canonical_internal(non_can.data), 1);

        // This test makes sure scalar_to_bytes does not return a mutable reference to a scalar's bits
        let non_can = scalar_zero();
        let bytes = scalar_to_bytes(&scalar_zero());
        let last_byte = std::vector::borrow_mut(&mut bytes, 31);
        *last_byte = 128;
        assert!(scalar_is_canonical_internal(non_can.data), 1);
        assert!(scalar_equals(&non_can, &scalar_zero()), 1);
    }

    #[test]
    fun test_num_points_within_limit() {
        let limit = 10000;
        let i = 0;
        while (i < limit) {
            point_identity();
            i = i + 1;
        }
    }

    #[test]
    #[expected_failure(abort_code=0x090004, location=Self)]
    fun test_num_points_limit_exceeded() {
        let limit = 10001;
        let i = 0;
        while (i < limit) {
            point_identity();
            i = i + 1;
        }
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.spec.move
================================================
spec aptos_std::ristretto255 {
    spec point_equals {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec new_point_from_sha512_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec new_point_from_64_uniform_bytes_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec point_is_canonical_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_point_is_canonical_internal(bytes);
    }

    spec point_identity_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec point_decompress_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec point_compress_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec point_mul_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec basepoint_mul_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec basepoint_double_mul_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec double_scalar_mul_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec point_add_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec point_clone_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec point_sub_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec point_neg_internal {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec multi_scalar_mul_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_multi_scalar_mul_internal<P, S>(points, scalars);
    }

    spec scalar_is_canonical_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_is_canonical_internal(s);
    }

    spec scalar_from_u64_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_from_u64_internal(num);
    }

    spec scalar_from_u128_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_from_u128_internal(num);
    }

    spec scalar_reduced_from_32_bytes_internal {
        pragma opaque;
        ensures result == spec_scalar_reduced_from_32_bytes_internal(bytes);
    }

    spec scalar_uniform_from_64_bytes_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_uniform_from_64_bytes_internal(bytes);
    }

    spec scalar_invert_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_invert_internal(bytes);
    }

    spec double_scalar_mul {
        // TODO: temporary mockup.
        pragma opaque;
    }

    spec multi_scalar_mul {
        aborts_if len(points) == 0;
        aborts_if len(scalars) == 0;
        aborts_if len(points) != len(scalars);
        ensures result.handle == spec_multi_scalar_mul_internal(points, scalars);
    }

    spec new_scalar_from_bytes {
        aborts_if false;
        ensures spec_scalar_is_canonical_internal(bytes) ==> (std::option::spec_is_some(result)
            && std::option::spec_borrow(result).data == bytes);
        ensures !spec_scalar_is_canonical_internal(bytes) ==> std::option::spec_is_none(result);
    }

    spec scalar_from_sha512_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_from_sha512_internal(sha2_512_input);
    }

    spec new_scalar_from_sha2_512 {
        aborts_if false;
        ensures result.data == spec_scalar_from_sha512_internal(sha2_512_input);
    }

    spec new_scalar_from_u8 {
        aborts_if false;
        ensures result.data[0] == byte;
        ensures forall i in 1..len(result.data): result.data[i] == 0;
    }

    spec new_scalar_from_u32 {
        aborts_if false;
        ensures result.data == spec_scalar_from_u64_internal(four_bytes);
    }

    spec new_scalar_from_u64 {
        aborts_if false;
        ensures result.data == spec_scalar_from_u64_internal(eight_bytes);
    }

    spec new_scalar_from_u128 {
        aborts_if false;
        ensures result.data == spec_scalar_from_u128_internal(sixteen_bytes);
    }

    spec new_scalar_reduced_from_32_bytes {
        ensures len(bytes) != 32 ==> std::option::spec_is_none(result);
        ensures len(bytes) == 32 ==> std::option::spec_borrow(result).data == spec_scalar_reduced_from_32_bytes_internal(bytes);
    }

    spec new_scalar_uniform_from_64_bytes {
        ensures len(bytes) != 64 ==> std::option::spec_is_none(result);
        ensures len(bytes) == 64 ==> std::option::spec_borrow(result).data == spec_scalar_uniform_from_64_bytes_internal(bytes);
    }

    spec scalar_zero {
        ensures spec_scalar_is_zero(result);
    }

    spec scalar_is_zero {
        ensures result == spec_scalar_is_zero(s);
    }

    spec scalar_one {
        ensures spec_scalar_is_one(result);
    }

    spec scalar_is_one {
        ensures result == spec_scalar_is_one(s);
    }

    spec scalar_equals {
        aborts_if false;
        ensures result == (lhs.data == rhs.data);
    }

    spec scalar_invert {
        aborts_if false;
        ensures spec_scalar_is_zero(s) ==> std::option::spec_is_none(result);
        ensures !spec_scalar_is_zero(s) ==> (std::option::spec_is_some(result) && std::option::spec_borrow(result).data == spec_scalar_invert_internal(s.data));
    }

    spec scalar_mul_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_mul_internal(a_bytes, b_bytes);
    }

    spec scalar_add_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_add_internal(a_bytes, b_bytes);
    }

    spec scalar_sub {
        aborts_if false;
        ensures result.data == spec_scalar_sub_internal(a.data, b.data);
    }

    spec scalar_sub_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_sub_internal(a_bytes, b_bytes);
    }

    spec scalar_neg {
        pragma opaque;
        aborts_if false;
        ensures result.data == spec_scalar_neg_internal(a.data);
    }

    spec scalar_neg_internal {
        pragma opaque;
        aborts_if [abstract] false;
        ensures result == spec_scalar_neg_internal(a_bytes);
    }

    spec scalar_neg_assign {
        aborts_if false;
        ensures a.data == spec_scalar_neg_internal(old(a).data);
    }

    spec scalar_add {
        aborts_if false;
        ensures result.data == spec_scalar_add_internal(a.data, b.data);
    }

    spec scalar_add_assign {
        aborts_if false;
        ensures a.data == spec_scalar_add_internal(old(a).data, b.data);
    }

    spec scalar_mul {
        aborts_if false;
        ensures result.data == spec_scalar_mul_internal(a.data, b.data);
    }

    spec scalar_mul_assign {
        aborts_if false;
        ensures a.data == spec_scalar_mul_internal(old(a).data, b.data);
    }

    spec scalar_sub_assign {
        aborts_if false;
        ensures a.data == spec_scalar_sub_internal(old(a).data, b.data);
    }

    spec scalar_to_bytes {
        aborts_if false;
        ensures result == s.data;
    }

    /// # Helper functions

    spec fun spec_scalar_is_zero(s: Scalar): bool {
        s.data == x"0000000000000000000000000000000000000000000000000000000000000000"
    }

    spec fun spec_scalar_is_one(s: Scalar): bool {
        s.data == x"0100000000000000000000000000000000000000000000000000000000000000"
    }

    spec fun spec_point_is_canonical_internal(bytes: vector<u8>): bool;

    spec fun spec_double_scalar_mul_internal(point1: u64, point2: u64, scalar1: vector<u8>, scalar2: vector<u8>): u64;

    spec fun spec_multi_scalar_mul_internal<P, S>(points: vector<P>, scalars: vector<S>): u64;

    spec fun spec_scalar_is_canonical_internal(s: vector<u8>): bool;

    spec fun spec_scalar_from_u64_internal(num: u64): vector<u8>;

    spec fun spec_scalar_from_u128_internal(num: u128): vector<u8>;

    spec fun spec_scalar_reduced_from_32_bytes_internal(bytes: vector<u8>): vector<u8>;

    spec fun spec_scalar_uniform_from_64_bytes_internal(bytes: vector<u8>): vector<u8>;

    spec fun spec_scalar_invert_internal(bytes: vector<u8>): vector<u8>;

    spec fun spec_scalar_from_sha512_internal(sha2_512_input: vector<u8>): vector<u8>;

    spec fun spec_scalar_mul_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    spec fun spec_scalar_add_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    spec fun spec_scalar_sub_internal(a_bytes: vector<u8>, b_bytes: vector<u8>): vector<u8>;

    spec fun spec_scalar_neg_internal(a_bytes: vector<u8>): vector<u8>;

}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_bulletproofs.move
================================================
/// This module implements a Bulletproof range proof verifier on the Ristretto255 curve.
///
/// A Bulletproof-based zero-knowledge range proof is a proof that a Pedersen commitment
/// $c = v G + r H$ commits to an $n$-bit value $v$ (i.e., $v \in [0, 2^n)$). Currently, this module only supports
/// $n \in \{8, 16, 32, 64\}$ for the number of bits.
module aptos_std::ristretto255_bulletproofs {
    use std::error;
    use std::features;
    use aptos_std::ristretto255_pedersen as pedersen;
    use aptos_std::ristretto255::{Self, RistrettoPoint};

    //
    // Constants
    //

    /// The maximum range supported by the Bulletproofs library is $[0, 2^{64})$.
    const MAX_RANGE_BITS : u64 = 64;

    //
    // Error codes
    //

    /// There was an error deserializing the range proof.
    const E_DESERIALIZE_RANGE_PROOF: u64 = 1;

    /// The committed value given to the prover is too large.
    const E_VALUE_OUTSIDE_RANGE: u64 = 2;

    /// The range proof system only supports proving ranges of type $[0, 2^b)$ where $b \in \{8, 16, 32, 64\}$.
    const E_RANGE_NOT_SUPPORTED: u64 = 3;

    /// The native functions have not been rolled out yet.
    const E_NATIVE_FUN_NOT_AVAILABLE: u64 = 4;

    //
    // Structs
    //

    /// Represents a zero-knowledge range proof that a value committed inside a Pedersen commitment lies in
    /// `[0, 2^{MAX_RANGE_BITS})`.
    struct RangeProof has copy, drop, store {
        bytes: vector<u8>
    }

    //
    // Public functions
    //

    /// Returns the maximum # of bits that the range proof system can verify proofs for.
    public fun get_max_range_bits(): u64 {
        MAX_RANGE_BITS
    }

    /// Deserializes a range proof from a sequence of bytes. The serialization format is the same as the format in
    /// the zkcrypto's `bulletproofs` library (https://docs.rs/bulletproofs/4.0.0/bulletproofs/struct.RangeProof.html#method.from_bytes).
    public fun range_proof_from_bytes(bytes: vector<u8>): RangeProof {
        RangeProof {
            bytes
        }
    }

    /// Returns the byte-representation of a range proof.
    public fun range_proof_to_bytes(proof: &RangeProof): vector<u8> {
        proof.bytes
    }

    /// Verifies a zero-knowledge range proof that the value `v` committed in `com` (under the default Bulletproofs
    /// commitment key; see `pedersen::new_commitment_for_bulletproof`) satisfies $v \in [0, 2^b)$. Only works
    /// for $b \in \{8, 16, 32, 64\}$. Additionally, checks that the prover used `dst` as the domain-separation
    /// tag (DST).
    ///
    /// WARNING: The DST check is VERY important for security as it prevents proofs computed for one application
    /// (a.k.a., a _domain_) with `dst_1` from verifying in a different application with `dst_2 != dst_1`.
    public fun verify_range_proof_pedersen(com: &pedersen::Commitment, proof: &RangeProof, num_bits: u64, dst: vector<u8>): bool {
        assert!(features::bulletproofs_enabled(), error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE));

        verify_range_proof_internal(
            ristretto255::point_to_bytes(&pedersen::commitment_as_compressed_point(com)),
            &ristretto255::basepoint(), &ristretto255::hash_to_point_base(),
            proof.bytes,
            num_bits,
            dst
        )
    }

    /// Verifies a zero-knowledge range proof that the value `v` committed in `com` (as v * val_base + r * rand_base,
    /// for some randomness `r`) satisfies `v` in `[0, 2^num_bits)`. Only works for `num_bits` in `{8, 16, 32, 64}`.
    public fun verify_range_proof(
        com: &RistrettoPoint,
        val_base: &RistrettoPoint, rand_base: &RistrettoPoint,
        proof: &RangeProof, num_bits: u64, dst: vector<u8>): bool
    {
        assert!(features::bulletproofs_enabled(), error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE));

        verify_range_proof_internal(
            ristretto255::point_to_bytes(&ristretto255::point_compress(com)),
            val_base, rand_base,
            proof.bytes, num_bits, dst
        )
    }

    #[test_only]
    /// Computes a range proof for the Pedersen commitment to 'val' with randomness 'r', under the default Bulletproofs
    /// commitment key; see `pedersen::new_commitment_for_bulletproof`. Returns the said commitment too.
    ///  Only works for `num_bits` in `{8, 16, 32, 64}`.
    public fun prove_range_pedersen(val: &Scalar, r: &Scalar, num_bits: u64, dst: vector<u8>): (RangeProof, pedersen::Commitment) {
        let (bytes, compressed_comm) = prove_range_internal(scalar_to_bytes(val), scalar_to_bytes(r), num_bits, dst, &ristretto255::basepoint(), &ristretto255::hash_to_point_base());
        let point = ristretto255::new_compressed_point_from_bytes(compressed_comm);
        let point = &std::option::extract(&mut point);

        (
            RangeProof { bytes },
            pedersen::commitment_from_compressed(point)
        )
    }

    //
    // Native functions
    //

    /// Aborts with `error::invalid_argument(E_DESERIALIZE_RANGE_PROOF)` if `proof` is not a valid serialization of a
    /// range proof.
    /// Aborts with `error::invalid_argument(E_RANGE_NOT_SUPPORTED)` if an unsupported `num_bits` is provided.
    native fun verify_range_proof_internal(
        com: vector<u8>,
        val_base: &RistrettoPoint,
        rand_base: &RistrettoPoint,
        proof: vector<u8>,
        num_bits: u64,
        dst: vector<u8>): bool;

    #[test_only]
    /// Returns a tuple consisting of (1) a range proof for 'val' committed with randomness 'r' under the default Bulletproofs
    /// commitment key and (2) the commitment itself.
    ///
    /// Aborts with `error::invalid_argument(E_RANGE_NOT_SUPPORTED)` if an unsupported `num_bits` is provided.
    /// Aborts with `error::invalid_argument(E_VALUE_OUTSIDE_RANGE)` if an `val_base` is not `num_bits` wide.
    native fun prove_range_internal(
        val: vector<u8>,
        r: vector<u8>,
        num_bits: u64,
        dst: vector<u8>,
        val_base: &RistrettoPoint,
        rand_base: &RistrettoPoint): (vector<u8>, vector<u8>);

    //
    // Testing
    //

    #[test_only]
    use aptos_std::ristretto255::{Scalar, scalar_to_bytes, point_equals};

    #[test_only]
    const A_DST: vector<u8> = b"AptosBulletproofs";
    #[test_only]
    const A_VALUE: vector<u8> = x"870c2fa1b2e9ac45000000000000000000000000000000000000000000000000";  // i.e., 5020644638028926087u64
    #[test_only]
    const A_BLINDER: vector<u8> = x"e7c7b42b75503bfc7b1932783786d227ebf88f79da752b68f6b865a9c179640c";
    // Pedersen commitment to A_VALUE with randomness A_BLINDER
    #[test_only]
    const A_COMM: vector<u8> = x"0a665260a4e42e575882c2cdcb3d0febd6cf168834f6de1e9e61e7b2e53dbf14";
    // Range proof for A_COMM using domain-separation tag in A_DST, and MAX_RANGE_BITS
    #[test_only]
    const A_RANGE_PROOF_PEDERSEN: vector<u8> = x"d8d422d3fb9511d1942b78e3ec1a8c82fe1c01a0a690c55a4761e7e825633a753cca816667d2cbb716fe04a9c199cad748c2d4e59de4ed04fedf5f04f4341a74ae75b63c1997fd65d5fb3a8c03ad8771abe2c0a4f65d19496c11d948d6809503eac4d996f2c6be4e64ebe2df31102c96f106695bdf489dc9290c93b4d4b5411fb6298d0c33afa57e2e1948c38ef567268a661e7b1c099272e29591e717930a06a2c6e0e2d56aedea3078fd59334634f1a4543069865409eba074278f191039083102a9a0621791a9be09212a847e22061e083d7a712b05bca7274b25e4cb1201c679c4957f0842d7661fa1d3f5456a651e89112628b456026f8ad3a7abeaba3fec8031ec8b0392c0aa6c96205f7b21b0c2d6b5d064bd5bd1a1d91c41625d910688fa0dca35ec0f0e31a45792f8d6a330be970a22e1e0773111a083de893c89419ee7de97295978de90bcdf873a2826746809e64f9143417dbed09fa1c124e673febfed65c137cc45fabda963c96b64645802d1440cba5e58717e539f55f3321ab0c0f60410fba70070c5db500fee874265a343a2a59773fd150bcae09321a5166062e176e2e76bef0e3dd1a9250bcb7f4c971c10f0b24eb2a94e009b72c1fc21ee4267881e27b4edba8bed627ddf37e0c53cd425bc279d0c50d154d136503e54882e9541820d6394bd52ca2b438fd8c517f186fec0649c4846c4e43ce845d80e503dee157ce55392188039a7efc78719107ab989db8d9363b9dfc1946f01a84dbca5e742ed5f30b07ac61cf17ce2cf2c6a49d799ed3968a63a3ccb90d9a0e50960d959f17f202dd5cf0f2c375a8a702e063d339e48c0227e7cf710157f63f13136d8c3076c672ea2c1028fc1825366a145a4311de6c2cc46d3144ae3d2bc5808819b9817be3fce1664ecb60f74733e75e97ca8e567d1b81bdd4c56c7a340ba00";

    #[test(fx = @std)]
    #[expected_failure(abort_code = 0x010003, location = Self)]
    fun test_unsupported_ranges(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);

        let comm = ristretto255::new_point_from_bytes(A_COMM);
        let comm = std::option::extract(&mut comm);
        let comm = pedersen::commitment_from_point(comm);

        assert!(verify_range_proof_pedersen(
            &comm,
            &range_proof_from_bytes(A_RANGE_PROOF_PEDERSEN), 10, A_DST), 1);
    }

    #[test(fx = @std)]
    fun test_prover(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);

        let v = ristretto255::new_scalar_from_u64(59);
        let r = ristretto255::new_scalar_from_bytes(A_BLINDER);
        let r = std::option::extract(&mut r);
        let num_bits = 8;

        let (proof, comm) = prove_range_pedersen(&v, &r, num_bits, A_DST);

        assert!(verify_range_proof_pedersen(&comm, &proof, 64, A_DST) == false, 1);
        assert!(verify_range_proof_pedersen(&comm, &proof, 32, A_DST) == false, 1);
        assert!(verify_range_proof_pedersen(&comm, &proof, 16, A_DST) == false, 1);
        assert!(verify_range_proof_pedersen(&comm, &proof, num_bits, A_DST), 1);
    }

    #[test(fx = @std)]
    #[expected_failure(abort_code = 0x010001, location = Self)]
    fun test_empty_range_proof(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);

        let proof = &range_proof_from_bytes(vector[ ]);
        let num_bits = 64;
        let com = pedersen::new_commitment_for_bulletproof(
            &ristretto255::scalar_one(),
            &ristretto255::new_scalar_from_sha2_512(b"hello random world")
        );

        // This will fail with error::invalid_argument(E_DESERIALIZE_RANGE_PROOF)
        verify_range_proof_pedersen(&com, proof, num_bits, A_DST);
    }

    #[test(fx = @std)]
    fun test_valid_range_proof_verifies_against_comm(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);

        let value = ristretto255::new_scalar_from_bytes(A_VALUE);
        let value = std::option::extract(&mut value);

        let blinder = ristretto255::new_scalar_from_bytes(A_BLINDER);
        let blinder = std::option::extract(&mut blinder);

        let comm = pedersen::new_commitment_for_bulletproof(&value, &blinder);

        let expected_comm = std::option::extract(&mut ristretto255::new_point_from_bytes(A_COMM));
        assert!(point_equals(pedersen::commitment_as_point(&comm), &expected_comm), 1);

        assert!(verify_range_proof_pedersen(
            &comm,
            &range_proof_from_bytes(A_RANGE_PROOF_PEDERSEN), MAX_RANGE_BITS, A_DST), 1);
    }

    #[test(fx = @std)]
    fun test_invalid_range_proof_fails_verification(fx: signer) {
        features::change_feature_flags_for_testing(&fx, vector[ features::get_bulletproofs_feature() ], vector[]);

        let comm = ristretto255::new_point_from_bytes(A_COMM);
        let comm = std::option::extract(&mut comm);
        let comm = pedersen::commitment_from_point(comm);

        // Take a valid proof...
        let range_proof_invalid = A_RANGE_PROOF_PEDERSEN;

        // ...and modify a byte in the middle of the proof
        let pos = std::vector::length(&range_proof_invalid) / 2;
        let byte = std::vector::borrow_mut(&mut range_proof_invalid, pos);
        *byte = *byte + 1;

        assert!(verify_range_proof_pedersen(
            &comm,
            &range_proof_from_bytes(range_proof_invalid), MAX_RANGE_BITS, A_DST) == false, 1);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_bulletproofs.spec.move
================================================
spec aptos_std::ristretto255_bulletproofs {
    spec verify_range_proof_internal { // TODO: temporary mockup.
        pragma opaque;
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move
================================================
/// This module implements an ElGamal encryption API, over the Ristretto255 curve, that can be used with the
/// Bulletproofs module.
///
/// An ElGamal *ciphertext* is an encryption of a value `v` under a basepoint `G` and public key `Y = sk * G`, where `sk`
/// is the corresponding secret key, is `(v * G + r * Y, r * G)`, for a random scalar `r`.
///
/// Note that we place the value `v` "in the exponent" of `G` so that ciphertexts are additively homomorphic: i.e., so
/// that `Enc_Y(v, r) + Enc_Y(v', r') = Enc_Y(v + v', r + r')` where `v, v'` are plaintext messages, `Y` is a public key and `r, r'`
/// are the randomness of the ciphertexts.

module aptos_std::ristretto255_elgamal {
    use aptos_std::ristretto255::{Self, RistrettoPoint, Scalar, CompressedRistretto, point_compress};
    use std::option::Option;
    use std::vector;

    //
    // Structs
    //

    /// An ElGamal ciphertext.
    struct Ciphertext has drop {
        left: RistrettoPoint,   // v * G + r * Y
        right: RistrettoPoint,  // r * G
    }

    /// A compressed ElGamal ciphertext.
    struct CompressedCiphertext has store, copy, drop {
        left: CompressedRistretto,
        right: CompressedRistretto,
    }

    /// An ElGamal public key.
    struct CompressedPubkey has store, copy, drop {
        point: CompressedRistretto,
    }

    //
    // Public functions
    //

    /// Creates a new public key from a serialized Ristretto255 point.
    public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
        let point = ristretto255::new_compressed_point_from_bytes(bytes);
        if (std::option::is_some(&mut point)) {
            let pk = CompressedPubkey {
                point: std::option::extract(&mut point)
            };
            std::option::some(pk)
        } else {
            std::option::none<CompressedPubkey>()
        }
    }

    /// Given an ElGamal public key `pubkey`, returns the byte representation of that public key.
    public fun pubkey_to_bytes(pubkey: &CompressedPubkey): vector<u8> {
        ristretto255::compressed_point_to_bytes(pubkey.point)
    }

    /// Given a public key `pubkey`, returns the underlying `RistrettoPoint` representing that key.
    public fun pubkey_to_point(pubkey: &CompressedPubkey): RistrettoPoint {
        ristretto255::point_decompress(&pubkey.point)
    }

    /// Given a public key, returns the underlying `CompressedRistretto` point representing that key.
    public fun pubkey_to_compressed_point(pubkey: &CompressedPubkey): CompressedRistretto {
        pubkey.point
    }

    /// Creates a new ciphertext from two serialized Ristretto255 points: the first 32 bytes store `r * G` while the
    /// next 32 bytes store `v * G + r * Y`, where `Y` is the public key.
    public fun new_ciphertext_from_bytes(bytes: vector<u8>): Option<Ciphertext> {
        if(vector::length(&bytes) != 64) {
            return std::option::none<Ciphertext>()
        };

        let bytes_right = vector::trim(&mut bytes, 32);

        let left_point = ristretto255::new_point_from_bytes(bytes);
        let right_point = ristretto255::new_point_from_bytes(bytes_right);

        if (std::option::is_some<RistrettoPoint>(&mut left_point) && std::option::is_some<RistrettoPoint>(&mut right_point)) {
            std::option::some<Ciphertext>(Ciphertext {
                left: std::option::extract<RistrettoPoint>(&mut left_point),
                right: std::option::extract<RistrettoPoint>(&mut right_point)
            })
        } else {
            std::option::none<Ciphertext>()
        }
    }

    /// Creates a new ciphertext `(val * G + 0 * Y, 0 * G) = (val * G, 0 * G)` where `G` is the Ristretto255 basepoint
    /// and the randomness is set to zero.
    public fun new_ciphertext_no_randomness(val: &Scalar): Ciphertext {
        Ciphertext {
            left: ristretto255::basepoint_mul(val),
            right: ristretto255::point_identity(),
        }
    }

    /// Moves a pair of Ristretto points into an ElGamal ciphertext.
    public fun ciphertext_from_points(left: RistrettoPoint, right: RistrettoPoint): Ciphertext {
        Ciphertext {
            left,
            right,
        }
    }

    /// Moves a pair of `CompressedRistretto` points into an ElGamal ciphertext.
    public fun ciphertext_from_compressed_points(left: CompressedRistretto, right: CompressedRistretto): CompressedCiphertext {
        CompressedCiphertext {
            left,
            right,
        }
    }

    /// Given a ciphertext `ct`, serializes that ciphertext into bytes.
    public fun ciphertext_to_bytes(ct: &Ciphertext): vector<u8> {
        let bytes_left = ristretto255::point_to_bytes(&ristretto255::point_compress(&ct.left));
        let bytes_right = ristretto255::point_to_bytes(&ristretto255::point_compress(&ct.right));
        let bytes = vector::empty<u8>();
        vector::append<u8>(&mut bytes, bytes_left);
        vector::append<u8>(&mut bytes, bytes_right);
        bytes
    }

    /// Moves the ciphertext into a pair of `RistrettoPoint`'s.
    public fun ciphertext_into_points(c: Ciphertext): (RistrettoPoint, RistrettoPoint) {
        let Ciphertext { left, right } = c;
        (left, right)
    }

    /// Returns the pair of `RistrettoPoint`'s representing the ciphertext.
    public fun ciphertext_as_points(c: &Ciphertext): (&RistrettoPoint, &RistrettoPoint) {
        (&c.left, &c.right)
    }

    /// Creates a new compressed ciphertext from a decompressed ciphertext.
    public fun compress_ciphertext(ct: &Ciphertext): CompressedCiphertext {
        CompressedCiphertext {
            left: point_compress(&ct.left),
            right: point_compress(&ct.right),
        }
    }

    /// Creates a new decompressed ciphertext from a compressed ciphertext.
    public fun decompress_ciphertext(ct: &CompressedCiphertext): Ciphertext {
        Ciphertext {
            left: ristretto255::point_decompress(&ct.left),
            right: ristretto255::point_decompress(&ct.right),
        }
    }

    /// Homomorphically combines two ciphertexts `lhs` and `rhs` as `lhs + rhs`.
    /// Useful for re-randomizing the ciphertext or updating the committed value.
    public fun ciphertext_add(lhs: &Ciphertext, rhs: &Ciphertext): Ciphertext {
        Ciphertext {
            left: ristretto255::point_add(&lhs.left, &rhs.left),
            right: ristretto255::point_add(&lhs.right, &rhs.right),
        }
    }

    /// Like `ciphertext_add` but assigns `lhs = lhs + rhs`.
    public fun ciphertext_add_assign(lhs: &mut Ciphertext, rhs: &Ciphertext) {
        ristretto255::point_add_assign(&mut lhs.left, &rhs.left);
        ristretto255::point_add_assign(&mut lhs.right, &rhs.right);
    }

    /// Homomorphically combines two ciphertexts `lhs` and `rhs` as `lhs - rhs`.
    /// Useful for re-randomizing the ciphertext or updating the committed value.
    public fun ciphertext_sub(lhs: &Ciphertext, rhs: &Ciphertext): Ciphertext {
        Ciphertext {
            left: ristretto255::point_sub(&lhs.left, &rhs.left),
            right: ristretto255::point_sub(&lhs.right, &rhs.right),
        }
    }

    /// Like `ciphertext_add` but assigns `lhs = lhs - rhs`.
    public fun ciphertext_sub_assign(lhs: &mut Ciphertext, rhs: &Ciphertext) {
        ristretto255::point_sub_assign(&mut lhs.left, &rhs.left);
        ristretto255::point_sub_assign(&mut lhs.right, &rhs.right);
    }

    /// Creates a copy of this ciphertext.
    public fun ciphertext_clone(c: &Ciphertext): Ciphertext {
        Ciphertext {
            left: ristretto255::point_clone(&c.left),
            right: ristretto255::point_clone(&c.right),
        }
    }

    /// Returns true if the two ciphertexts are identical: i.e., same value and same randomness.
    public fun ciphertext_equals(lhs: &Ciphertext, rhs: &Ciphertext): bool {
        ristretto255::point_equals(&lhs.left, &rhs.left) &&
        ristretto255::point_equals(&lhs.right, &rhs.right)
    }

    /// Returns the `RistrettoPoint` in the ciphertext which contains the encrypted value in the exponent.
    public fun get_value_component(ct: &Ciphertext): &RistrettoPoint {
        &ct.left
    }

    //
    // Test-only functions
    //

    #[test_only]
    /// Given an ElGamal secret key `sk`, returns the corresponding ElGamal public key as `sk * G`.
    public fun pubkey_from_secret_key(sk: &Scalar): CompressedPubkey {
        let point = ristretto255::basepoint_mul(sk);
        CompressedPubkey {
            point: point_compress(&point)
        }
    }

    #[test_only]
    /// Returns a ciphertext (v * point + r * pubkey, r * point) where `point` is *any* Ristretto255 point,
    /// `pubkey` is the public key and `r` is the randomness.
    public fun new_ciphertext(v: &Scalar, point: &RistrettoPoint, r: &Scalar, pubkey: &CompressedPubkey): Ciphertext {
        Ciphertext {
            left: ristretto255::double_scalar_mul(v, point, r, &pubkey_to_point(pubkey)),
            right: ristretto255::point_mul(point, r),
        }
    }

    #[test_only]
    /// Returns a ciphertext (v * basepoint + r * pubkey, r * basepoint) where `basepoint` is the Ristretto255 basepoint
    /// `pubkey` is the public key and `r` is the randomness.
    public fun new_ciphertext_with_basepoint(v: &Scalar, r: &Scalar, pubkey: &CompressedPubkey): Ciphertext {
        Ciphertext {
            left: ristretto255::basepoint_double_mul(r, &pubkey_to_point(pubkey), v),
            right: ristretto255::basepoint_mul(r),
        }
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.spec.move
================================================
spec aptos_std::ristretto255_elgamal {
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_pedersen.move
================================================
/// This module implements a Pedersen commitment API, over the Ristretto255 curve, that can be used with the
/// Bulletproofs module.
///
/// A Pedersen commitment to a value `v` under _commitment key_ `(g, h)` is `v * g + r * h`, for a random scalar `r`.

module aptos_std::ristretto255_pedersen {
    use aptos_std::ristretto255::{Self, RistrettoPoint, Scalar, CompressedRistretto, point_compress};
    use std::option::Option;

    //
    // Constants
    //

    /// The default Pedersen randomness base `h` used in our underlying Bulletproofs library.
    /// This is obtained by hashing the compressed Ristretto255 basepoint using SHA3-512 (not SHA2-512).
    const BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE : vector<u8> = x"8c9240b456a9e6dc65c377a1048d745f94a08cdb7f44cbcd7b46f34048871134";

    //
    // Structs
    //

    /// A Pedersen commitment to some value with some randomness.
    struct Commitment has drop {
        point: RistrettoPoint,
    }

    //
    // Public functions
    //

    /// Creates a new public key from a serialized Ristretto255 point.
    public fun new_commitment_from_bytes(bytes: vector<u8>): Option<Commitment> {
        let point = ristretto255::new_point_from_bytes(bytes);
        if (std::option::is_some(&mut point)) {
            let comm = Commitment {
                point: std::option::extract(&mut point)
            };
            std::option::some(comm)
        } else {
            std::option::none<Commitment>()
        }
    }

    /// Returns a commitment as a serialized byte array
    public fun commitment_to_bytes(comm: &Commitment): vector<u8> {
        ristretto255::point_to_bytes(&ristretto255::point_compress(&comm.point))
    }

    /// Moves a Ristretto point into a Pedersen commitment.
    public fun commitment_from_point(point: RistrettoPoint): Commitment {
        Commitment {
            point
        }
    }

    /// Deserializes a commitment from a compressed Ristretto point.
    public fun commitment_from_compressed(point: &CompressedRistretto): Commitment {
        Commitment {
            point: ristretto255::point_decompress(point)
        }
    }

    /// Returns a commitment `v * val_base + r * rand_base` where `(val_base, rand_base)` is the commitment key.
    public fun new_commitment(v: &Scalar, val_base: &RistrettoPoint, r: &Scalar, rand_base: &RistrettoPoint): Commitment {
        Commitment {
            point: ristretto255::double_scalar_mul(v, val_base, r, rand_base)
        }
    }

    /// Returns a commitment `v * G + r * rand_base` where `G` is the Ristretto255 basepoint.
    public fun new_commitment_with_basepoint(v: &Scalar, r: &Scalar, rand_base: &RistrettoPoint): Commitment {
        Commitment {
            point: ristretto255::basepoint_double_mul(r, rand_base, v)
        }
    }

    /// Returns a commitment `v * G + r * H` where `G` is the Ristretto255 basepoint and `H` is the default randomness
    /// base used in the Bulletproofs library (i.e., `BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE`).
    public fun new_commitment_for_bulletproof(v: &Scalar, r: &Scalar): Commitment {
        let rand_base = ristretto255::new_point_from_bytes(BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE);
        let rand_base = std::option::extract(&mut rand_base);

        Commitment {
            point: ristretto255::basepoint_double_mul(r, &rand_base, v)
        }
    }

    /// Homomorphically combines two commitments `lhs` and `rhs` as `lhs + rhs`.
    /// Useful for re-randomizing the commitment or updating the committed value.
    public fun commitment_add(lhs: &Commitment, rhs: &Commitment): Commitment {
        Commitment {
            point: ristretto255::point_add(&lhs.point, &rhs.point)
        }
    }

    /// Like `commitment_add` but assigns `lhs = lhs + rhs`.
    public fun commitment_add_assign(lhs: &mut Commitment, rhs: &Commitment) {
        ristretto255::point_add_assign(&mut lhs.point, &rhs.point);
    }

    /// Homomorphically combines two commitments `lhs` and `rhs` as `lhs - rhs`.
    /// Useful for re-randomizing the commitment or updating the committed value.
    public fun commitment_sub(lhs: &Commitment, rhs: &Commitment): Commitment {
        Commitment {
            point: ristretto255::point_sub(&lhs.point, &rhs.point)
        }
    }

    /// Like `commitment_add` but assigns `lhs = lhs - rhs`.
    public fun commitment_sub_assign(lhs: &mut Commitment, rhs: &Commitment) {
        ristretto255::point_sub_assign(&mut lhs.point, &rhs.point);
    }

    /// Creates a copy of this commitment.
    public fun commitment_clone(c: &Commitment): Commitment {
        Commitment {
            point: ristretto255::point_clone(&c.point)
        }
    }

    /// Returns true if the two commitments are identical: i.e., same value and same randomness.
    public fun commitment_equals(lhs: &Commitment, rhs: &Commitment): bool {
        ristretto255::point_equals(&lhs.point, &rhs.point)
    }

    /// Returns the underlying elliptic curve point representing the commitment as an in-memory `RistrettoPoint`.
    public fun commitment_as_point(c: &Commitment): &RistrettoPoint {
        &c.point
    }

    /// Returns the Pedersen commitment as a `CompressedRistretto` point.
    public fun commitment_as_compressed_point(c: &Commitment): CompressedRistretto {
        point_compress(&c.point)
    }

    /// Moves the Commitment into a CompressedRistretto point.
    public fun commitment_into_point(c: Commitment): RistrettoPoint {
        let Commitment { point } = c;
        point
    }

    /// Moves the Commitment into a `CompressedRistretto` point.
    public fun commitment_into_compressed_point(c: Commitment): CompressedRistretto {
        point_compress(&c.point)
    }

    /// Returns the randomness base compatible with the Bulletproofs module.
    ///
    /// Recal that a Bulletproof range proof attests, in zero-knowledge, that a value `v` inside a Pedersen commitment
    /// `v * g + r * h` is sufficiently "small" (e.g., is 32-bits wide). Here, `h` is referred to as the
    /// "randomness base" of the commitment scheme.
    ///
    /// Bulletproof has a default choice for `g` and `h` and this function returns the default `h` as used in the
    /// Bulletproofs Move module.
    public fun randomness_base_for_bulletproof(): RistrettoPoint {
        std::option::extract(&mut ristretto255::new_point_from_bytes(BULLETPROOF_DEFAULT_PEDERSEN_RAND_BASE))
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_pedersen.spec.move
================================================
spec aptos_std::ristretto255_pedersen {
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/secp256k1.move
================================================
/// This module implements ECDSA signatures based on the prime-order secp256k1 ellptic curve (i.e., cofactor is 1).

module aptos_std::secp256k1 {
    use std::option::Option;

    /// An error occurred while deserializing, for example due to wrong input size.
    const E_DESERIALIZE: u64 = 1;   // This code must be the same, if ever returned from the native Rust implementation.

    /// The size of a secp256k1-based ECDSA public key, in bytes.
    const RAW_PUBLIC_KEY_NUM_BYTES: u64 = 64;
    //const COMPRESSED_PUBLIC_KEY_SIZE: u64 = 33;

    /// The size of a secp256k1-based ECDSA signature, in bytes.
    const SIGNATURE_NUM_BYTES: u64 = 64;

    /// A 64-byte ECDSA public key.
    struct ECDSARawPublicKey has copy, drop, store {
        bytes: vector<u8>
    }

    /// A 64-byte ECDSA signature.
    struct ECDSASignature has copy, drop, store {
        bytes: vector<u8>
    }

    /// Constructs an ECDSASignature struct from the given 64 bytes.
    public fun ecdsa_signature_from_bytes(bytes: vector<u8>): ECDSASignature {
        assert!(std::vector::length(&bytes) == SIGNATURE_NUM_BYTES, std::error::invalid_argument(E_DESERIALIZE));
        ECDSASignature { bytes }
    }

    /// Constructs an ECDSARawPublicKey struct, given a 64-byte raw representation.
    public fun ecdsa_raw_public_key_from_64_bytes(bytes: vector<u8>): ECDSARawPublicKey {
        assert!(std::vector::length(&bytes) == RAW_PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_DESERIALIZE));
        ECDSARawPublicKey { bytes }
    }

    /// Serializes an ECDSARawPublicKey struct to 64-bytes.
    public fun ecdsa_raw_public_key_to_bytes(pk: &ECDSARawPublicKey): vector<u8> {
        pk.bytes
    }

    /// Serializes an ECDSASignature struct to 64-bytes.
    public fun ecdsa_signature_to_bytes(sig: &ECDSASignature): vector<u8> {
        sig.bytes
    }

    /// Recovers the signer's raw (64-byte) public key from a secp256k1 ECDSA `signature` given the `recovery_id` and the signed
    /// `message` (32 byte digest).
    ///
    /// Note that an invalid signature, or a signature from a different message, will result in the recovery of an
    /// incorrect public key. This recovery algorithm can only be used to check validity of a signature if the signer's
    /// public key (or its hash) is known beforehand.
    public fun ecdsa_recover(
        message: vector<u8>,
        recovery_id: u8,
        signature: &ECDSASignature,
    ): Option<ECDSARawPublicKey> {
        let (pk, success) = ecdsa_recover_internal(message, recovery_id, signature.bytes);
        if (success) {
            std::option::some(ecdsa_raw_public_key_from_64_bytes(pk))
        } else {
            std::option::none<ECDSARawPublicKey>()
        }
    }

    //
    // Native functions
    //

    /// Returns `(public_key, true)` if `signature` verifies on `message` under the recovered `public_key`
    /// and returns `([], false)` otherwise.
    native fun ecdsa_recover_internal(
        message: vector<u8>,
        recovery_id: u8,
        signature: vector<u8>
    ): (vector<u8>, bool);

    //
    // Tests
    //

    #[test]
    /// Test on a valid secp256k1 ECDSA signature created using sk = x"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
    fun test_ecdsa_recover() {
        use std::hash;

        let pk = ecdsa_recover(
            hash::sha2_256(b"test aptos secp256k1"),
            0,
            &ECDSASignature { bytes: x"f7ad936da03f948c14c542020e3c5f4e02aaacd1f20427c11aa6e2fbf8776477646bba0e1a37f9e7c777c423a1d2849baafd7ff6a9930814a43c3f80d59db56f" },
        );
        assert!(std::option::is_some(&pk), 1);
        assert!(std::option::extract(&mut pk).bytes == x"4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559", 1);

        // Flipped bits; Signature stays valid
        let pk = ecdsa_recover(
            hash::sha2_256(b"test aptos secp256k1"),
            0,
            // NOTE: A '7' was flipped to an 'f' here
            &ECDSASignature { bytes: x"f7ad936da03f948c14c542020e3c5f4e02aaacd1f20427c11aa6e2fbf8776477646bba0e1a37f9e7c7f7c423a1d2849baafd7ff6a9930814a43c3f80d59db56f" },
        );
        assert!(std::option::is_some(&pk), 1);
        assert!(std::option::extract(&mut pk).bytes != x"4646ae5047316b4230d0086c8acec687f00b1cd9d1dc634f6cb358ac0a9a8ffffe77b4dd0a4bfb95851f3b7355c781dd60f8418fc8a65d14907aff47c903a559", 1);

        // Flipped bits; Signature becomes invalid
        let pk = ecdsa_recover(
            hash::sha2_256(b"test aptos secp256k1"),
            0,
            &ECDSASignature { bytes: x"ffad936da03f948c14c542020e3c5f4e02aaacd1f20427c11aa6e2fbf8776477646bba0e1a37f9e7c7f7c423a1d2849baafd7ff6a9930814a43c3f80d59db56f" },
        );
        assert!(std::option::is_none(&pk), 1);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/cryptography/secp256k1.spec.move
================================================
spec aptos_std::secp256k1 {
    spec ecdsa_signature_from_bytes(bytes: vector<u8>): ECDSASignature {
        aborts_if len(bytes) != SIGNATURE_NUM_BYTES;
        ensures result == ECDSASignature { bytes };
    }

    spec ecdsa_raw_public_key_from_64_bytes(bytes: vector<u8>): ECDSARawPublicKey {
        aborts_if len(bytes) != RAW_PUBLIC_KEY_NUM_BYTES;
        ensures result == ECDSARawPublicKey { bytes };
    }

    spec ecdsa_raw_public_key_to_bytes(pk: &ECDSARawPublicKey): vector<u8> {
        aborts_if false;
        ensures result == pk.bytes;
    }

    spec ecdsa_signature_to_bytes(sig: &ECDSASignature): vector<u8> {
        aborts_if false;
        ensures result == sig.bytes;
    }

    spec ecdsa_recover(
        message: vector<u8>,
        recovery_id: u8,
        signature: &ECDSASignature,
    ): Option<ECDSARawPublicKey> {
        aborts_if ecdsa_recover_internal_abort_condition(message, recovery_id, signature.bytes);
        let pk = spec_ecdsa_recover_internal_result_1(message, recovery_id, signature.bytes);
        let success = spec_ecdsa_recover_internal_result_2(message, recovery_id, signature.bytes);
        ensures success ==> result == std::option::spec_some(ecdsa_raw_public_key_from_64_bytes(pk));
        ensures !success ==> result == std::option::spec_none<ECDSARawPublicKey>();
    }

    spec ecdsa_recover_internal(
        message: vector<u8>,
        recovery_id: u8,
        signature: vector<u8>
    ): (vector<u8>, bool) {
        pragma opaque;
        aborts_if ecdsa_recover_internal_abort_condition(message, recovery_id, signature);
        ensures result_1 == spec_ecdsa_recover_internal_result_1(message, recovery_id, signature);
        ensures result_2 == spec_ecdsa_recover_internal_result_2(message, recovery_id, signature);
        ensures len(result_1) == if (result_2) { RAW_PUBLIC_KEY_NUM_BYTES } else { 0 };
    }

    spec fun ecdsa_recover_internal_abort_condition(message: vector<u8>, recovery_id: u8, signature: vector<u8>): bool;
    spec fun spec_ecdsa_recover_internal_result_1(message: vector<u8>, recovery_id: u8, signature: vector<u8>): vector<u8>;
    spec fun spec_ecdsa_recover_internal_result_2(message: vector<u8>, recovery_id: u8, signature: vector<u8>): bool;
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/data_structures/big_vector.move
================================================
module aptos_std::big_vector {
    use std::error;
    use std::vector;
    use aptos_std::table_with_length::{Self, TableWithLength};
    friend aptos_std::smart_vector;

    /// Vector index is out of bounds
    const EINDEX_OUT_OF_BOUNDS: u64 = 1;
    /// Cannot destroy a non-empty vector
    const EVECTOR_NOT_EMPTY: u64 = 2;
    /// Cannot pop back from an empty vector
    const EVECTOR_EMPTY: u64 = 3;
    /// bucket_size cannot be 0
    const EZERO_BUCKET_SIZE: u64 = 4;

    /// A scalable vector implementation based on tables where elements are grouped into buckets.
    /// Each bucket has a capacity of `bucket_size` elements.
    struct BigVector<T> has store {
        buckets: TableWithLength<u64, vector<T>>,
        end_index: u64,
        bucket_size: u64
    }

    /// Regular Vector API

    /// Create an empty vector.
    public(friend) fun empty<T: store>(bucket_size: u64): BigVector<T> {
        assert!(bucket_size > 0, error::invalid_argument(EZERO_BUCKET_SIZE));
        BigVector {
            buckets: table_with_length::new(),
            end_index: 0,
            bucket_size,
        }
    }

    /// Create a vector of length 1 containing the passed in element.
    public(friend) fun singleton<T: store>(element: T, bucket_size: u64): BigVector<T> {
        let v = empty(bucket_size);
        push_back(&mut v, element);
        v
    }

    /// Destroy the vector `v`.
    /// Aborts if `v` is not empty.
    public fun destroy_empty<T>(v: BigVector<T>) {
        assert!(is_empty(&v), error::invalid_argument(EVECTOR_NOT_EMPTY));
        let BigVector { buckets, end_index: _, bucket_size: _ } = v;
        table_with_length::destroy_empty(buckets);
    }

    /// Destroy the vector `v` if T has `drop`
    public fun destroy<T: drop>(v: BigVector<T>) {
        let BigVector { buckets, end_index, bucket_size: _ } = v;
        let i = 0;
        while (end_index > 0) {
            let num_elements = vector::length(&table_with_length::remove(&mut buckets, i));
            end_index = end_index - num_elements;
            i = i + 1;
        };
        table_with_length::destroy_empty(buckets);
    }

    /// Acquire an immutable reference to the `i`th element of the vector `v`.
    /// Aborts if `i` is out of bounds.
    public fun borrow<T>(v: &BigVector<T>, i: u64): &T {
        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        vector::borrow(table_with_length::borrow(&v.buckets, i / v.bucket_size), i % v.bucket_size)
    }

    /// Return a mutable reference to the `i`th element in the vector `v`.
    /// Aborts if `i` is out of bounds.
    public fun borrow_mut<T>(v: &mut BigVector<T>, i: u64): &mut T {
        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        vector::borrow_mut(table_with_length::borrow_mut(&mut v.buckets, i / v.bucket_size), i % v.bucket_size)
    }

    /// Empty and destroy the other vector, and push each of the elements in the other vector onto the lhs vector in the
    /// same order as they occurred in other.
    /// Disclaimer: This function is costly. Use it at your own discretion.
    public fun append<T: store>(lhs: &mut BigVector<T>, other: BigVector<T>) {
        let other_len = length(&other);
        let half_other_len = other_len / 2;
        let i = 0;
        while (i < half_other_len) {
            push_back(lhs, swap_remove(&mut other, i));
            i = i + 1;
        };
        while (i < other_len) {
            push_back(lhs, pop_back(&mut other));
            i = i + 1;
        };
        destroy_empty(other);
    }

    /// Add element `val` to the end of the vector `v`. It grows the buckets when the current buckets are full.
    /// This operation will cost more gas when it adds new bucket.
    public fun push_back<T: store>(v: &mut BigVector<T>, val: T) {
        let num_buckets = table_with_length::length(&v.buckets);
        if (v.end_index == num_buckets * v.bucket_size) {
            table_with_length::add(&mut v.buckets, num_buckets, vector::empty());
            vector::push_back(table_with_length::borrow_mut(&mut v.buckets, num_buckets), val);
        } else {
            vector::push_back(table_with_length::borrow_mut(&mut v.buckets, num_buckets - 1), val);
        };
        v.end_index = v.end_index + 1;
    }

    /// Pop an element from the end of vector `v`. It doesn't shrink the buckets even if they're empty.
    /// Call `shrink_to_fit` explicity to deallocate empty buckets.
    /// Aborts if `v` is empty.
    public fun pop_back<T>(v: &mut BigVector<T>): T {
        assert!(!is_empty(v), error::invalid_state(EVECTOR_EMPTY));
        let num_buckets = table_with_length::length(&v.buckets);
        let last_bucket = table_with_length::borrow_mut(&mut v.buckets, num_buckets - 1);
        let val = vector::pop_back(last_bucket);
        // Shrink the table if the last vector is empty.
        if (vector::is_empty(last_bucket)) {
            move last_bucket;
            vector::destroy_empty(table_with_length::remove(&mut v.buckets, num_buckets - 1));
        };
        v.end_index = v.end_index - 1;
        val
    }

    /// Remove the element at index i in the vector v and return the owned value that was previously stored at i in v.
    /// All elements occurring at indices greater than i will be shifted down by 1. Will abort if i is out of bounds.
    /// Disclaimer: This function is costly. Use it at your own discretion.
    public fun remove<T>(v: &mut BigVector<T>, i: u64): T {
        let len = length(v);
        assert!(i < len, error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        let num_buckets = table_with_length::length(&v.buckets);
        let cur_bucket_index = i / v.bucket_size + 1;
        let cur_bucket = table_with_length::borrow_mut(&mut v.buckets, cur_bucket_index - 1);
        let res = vector::remove(cur_bucket, i % v.bucket_size);
        v.end_index = v.end_index - 1;
        move cur_bucket;
        while ({
            spec {
                invariant cur_bucket_index <= num_buckets;
                invariant table_with_length::spec_len(v.buckets) == num_buckets;
            };
            (cur_bucket_index < num_buckets)
        }) {
            // remove one element from the start of current vector
            let cur_bucket = table_with_length::borrow_mut(&mut v.buckets, cur_bucket_index);
            let t = vector::remove(cur_bucket, 0);
            move cur_bucket;
            // and put it at the end of the last one
            let prev_bucket = table_with_length::borrow_mut(&mut v.buckets, cur_bucket_index - 1);
            vector::push_back(prev_bucket, t);
            cur_bucket_index = cur_bucket_index + 1;
        };
        spec {
            assert cur_bucket_index == num_buckets;
        };

        // Shrink the table if the last vector is empty.
        let last_bucket = table_with_length::borrow_mut(&mut v.buckets, num_buckets - 1);
        if (vector::is_empty(last_bucket)) {
            move last_bucket;
            vector::destroy_empty(table_with_length::remove(&mut v.buckets, num_buckets - 1));
        };

        res
    }

    /// Swap the `i`th element of the vector `v` with the last element and then pop the vector.
    /// This is O(1), but does not preserve ordering of elements in the vector.
    /// Aborts if `i` is out of bounds.
    public fun swap_remove<T>(v: &mut BigVector<T>, i: u64): T {
        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        let last_val = pop_back(v);
        // if the requested value is the last one, return it
        if (v.end_index == i) {
            return last_val
        };
        // because the lack of mem::swap, here we swap remove the requested value from the bucket
        // and append the last_val to the bucket then swap the last bucket val back
        let bucket = table_with_length::borrow_mut(&mut v.buckets, i / v.bucket_size);
        let bucket_len = vector::length(bucket);
        let val = vector::swap_remove(bucket, i % v.bucket_size);
        vector::push_back(bucket, last_val);
        vector::swap(bucket, i % v.bucket_size, bucket_len - 1);
        val
    }

    /// Swap the elements at the i'th and j'th indices in the vector v. Will abort if either of i or j are out of bounds
    /// for v.
    public fun swap<T>(v: &mut BigVector<T>, i: u64, j: u64) {
        assert!(i < length(v) && j < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        let i_bucket_index = i / v.bucket_size;
        let j_bucket_index = j / v.bucket_size;
        let i_vector_index = i % v.bucket_size;
        let j_vector_index = j % v.bucket_size;
        if (i_bucket_index == j_bucket_index) {
            vector::swap(table_with_length::borrow_mut(&mut v.buckets, i_bucket_index), i_vector_index, j_vector_index);
            return
        };
        // If i and j are in different buckets, take the buckets out first for easy mutation.
        let bucket_i = table_with_length::remove(&mut v.buckets, i_bucket_index);
        let bucket_j = table_with_length::remove(&mut v.buckets, j_bucket_index);
        // Get the elements from buckets by calling `swap_remove`.
        let element_i = vector::swap_remove(&mut bucket_i, i_vector_index);
        let element_j = vector::swap_remove(&mut bucket_j, j_vector_index);
        // Swap the elements and push back to the other bucket.
        vector::push_back(&mut bucket_i, element_j);
        vector::push_back(&mut bucket_j, element_i);
        let last_index_in_bucket_i = vector::length(&bucket_i) - 1;
        let last_index_in_bucket_j = vector::length(&bucket_j) - 1;
        // Re-position the swapped elements to the right index.
        vector::swap(&mut bucket_i, i_vector_index, last_index_in_bucket_i);
        vector::swap(&mut bucket_j, j_vector_index, last_index_in_bucket_j);
        // Add back the buckets.
        table_with_length::add(&mut v.buckets, i_bucket_index, bucket_i);
        table_with_length::add(&mut v.buckets, j_bucket_index, bucket_j);
    }

    /// Reverse the order of the elements in the vector v in-place.
    /// Disclaimer: This function is costly. Use it at your own discretion.
    public fun reverse<T>(v: &mut BigVector<T>) {
        let new_buckets = vector[];
        let push_bucket = vector[];
        let num_buckets = table_with_length::length(&v.buckets);
        let num_buckets_left = num_buckets;

        while (num_buckets_left > 0) {
            let pop_bucket = table_with_length::remove(&mut v.buckets, num_buckets_left - 1);
            vector::for_each_reverse(pop_bucket, |val| {
                vector::push_back(&mut push_bucket, val);
                if (vector::length(&push_bucket) == v.bucket_size) {
                    vector::push_back(&mut new_buckets, push_bucket);
                    push_bucket = vector[];
                };
            });
            num_buckets_left = num_buckets_left - 1;
        };

        if (vector::length(&push_bucket) > 0) {
            vector::push_back(&mut new_buckets, push_bucket);
        } else {
            vector::destroy_empty(push_bucket);
        };

        vector::reverse(&mut new_buckets);
        let i = 0;
        assert!(table_with_length::length(&v.buckets) == 0, 0);
        while (i < num_buckets) {
            table_with_length::add(&mut v.buckets, i, vector::pop_back(&mut new_buckets));
            i = i + 1;
        };
        vector::destroy_empty(new_buckets);
    }

    /// Return the index of the first occurrence of an element in v that is equal to e. Returns (true, index) if such an
    /// element was found, and (false, 0) otherwise.
    /// Disclaimer: This function is costly. Use it at your own discretion.
    public fun index_of<T>(v: &BigVector<T>, val: &T): (bool, u64) {
        let num_buckets = table_with_length::length(&v.buckets);
        let bucket_index = 0;
        while (bucket_index < num_buckets) {
            let cur = table_with_length::borrow(&v.buckets, bucket_index);
            let (found, i) = vector::index_of(cur, val);
            if (found) {
                return (true, bucket_index * v.bucket_size + i)
            };
            bucket_index = bucket_index + 1;
        };
        (false, 0)
    }

    /// Return if an element equal to e exists in the vector v.
    /// Disclaimer: This function is costly. Use it at your own discretion.
    public fun contains<T>(v: &BigVector<T>, val: &T): bool {
        if (is_empty(v)) return false;
        let (exist, _) = index_of(v, val);
        exist
    }

    /// Convert a big vector to a native vector, which is supposed to be called mostly by view functions to get an
    /// atomic view of the whole vector.
    /// Disclaimer: This function may be costly as the big vector may be huge in size. Use it at your own discretion.
    public fun to_vector<T: copy>(v: &BigVector<T>): vector<T> {
        let res = vector[];
        let num_buckets = table_with_length::length(&v.buckets);
        let i = 0;
        while (i < num_buckets) {
            vector::append(&mut res, *table_with_length::borrow(&v.buckets, i));
            i = i + 1;
        };
        res
    }

    /// Return the length of the vector.
    public fun length<T>(v: &BigVector<T>): u64 {
        v.end_index
    }

    /// Return `true` if the vector `v` has no elements and `false` otherwise.
    public fun is_empty<T>(v: &BigVector<T>): bool {
        length(v) == 0
    }

    #[test]
    fun big_vector_test() {
        let v = empty(5);
        let i = 0;
        while (i < 100) {
            push_back(&mut v, i);
            i = i + 1;
        };
        let j = 0;
        while (j < 100) {
            let val = borrow(&v, j);
            assert!(*val == j, 0);
            j = j + 1;
        };
        while (i > 0) {
            i = i - 1;
            let (exist, index) = index_of(&v, &i);
            let j = pop_back(&mut v);
            assert!(exist, 0);
            assert!(index == i, 0);
            assert!(j == i, 0);
        };
        while (i < 100) {
            push_back(&mut v, i);
            i = i + 1;
        };
        let last_index = length(&v) - 1;
        assert!(swap_remove(&mut v, last_index) == 99, 0);
        assert!(swap_remove(&mut v, 0) == 0, 0);
        while (length(&v) > 0) {
            // the vector is always [N, 1, 2, ... N-1] with repetitive swap_remove(&mut v, 0)
            let expected = length(&v);
            let val = swap_remove(&mut v, 0);
            assert!(val == expected, 0);
        };
        destroy_empty(v);
    }

    #[test]
    fun big_vector_append_edge_case_test() {
        let v1 = empty(5);
        let v2 = singleton(1u64, 7);
        let v3 = empty(6);
        let v4 = empty(8);
        append(&mut v3, v4);
        assert!(length(&v3) == 0, 0);
        append(&mut v2, v3);
        assert!(length(&v2) == 1, 0);
        append(&mut v1, v2);
        assert!(length(&v1) == 1, 0);
        destroy(v1);
    }

    #[test]
    fun big_vector_append_test() {
        let v1 = empty(5);
        let v2 = empty(7);
        let i = 0;
        while (i < 7) {
            push_back(&mut v1, i);
            i = i + 1;
        };
        while (i < 25) {
            push_back(&mut v2, i);
            i = i + 1;
        };
        append(&mut v1, v2);
        assert!(length(&v1) == 25, 0);
        i = 0;
        while (i < 25) {
            assert!(*borrow(&v1, i) == i, 0);
            i = i + 1;
        };
        destroy(v1);
    }

    #[test]
    fun big_vector_to_vector_test() {
        let v1 = empty(7);
        let i = 0;
        while (i < 100) {
            push_back(&mut v1, i);
            i = i + 1;
        };
        let v2 = to_vector(&v1);
        let j = 0;
        while (j < 100) {
            assert!(*vector::borrow(&v2, j) == j, 0);
            j = j + 1;
        };
        destroy(v1);
    }

    #[test]
    fun big_vector_remove_and_reverse_test() {
        let v = empty(11);
        let i = 0;
        while (i < 101) {
            push_back(&mut v, i);
            i = i + 1;
        };
        remove(&mut v, 100);
        remove(&mut v, 90);
        remove(&mut v, 80);
        remove(&mut v, 70);
        remove(&mut v, 60);
        remove(&mut v, 50);
        remove(&mut v, 40);
        remove(&mut v, 30);
        remove(&mut v, 20);
        remove(&mut v, 10);
        remove(&mut v, 0);
        assert!(length(&v) == 90, 0);

        let index = 0;
        i = 0;
        while (i < 101) {
            if (i % 10 != 0) {
                assert!(*borrow(&v, index) == i, 0);
                index = index + 1;
            };
            i = i + 1;
        };
        destroy(v);
    }

    #[test]
    fun big_vector_swap_test() {
        let v = empty(11);
        let i = 0;
        while (i < 101) {
            push_back(&mut v, i);
            i = i + 1;
        };
        i = 0;
        while (i < 51) {
            swap(&mut v, i, 100 - i);
            i = i + 1;
        };
        i = 0;
        while (i < 101) {
            assert!(*borrow(&v, i) == 100 - i, 0);
            i = i + 1;
        };
        destroy(v);
    }

    #[test]
    fun big_vector_index_of_test() {
        let v = empty(11);
        let i = 0;
        while (i < 100) {
            push_back(&mut v, i);
            let (found, idx) = index_of(&mut v, &i);
            assert!(found && idx == i, 0);
            i = i + 1;
        };
        destroy(v);
    }

    #[test]
    fun big_vector_empty_contains() {
        let v = empty<u64>(10);
        assert!(!contains<u64>(&v, &(1 as u64)), 0);
        destroy_empty(v);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/data_structures/big_vector.spec.move
================================================
spec aptos_std::big_vector {
    // -----------------
    // Data invariants
    // -----------------

    spec BigVector {
        invariant bucket_size != 0;
        invariant spec_table_len(buckets) == 0 ==> end_index == 0;
        invariant end_index == 0 ==> spec_table_len(buckets) == 0;
        invariant end_index <= spec_table_len(buckets) * bucket_size;

        // ensure all buckets except last has `bucket_size`
        invariant spec_table_len(buckets) == 0
            || (forall i in 0..spec_table_len(buckets)-1: len(table_with_length::spec_get(buckets, i)) == bucket_size);
        // ensure last bucket doesn't have more than `bucket_size` elements
        invariant spec_table_len(buckets) == 0
            || len(table_with_length::spec_get(buckets, spec_table_len(buckets) -1 )) <= bucket_size;
        // ensure each table entry exists due to a bad spec in `Table::spec_get`
        invariant forall i in 0..spec_table_len(buckets): spec_table_contains(buckets, i);
        // ensure correct number of buckets
        invariant spec_table_len(buckets) == (end_index + bucket_size - 1) / bucket_size;
        // ensure bucket lengths add up to `end_index`
        invariant (spec_table_len(buckets) == 0 && end_index == 0)
            || (spec_table_len(buckets) != 0 && ((spec_table_len(buckets) - 1) * bucket_size) + (len(table_with_length::spec_get(buckets, spec_table_len(buckets) - 1))) == end_index);
        // ensures that no out-of-bound buckets exist
        invariant forall i: u64 where i >= spec_table_len(buckets):  {
            !spec_table_contains(buckets, i)
        };
        // ensures that all buckets exist
        invariant forall i: u64 where i < spec_table_len(buckets):  {
            spec_table_contains(buckets, i)
        };
        // ensures that the last bucket is non-empty
        invariant spec_table_len(buckets) == 0
            || (len(table_with_length::spec_get(buckets, spec_table_len(buckets) - 1)) > 0);
    }


    // -----------------------
    // Function specifications
    // -----------------------

    spec empty<T: store>(bucket_size: u64): BigVector<T> {
        aborts_if bucket_size == 0;
        ensures length(result) == 0;
        ensures result.bucket_size == bucket_size;
    }

    spec singleton<T: store>(element: T, bucket_size: u64): BigVector<T> {
        aborts_if bucket_size == 0;
        ensures length(result) == 1;
        ensures result.bucket_size == bucket_size;
    }

    spec destroy_empty<T>(v: BigVector<T>) {
        aborts_if !is_empty(v);
    }

    spec borrow<T>(v: &BigVector<T>, i: u64): &T {
        aborts_if i >= length(v);
        ensures result == spec_at(v, i);
    }

    spec borrow_mut<T>(v: &mut BigVector<T>, i: u64): &mut T {
        aborts_if i >= length(v);
        ensures result == spec_at(v, i);
    }

    spec push_back<T: store>(v: &mut BigVector<T>, val: T) {
        let num_buckets = spec_table_len(v.buckets);
        include PushbackAbortsIf<T>;
        ensures length(v) == length(old(v)) + 1;
        ensures v.end_index == old(v.end_index) + 1;
        ensures spec_at(v, v.end_index-1) == val;
        ensures forall i in 0..v.end_index-1: spec_at(v, i) == spec_at(old(v), i);
        ensures v.bucket_size == old(v).bucket_size;
    }

    spec schema PushbackAbortsIf<T> {
        v: BigVector<T>;
        let num_buckets = spec_table_len(v.buckets);
        aborts_if num_buckets * v.bucket_size > MAX_U64;
        aborts_if v.end_index + 1 > MAX_U64;
    }

    spec pop_back<T>(v: &mut BigVector<T>): T {
        aborts_if is_empty(v);
        ensures length(v) == length(old(v)) - 1;
        ensures result == old(spec_at(v, v.end_index-1));
        ensures forall i in 0..v.end_index: spec_at(v, i) == spec_at(old(v), i);
    }

    spec swap_remove<T>(v: &mut BigVector<T>, i: u64): T {
        pragma verify_duration_estimate = 120;
        aborts_if i >= length(v);
        ensures length(v) == length(old(v)) - 1;
        ensures result == spec_at(old(v), i);
    }

    spec swap<T>(v: &mut BigVector<T>, i: u64, j: u64) {
        pragma verify_duration_estimate = 1000;
        aborts_if i >= length(v) || j >= length(v);
        ensures length(v) == length(old(v));
        ensures spec_at(v, i) == spec_at(old(v), j);
        ensures spec_at(v, j) == spec_at(old(v), i);
        ensures forall idx in 0..length(v)
            where idx != i && idx != j:
            spec_at(v, idx) == spec_at(old(v), idx);
    }

    spec append<T: store>(lhs: &mut BigVector<T>, other: BigVector<T>) {
        pragma verify=false;
    }

    spec remove<T>(v: &mut BigVector<T>, i: u64): T {
        pragma verify=false;
    }

    spec reverse<T>(v: &mut BigVector<T>) {
        pragma verify=false;
    }

    spec index_of<T>(v: &BigVector<T>, val: &T): (bool, u64) {
        pragma verify=false;
    }

    // ---------------------
    // Spec helper functions
    // ---------------------

    spec fun spec_table_len<K, V>(t: TableWithLength<K, V>): u64 {
        table_with_length::spec_len(t)
    }

    spec fun spec_table_contains<K, V>(t: TableWithLength<K, V>, k: K): bool {
        table_with_length::spec_contains(t, k)
    }

    spec fun spec_at<T>(v: BigVector<T>, i: u64): T {
        let bucket = i / v.bucket_size;
        let idx = i % v.bucket_size;
        let v = table_with_length::spec_get(v.buckets, bucket);
        v[idx]
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/data_structures/smart_table.move
================================================
/// A smart table implementation based on linear hashing. (https://en.wikipedia.org/wiki/Linear_hashing)
/// Compare to Table, it uses less storage slots but has higher chance of collision, a trade-off between space and time.
/// Compare to other dynamic hashing implementation, linear hashing splits one bucket a time instead of doubling buckets
/// when expanding to avoid unexpected gas cost.
/// SmartTable uses faster hash function SipHash instead of cryptographically secure hash functions like sha3-256 since
/// it tolerates collisions.
module aptos_std::smart_table {
    use std::error;
    use std::vector;
    use aptos_std::aptos_hash::sip_hash_from_value;
    use aptos_std::table_with_length::{Self, TableWithLength};
    use aptos_std::type_info::size_of_val;
    use aptos_std::math64::max;
    use aptos_std::simple_map::SimpleMap;
    use aptos_std::simple_map;
    use std::option::{Self, Option};

    /// Key not found in the smart table
    const ENOT_FOUND: u64 = 1;
    /// Smart table capacity must be larger than 0
    const EZERO_CAPACITY: u64 = 2;
    /// Cannot destroy non-empty hashmap
    const ENOT_EMPTY: u64 = 3;
    /// Key already exists
    const EALREADY_EXIST: u64 = 4;
    /// Invalid load threshold percent to trigger split.
    const EINVALID_LOAD_THRESHOLD_PERCENT: u64 = 5;
    /// Invalid target bucket size.
    const EINVALID_TARGET_BUCKET_SIZE: u64 = 6;
    /// Invalid target bucket size.
    const EEXCEED_MAX_BUCKET_SIZE: u64 = 7;
    /// Invalid bucket index.
    const EINVALID_BUCKET_INDEX: u64 = 8;
    /// Invalid vector index within a bucket.
    const EINVALID_VECTOR_INDEX: u64 = 9;

    /// SmartTable entry contains both the key and value.
    struct Entry<K, V> has copy, drop, store {
        hash: u64,
        key: K,
        value: V,
    }

    struct SmartTable<K, V> has store {
        buckets: TableWithLength<u64, vector<Entry<K, V>>>,
        num_buckets: u64,
        // number of bits to represent num_buckets
        level: u8,
        // total number of items
        size: u64,
        // Split will be triggered when target load threshold in percentage is reached when adding a new entry.
        split_load_threshold: u8,
        // The target size of each bucket, which is NOT enforced so oversized buckets can exist.
        target_bucket_size: u64,
    }

    /// Create an empty SmartTable with default configurations.
    public fun new<K: copy + drop + store, V: store>(): SmartTable<K, V> {
        new_with_config<K, V>(0, 0, 0)
    }

    /// Create an empty SmartTable with customized configurations.
    /// `num_initial_buckets`: The number of buckets on initialization. 0 means using default value.
    /// `split_load_threshold`: The percent number which once reached, split will be triggered. 0 means using default
    /// value.
    /// `target_bucket_size`: The target number of entries per bucket, though not guaranteed. 0 means not set and will
    /// dynamically assgined by the contract code.
    public fun new_with_config<K: copy + drop + store, V: store>(
        num_initial_buckets: u64,
        split_load_threshold: u8,
        target_bucket_size: u64
    ): SmartTable<K, V> {
        assert!(split_load_threshold <= 100, error::invalid_argument(EINVALID_LOAD_THRESHOLD_PERCENT));
        let buckets = table_with_length::new();
        table_with_length::add(&mut buckets, 0, vector::empty());
        let table = SmartTable {
            buckets,
            num_buckets: 1,
            level: 0,
            size: 0,
            // The default split load threshold is 75%.
            split_load_threshold: if (split_load_threshold == 0) { 75 } else { split_load_threshold },
            target_bucket_size,
        };
        // The default number of initial buckets is 2.
        if (num_initial_buckets == 0) {
            num_initial_buckets = 2;
        };
        while (num_initial_buckets > 1) {
            num_initial_buckets = num_initial_buckets - 1;
            split_one_bucket(&mut table);
        };
        table
    }

    /// Destroy empty table.
    /// Aborts if it's not empty.
    public fun destroy_empty<K, V>(table: SmartTable<K, V>) {
        assert!(table.size == 0, error::invalid_argument(ENOT_EMPTY));
        let i = 0;
        while (i < table.num_buckets) {
            vector::destroy_empty(table_with_length::remove(&mut table.buckets, i));
            i = i + 1;
        };
        let SmartTable { buckets, num_buckets: _, level: _, size: _, split_load_threshold: _, target_bucket_size: _ } = table;
        table_with_length::destroy_empty(buckets);
    }

    /// Destroy a table completely when V has `drop`.
    public fun destroy<K: drop, V: drop>(table: SmartTable<K, V>) {
        clear(&mut table);
        destroy_empty(table);
    }

    /// Clear a table completely when T has `drop`.
    public fun clear<K: drop, V: drop>(table: &mut SmartTable<K, V>) {
        *table_with_length::borrow_mut(&mut table.buckets, 0) = vector::empty();
        let i = 1;
        while (i < table.num_buckets) {
            table_with_length::remove(&mut table.buckets, i);
            i = i + 1;
        };
        table.num_buckets = 1;
        table.level = 0;
        table.size = 0;
    }

    /// Add (key, value) pair in the hash map, it may grow one bucket if current load factor exceeds the threshold.
    /// Note it may not split the actual overflowed bucket. Instead, it was determined by `num_buckets` and `level`.
    /// For standard linear hash algorithm, it is stored as a variable but `num_buckets` here could be leveraged.
    /// Abort if `key` already exists.
    /// Note: This method may occasionally cost much more gas when triggering bucket split.
    public fun add<K, V>(table: &mut SmartTable<K, V>, key: K, value: V) {
        let hash = sip_hash_from_value(&key);
        let index = bucket_index(table.level, table.num_buckets, hash);
        let bucket = table_with_length::borrow_mut(&mut table.buckets, index);
        // We set a per-bucket limit here with a upper bound (10000) that nobody should normally reach.
        assert!(vector::length(bucket) <= 10000, error::permission_denied(EEXCEED_MAX_BUCKET_SIZE));
        assert!(vector::all(bucket, | entry | {
            let e: &Entry<K, V> = entry;
            &e.key != &key
        }), error::invalid_argument(EALREADY_EXIST));
        let e = Entry { hash, key, value };
        if (table.target_bucket_size == 0) {
            let estimated_entry_size = max(size_of_val(&e), 1);
            table.target_bucket_size = max(1024 /* free_write_quota */ / estimated_entry_size, 1);
        };
        vector::push_back(bucket, e);
        table.size = table.size + 1;

        if (load_factor(table) >= (table.split_load_threshold as u64)) {
            split_one_bucket(table);
        }
    }

    /// Add multiple key/value pairs to the smart table. The keys must not already exist.
    public fun add_all<K, V>(table: &mut SmartTable<K, V>, keys: vector<K>, values: vector<V>) {
        vector::zip(keys, values, |key, value| { add(table, key, value); });
    }

    inline fun unzip_entries<K: copy, V: copy>(entries: &vector<Entry<K, V>>): (vector<K>, vector<V>) {
        let keys = vector[];
        let values = vector[];
        vector::for_each_ref(entries, |e|{
            let entry: &Entry<K, V> = e;
            vector::push_back(&mut keys, entry.key);
            vector::push_back(&mut values, entry.value);
        });
        (keys, values)
    }

    /// Convert a smart table to a simple_map, which is supposed to be called mostly by view functions to get an atomic
    /// view of the whole table.
    /// Disclaimer: This function may be costly as the smart table may be huge in size. Use it at your own discretion.
    public fun to_simple_map<K: store + copy + drop, V: store + copy>(
        table: &SmartTable<K, V>,
    ): SimpleMap<K, V> {
        let i = 0;
        let res = simple_map::new<K, V>();
        while (i < table.num_buckets) {
            let (keys, values) = unzip_entries(table_with_length::borrow(&table.buckets, i));
            simple_map::add_all(&mut res, keys, values);
            i = i + 1;
        };
        res
    }

    /// Get all keys in a smart table.
    ///
    /// For a large enough smart table this function will fail due to execution gas limits, and
    /// `keys_paginated` should be used instead.
    public fun keys<K: store + copy + drop, V: store + copy>(
        table_ref: &SmartTable<K, V>
    ): vector<K> {
        let (keys, _, _) = keys_paginated(table_ref, 0, 0, length(table_ref));
        keys
    }

    /// Get keys from a smart table, paginated.
    ///
    /// This function can be used to paginate all keys in a large smart table outside of runtime,
    /// e.g. through chained view function calls. The maximum `num_keys_to_get` before hitting gas
    /// limits depends on the data types in the smart table.
    ///
    /// When starting pagination, pass `starting_bucket_index` = `starting_vector_index` = 0.
    ///
    /// The function will then return a vector of keys, an optional bucket index, and an optional
    /// vector index. The unpacked return indices can then be used as inputs to another pagination
    /// call, which will return a vector of more keys. This process can be repeated until the
    /// returned bucket index and vector index value options are both none, which means that
    /// pagination is complete. For an example, see `test_keys()`.
    public fun keys_paginated<K: store + copy + drop, V: store + copy>(
        table_ref: &SmartTable<K, V>,
        starting_bucket_index: u64,
        starting_vector_index: u64,
        num_keys_to_get: u64,
    ): (
        vector<K>,
        Option<u64>,
        Option<u64>,
    ) {
        let num_buckets = table_ref.num_buckets;
        let buckets_ref = &table_ref.buckets;
        assert!(starting_bucket_index < num_buckets, EINVALID_BUCKET_INDEX);
        let bucket_ref = table_with_length::borrow(buckets_ref, starting_bucket_index);
        let bucket_length = vector::length(bucket_ref);
        assert!(
            // In the general case, starting vector index should never be equal to bucket length
            // because then iteration will attempt to borrow a vector element that is out of bounds.
            // However starting vector index can be equal to bucket length in the special case of
            // starting iteration at the beginning of an empty bucket since buckets are never
            // destroyed, only emptied.
            starting_vector_index < bucket_length || starting_vector_index == 0,
            EINVALID_VECTOR_INDEX
        );
        let keys = vector[];
        if (num_keys_to_get == 0) return
            (keys, option::some(starting_bucket_index), option::some(starting_vector_index));
        for (bucket_index in starting_bucket_index..num_buckets) {
            bucket_ref = table_with_length::borrow(buckets_ref, bucket_index);
            bucket_length = vector::length(bucket_ref);
            for (vector_index in starting_vector_index..bucket_length) {
                vector::push_back(&mut keys, vector::borrow(bucket_ref, vector_index).key);
                num_keys_to_get = num_keys_to_get - 1;
                if (num_keys_to_get == 0) {
                    vector_index = vector_index + 1;
                    return if (vector_index == bucket_length) {
                        bucket_index = bucket_index + 1;
                        if (bucket_index < num_buckets) {
                            (keys, option::some(bucket_index), option::some(0))
                        } else {
                            (keys, option::none(), option::none())
                        }
                    } else {
                        (keys, option::some(bucket_index), option::some(vector_index))
                    }
                };
            };
            starting_vector_index = 0; // Start parsing the next bucket at vector index 0.
        };
        (keys, option::none(), option::none())
    }

    /// Decide which is the next bucket to split and split it into two with the elements inside the bucket.
    fun split_one_bucket<K, V>(table: &mut SmartTable<K, V>) {
        let new_bucket_index = table.num_buckets;
        // the next bucket to split is num_bucket without the most significant bit.
        let to_split = new_bucket_index ^ (1 << table.level);
        table.num_buckets = new_bucket_index + 1;
        // if the whole level is splitted once, bump the level.
        if (to_split + 1 == 1 << table.level) {
            table.level = table.level + 1;
        };
        let old_bucket = table_with_length::borrow_mut(&mut table.buckets, to_split);
        // partition the bucket, [0..p) stays in old bucket, [p..len) goes to new bucket
        let p = vector::partition(old_bucket, |e| {
            let entry: &Entry<K, V> = e; // Explicit type to satisfy compiler
            bucket_index(table.level, table.num_buckets, entry.hash) != new_bucket_index
        });
        let new_bucket = vector::trim_reverse(old_bucket, p);
        table_with_length::add(&mut table.buckets, new_bucket_index, new_bucket);
    }

    /// Return the expected bucket index to find the hash.
    /// Basically, it use different base `1 << level` vs `1 << (level + 1)` in modulo operation based on the target
    /// bucket index compared to the index of the next bucket to split.
    fun bucket_index(level: u8, num_buckets: u64, hash: u64): u64 {
        let index = hash % (1 << (level + 1));
        if (index < num_buckets) {
            // in existing bucket
            index
        } else {
            // in unsplitted bucket
            index % (1 << level)
        }
    }

    /// Acquire an immutable reference to the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun borrow<K: drop, V>(table: &SmartTable<K, V>, key: K): &V {
        let index = bucket_index(table.level, table.num_buckets, sip_hash_from_value(&key));
        let bucket = table_with_length::borrow(&table.buckets, index);
        let i = 0;
        let len = vector::length(bucket);
        while (i < len) {
            let entry = vector::borrow(bucket, i);
            if (&entry.key == &key) {
                return &entry.value
            };
            i = i + 1;
        };
        abort error::invalid_argument(ENOT_FOUND)
    }

    /// Acquire an immutable reference to the value which `key` maps to.
    /// Returns specified default value if there is no entry for `key`.
    public fun borrow_with_default<K: copy + drop, V>(table: &SmartTable<K, V>, key: K, default: &V): &V {
        if (!contains(table, copy key)) {
            default
        } else {
            borrow(table, copy key)
        }
    }

    /// Acquire a mutable reference to the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun borrow_mut<K: drop, V>(table: &mut SmartTable<K, V>, key: K): &mut V {
        let index = bucket_index(table.level, table.num_buckets, sip_hash_from_value(&key));
        let bucket = table_with_length::borrow_mut(&mut table.buckets, index);
        let i = 0;
        let len = vector::length(bucket);
        while (i < len) {
            let entry = vector::borrow_mut(bucket, i);
            if (&entry.key == &key) {
                return &mut entry.value
            };
            i = i + 1;
        };
        abort error::invalid_argument(ENOT_FOUND)
    }

    /// Acquire a mutable reference to the value which `key` maps to.
    /// Insert the pair (`key`, `default`) first if there is no entry for `key`.
    public fun borrow_mut_with_default<K: copy + drop, V: drop>(
        table: &mut SmartTable<K, V>,
        key: K,
        default: V
    ): &mut V {
        if (!contains(table, copy key)) {
            add(table, copy key, default)
        };
        borrow_mut(table, key)
    }

    /// Returns true iff `table` contains an entry for `key`.
    public fun contains<K: drop, V>(table: &SmartTable<K, V>, key: K): bool {
        let hash = sip_hash_from_value(&key);
        let index = bucket_index(table.level, table.num_buckets, hash);
        let bucket = table_with_length::borrow(&table.buckets, index);
        vector::any(bucket, | entry | {
            let e: &Entry<K, V> = entry;
            e.hash == hash && &e.key == &key
        })
    }

    /// Remove from `table` and return the value which `key` maps to.
    /// Aborts if there is no entry for `key`.
    public fun remove<K: copy + drop, V>(table: &mut SmartTable<K, V>, key: K): V {
        let index = bucket_index(table.level, table.num_buckets, sip_hash_from_value(&key));
        let bucket = table_with_length::borrow_mut(&mut table.buckets, index);
        let i = 0;
        let len = vector::length(bucket);
        while (i < len) {
            let entry = vector::borrow(bucket, i);
            if (&entry.key == &key) {
                let Entry { hash: _, key: _, value } = vector::swap_remove(bucket, i);
                table.size = table.size - 1;
                return value
            };
            i = i + 1;
        };
        abort error::invalid_argument(ENOT_FOUND)
    }

    /// Insert the pair (`key`, `value`) if there is no entry for `key`.
    /// update the value of the entry for `key` to `value` otherwise
    public fun upsert<K: copy + drop, V: drop>(table: &mut SmartTable<K, V>, key: K, value: V) {
        if (!contains(table, copy key)) {
            add(table, copy key, value)
        } else {
            let ref = borrow_mut(table, key);
            *ref = value;
        };
    }

    /// Returns the length of the table, i.e. the number of entries.
    public fun length<K, V>(table: &SmartTable<K, V>): u64 {
        table.size
    }

    /// Return the load factor of the hashtable.
    public fun load_factor<K, V>(table: &SmartTable<K, V>): u64 {
        table.size * 100 / table.num_buckets / table.target_bucket_size
    }

    /// Update `split_load_threshold`.
    public fun update_split_load_threshold<K, V>(table: &mut SmartTable<K, V>, split_load_threshold: u8) {
        assert!(
            split_load_threshold <= 100 && split_load_threshold > 0,
            error::invalid_argument(EINVALID_LOAD_THRESHOLD_PERCENT)
        );
        table.split_load_threshold = split_load_threshold;
    }

    /// Update `target_bucket_size`.
    public fun update_target_bucket_size<K, V>(table: &mut SmartTable<K, V>, target_bucket_size: u64) {
        assert!(target_bucket_size > 0, error::invalid_argument(EINVALID_TARGET_BUCKET_SIZE));
        table.target_bucket_size = target_bucket_size;
    }

    /// Apply the function to a reference of each key-value pair in the table.
    public inline fun for_each_ref<K, V>(table: &SmartTable<K, V>, f: |&K, &V|) {
        let i = 0;
        while (i < aptos_std::smart_table::num_buckets(table)) {
            vector::for_each_ref(
                aptos_std::table_with_length::borrow(aptos_std::smart_table::borrow_buckets(table), i),
                |elem| {
                    let (key, value) = aptos_std::smart_table::borrow_kv(elem);
                    f(key, value)
                }
            );
            i = i + 1;
        }
    }

    /// Apply the function to a mutable reference of each key-value pair in the table.
    public inline fun for_each_mut<K, V>(table: &mut SmartTable<K, V>, f: |&K, &mut V|) {
        let i = 0;
        while (i < aptos_std::smart_table::num_buckets(table)) {
            vector::for_each_mut(
                table_with_length::borrow_mut(aptos_std::smart_table::borrow_buckets_mut(table), i),
                |elem| {
                    let (key, value) = aptos_std::smart_table::borrow_kv_mut(elem);
                    f(key, value)
                }
            );
            i = i + 1;
        };
    }

    /// Map the function over the references of key-value pairs in the table without modifying it.
    public inline fun map_ref<K: copy + drop + store, V1, V2: store>(
        table: &SmartTable<K, V1>,
        f: |&V1|V2
    ): SmartTable<K, V2> {
        let new_table = new<K, V2>();
        for_each_ref(table, |key, value| add(&mut new_table, *key, f(value)));
        new_table
    }

    /// Return true if any key-value pair in the table satisfies the predicate.
    public inline fun any<K, V>(
        table: &SmartTable<K, V>,
        p: |&K, &V|bool
    ): bool {
        let found = false;
        let i = 0;
        while (i < aptos_std::smart_table::num_buckets(table)) {
            found = vector::any(table_with_length::borrow(aptos_std::smart_table::borrow_buckets(table), i), |elem| {
                let (key, value) = aptos_std::smart_table::borrow_kv(elem);
                p(key, value)
            });
            if (found) break;
            i = i + 1;
        };
        found
    }

    // Helper functions to circumvent the scope issue of inline functions.
    public fun borrow_kv<K, V>(e: &Entry<K, V>): (&K, &V) {
        (&e.key, &e.value)
    }

    public fun borrow_kv_mut<K, V>(e: &mut Entry<K, V>): (&mut K, &mut V) {
        (&mut e.key, &mut e.value)
    }

    public fun num_buckets<K, V>(table: &SmartTable<K, V>): u64 {
        table.num_buckets
    }

    public fun borrow_buckets<K, V>(table: &SmartTable<K, V>): &TableWithLength<u64, vector<Entry<K, V>>> {
        &table.buckets
    }

    public fun borrow_buckets_mut<K, V>(table: &mut SmartTable<K, V>): &mut TableWithLength<u64, vector<Entry<K, V>>> {
        &mut table.buckets
    }


    #[test]
    fun smart_table_test() {
        let table = new();
        let i = 0;
        while (i < 200) {
            add(&mut table, i, i);
            i = i + 1;
        };
        assert!(length(&table) == 200, 0);
        i = 0;
        while (i < 200) {
            *borrow_mut(&mut table, i) = i * 2;
            assert!(*borrow(&table, i) == i * 2, 0);
            i = i + 1;
        };
        i = 0;
        assert!(table.num_buckets > 5, table.num_buckets);
        while (i < 200) {
            assert!(contains(&table, i), 0);
            assert!(remove(&mut table, i) == i * 2, 0);
            i = i + 1;
        };
        destroy_empty(table);
    }

    #[test]
    fun smart_table_split_test() {
        let table: SmartTable<u64, u64> = new_with_config(1, 100, 1);
        let i = 1;
        let level = 0;
        while (i <= 256) {
            assert!(table.num_buckets == i, 0);
            assert!(table.level == level, i);
            add(&mut table, i, i);
            i = i + 1;
            if (i == 1 << (level + 1)) {
                level = level + 1;
            };
        };
        let i = 1;
        while (i <= 256) {
            assert!(*borrow(&table, i) == i, 0);
            i = i + 1;
        };
        assert!(table.num_buckets == 257, table.num_buckets);
        assert!(load_factor(&table) == 99, 0);
        assert!(length(&table) == 256, 0);
        destroy(table);
    }

    #[test]
    fun smart_table_update_configs() {
        let table = new();
        let i = 0;
        while (i < 200) {
            add(&mut table, i, i);
            i = i + 1;
        };
        assert!(length(&table) == 200, 0);
        update_target_bucket_size(&mut table, 10);
        update_split_load_threshold(&mut table, 50);
        while (i < 400) {
            add(&mut table, i, i);
            i = i + 1;
        };
        assert!(length(&table) == 400, 0);
        i = 0;
        while (i < 400) {
            assert!(contains(&table, i), 0);
            assert!(remove(&mut table, i) == i, 0);
            i = i + 1;
        };
        destroy_empty(table);
    }

    #[test]
    public fun smart_table_add_all_test() {
        let table: SmartTable<u64, u64> = new_with_config(1, 100, 2);
        assert!(length(&table) == 0, 0);
        add_all(&mut table, vector[1, 2, 3, 4, 5, 6, 7], vector[1, 2, 3, 4, 5, 6, 7]);
        assert!(length(&table) == 7, 1);
        let i = 1;
        while (i < 8) {
            assert!(*borrow(&table, i) == i, 0);
            i = i + 1;
        };
        i = i - 1;
        while (i > 0) {
            remove(&mut table, i);
            i = i - 1;
        };
        destroy_empty(table);
    }

    #[test]
    public fun smart_table_to_simple_map_test() {
        let table = new();
        let i = 0;
        while (i < 200) {
            add(&mut table, i, i);
            i = i + 1;
        };
        let map = to_simple_map(&table);
        assert!(simple_map::length(&map) == 200, 0);
        destroy(table);
    }

    #[test]
    public fun smart_table_clear_test() {
        let table = new();
        let i = 0u64;
        while (i < 200) {
            add(&mut table, i, i);
            i = i + 1;
        };
        clear(&mut table);
        let i = 0;
        while (i < 200) {
            add(&mut table, i, i);
            i = i + 1;
        };
        assert!(table.size == 200, 0);
        destroy(table);
    }

    #[test]
    fun test_keys() {
        let i = 0;
        let table = new();
        let expected_keys = vector[];
        let keys = keys(&table);
        assert!(vector::is_empty(&keys), 0);
        let starting_bucket_index = 0;
        let starting_vector_index = 0;
        let (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(
            &table,
            starting_bucket_index,
            starting_vector_index,
            0
        );
        assert!(starting_bucket_index_r == option::some(starting_bucket_index), 0);
        assert!(starting_vector_index_r == option::some(starting_vector_index), 0);
        assert!(vector::is_empty(&keys), 0);
        while (i < 100) {
            add(&mut table, i, 0);
            vector::push_back(&mut expected_keys, i);
            i = i + 1;
        };
        let keys = keys(&table);
        assert!(vector::length(&keys) == vector::length(&expected_keys), 0);
        vector::for_each_ref(&keys, |e_ref| {
            assert!(vector::contains(&expected_keys, e_ref), 0);
        });
        let keys = vector[];
        let starting_bucket_index = 0;
        let starting_vector_index = 0;
        let returned_keys = vector[];
        vector::length(&returned_keys); // To eliminate erroneous compiler "unused" warning
        loop {
            (returned_keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(
                &table,
                starting_bucket_index,
                starting_vector_index,
                15
            );
            vector::append(&mut keys, returned_keys);
            if (
                starting_bucket_index_r == option::none() ||
                starting_vector_index_r == option::none()
            ) break;
            starting_bucket_index = option::destroy_some(starting_bucket_index_r);
            starting_vector_index = option::destroy_some(starting_vector_index_r);
        };
        assert!(vector::length(&keys) == vector::length(&expected_keys), 0);
        vector::for_each_ref(&keys, |e_ref| {
            assert!(vector::contains(&expected_keys, e_ref), 0);
        });
        destroy(table);
        table = new();
        add(&mut table, 1, 0);
        add(&mut table, 2, 0);
        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(&table, 0, 0, 1);
        (returned_keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(
            &table,
            option::destroy_some(starting_bucket_index_r),
            option::destroy_some(starting_vector_index_r),
            1,
        );
        vector::append(&mut keys, returned_keys);
        assert!(keys == vector[1, 2] || keys == vector[2, 1], 0);
        assert!(starting_bucket_index_r == option::none(), 0);
        assert!(starting_vector_index_r == option::none(), 0);
        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(&table, 0, 0, 0);
        assert!(keys == vector[], 0);
        assert!(starting_bucket_index_r == option::some(0), 0);
        assert!(starting_vector_index_r == option::some(0), 0);
        destroy(table);
    }

    #[test]
    fun test_keys_corner_cases() {
        let table = new();
        let expected_keys = vector[];
        for (i in 0..100) {
            add(&mut table, i, 0);
            vector::push_back(&mut expected_keys, i);
        };
        let (keys, starting_bucket_index_r, starting_vector_index_r) =
            keys_paginated(&table, 0, 0, 5); // Both indices 0.
        assert!(vector::length(&keys) == 5, 0);
        vector::for_each_ref(&keys, |e_ref| {
            assert!(vector::contains(&expected_keys, e_ref), 0);
        });
        let starting_bucket_index = option::destroy_some(starting_bucket_index_r);
        let starting_vector_index = option::destroy_some(starting_vector_index_r);
        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(
            &table,
            starting_bucket_index,
            starting_vector_index,
            0, // Number of keys 0.
        );
        assert!(keys == vector[], 0);
        assert!(starting_bucket_index_r == option::some(starting_bucket_index), 0);
        assert!(starting_vector_index_r == option::some(starting_vector_index), 0);
        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(
            &table,
            starting_bucket_index,
            0, // Vector index 0.
            50,
        );
        assert!(vector::length(&keys) == 50, 0);
        vector::for_each_ref(&keys, |e_ref| {
            assert!(vector::contains(&expected_keys, e_ref), 0);
        });
        let starting_bucket_index = option::destroy_some(starting_bucket_index_r);
        assert!(starting_bucket_index > 0, 0);
        assert!(option::is_some(&starting_vector_index_r), 0);
        (keys, starting_bucket_index_r, starting_vector_index_r) = keys_paginated(
            &table,
            0, // Bucket index 0.
            1,
            50,
        );
        assert!(vector::length(&keys) == 50, 0);
        vector::for_each_ref(&keys, |e_ref| {
            assert!(vector::contains(&expected_keys, e_ref), 0);
        });
        assert!(option::is_some(&starting_bucket_index_r), 0);
        assert!(option::is_some(&starting_vector_index_r), 0);
        destroy(table);
    }

    #[test, expected_failure(abort_code = EINVALID_BUCKET_INDEX)]
    fun test_keys_invalid_bucket_index() {
        let table = new();
        add(&mut table, 1, 0);
        let num_buckets = table.num_buckets;
        keys_paginated(&table, num_buckets + 1, 0, 1);
        destroy(table);
    }

    #[test, expected_failure(abort_code = EINVALID_VECTOR_INDEX)]
    fun test_keys_invalid_vector_index() {
        let table = new();
        add(&mut table, 1, 0);
        keys_paginated(&table, 0, 1, 1);
        destroy(table);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/data_structures/smart_table.spec.move
================================================
spec aptos_std::smart_table {
    spec SmartTable {
        pragma intrinsic = map,
            map_new = new,
            map_destroy_empty = destroy_empty,
            map_len = length,
            map_has_key = contains,
            map_add_no_override = add,
            map_add_override_if_exists = upsert,
            map_del_must_exist = remove,
            map_borrow = borrow,
            map_borrow_mut = borrow_mut,
            map_borrow_mut_with_default = borrow_mut_with_default,
            map_spec_get = spec_get,
            map_spec_set = spec_set,
            map_spec_del = spec_remove,
            map_spec_len = spec_len,
        map_spec_has_key = spec_contains;
    }

    spec new_with_config<K: copy + drop + store, V: store>(num_initial_buckets: u64, split_load_threshold: u8, target_bucket_size: u64): SmartTable<K, V> {
        pragma verify = false;
    }

    spec destroy<K: drop, V: drop>(table: SmartTable<K, V>) {
        pragma verify = false;
    }

    spec clear<K: drop, V: drop>(table: &mut SmartTable<K, V>) {
        pragma verify = false;
    }

    spec split_one_bucket<K, V>(table: &mut SmartTable<K, V>) {
        pragma verify = false;
    }

    spec bucket_index(level: u8, num_buckets: u64, hash: u64): u64 {
        pragma verify = false;
    }

    spec borrow_with_default<K: copy + drop, V>(table: &SmartTable<K, V>, key: K, default: &V): &V {
        pragma verify = false;
    }

    spec load_factor<K, V>(table: &SmartTable<K, V>): u64 {
        pragma verify = false;
    }

    spec to_simple_map<K: store + copy + drop, V: store + copy>(
    table: &SmartTable<K, V>,
    ): SimpleMap<K, V> {
        pragma verify = false;
    }

    spec keys<K: store + copy + drop, V: store + copy>(table_ref: &SmartTable<K, V>): vector<K> {
        pragma verify = false;
    }

    spec keys_paginated<K: store + copy + drop, V: store + copy>(
        table_ref: &SmartTable<K, V>,
        starting_bucket_index: u64,
        starting_vector_index: u64,
        num_keys_to_get: u64,
    ): (
        vector<K>,
        Option<u64>,
        Option<u64>,
    ) {
        pragma verify = false;
    }

    spec add_all<K, V>(table: &mut SmartTable<K, V>, keys: vector<K>, values: vector<V>) {
        pragma verify = false;
    }

    spec update_split_load_threshold<K, V>(table: &mut SmartTable<K, V>, split_load_threshold: u8) {
        pragma verify = false;
    }

    spec update_target_bucket_size<K, V>(table: &mut SmartTable<K, V>, target_bucket_size: u64) {
        pragma verify = false;
    }

    spec borrow_kv<K, V>(e: &Entry<K, V>): (&K, &V) {
        pragma verify = false;
    }

    spec borrow_kv_mut<K, V>(e: &mut Entry<K, V>): (&mut K, &mut V) {
        pragma verify = false;
    }

    spec num_buckets<K, V>(table: &SmartTable<K, V>): u64 {
        pragma verify = false;
    }

    spec borrow_buckets<K, V>(table: &SmartTable<K, V>): &TableWithLength<u64, vector<Entry<K, V>>> {
        pragma verify = false;
    }

    spec borrow_buckets_mut<K, V>(table: &mut SmartTable<K, V>): &mut TableWithLength<u64, vector<Entry<K, V>>> {
        pragma verify = false;
    }

    // Specification functions for tables
    spec native fun spec_len<K, V>(t: SmartTable<K, V>): num;
    spec native fun spec_contains<K, V>(t: SmartTable<K, V>, k: K): bool;
    spec native fun spec_set<K, V>(t: SmartTable<K, V>, k: K, v: V): SmartTable<K, V>;
    spec native fun spec_remove<K, V>(t: SmartTable<K, V>, k: K): SmartTable<K, V>;
    spec native fun spec_get<K, V>(t: SmartTable<K, V>, k: K): V;
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/data_structures/smart_vector.move
================================================
module aptos_std::smart_vector {
    use std::error;
    use std::vector;
    use aptos_std::big_vector::{Self, BigVector};
    use aptos_std::math64::max;
    use aptos_std::type_info::size_of_val;
    use std::option::{Self, Option};

    /// Vector index is out of bounds
    const EINDEX_OUT_OF_BOUNDS: u64 = 1;
    /// Cannot destroy a non-empty vector
    const EVECTOR_NOT_EMPTY: u64 = 2;
    /// Cannot pop back from an empty vector
    const EVECTOR_EMPTY: u64 = 3;
    /// bucket_size cannot be 0
    const EZERO_BUCKET_SIZE: u64 = 4;
    /// The length of the smart vectors are not equal.
    const ESMART_VECTORS_LENGTH_MISMATCH: u64 = 0x20005;

    /// A Scalable vector implementation based on tables, Ts are grouped into buckets with `bucket_size`.
    /// The option wrapping BigVector saves space in the metadata associated with BigVector when smart_vector is
    /// so small that inline_vec vector can hold all the data.
    struct SmartVector<T> has store {
        inline_vec: vector<T>,
        big_vec: Option<BigVector<T>>,
        inline_capacity: Option<u64>,
        bucket_size: Option<u64>,
    }

    /// Regular Vector API

    /// Create an empty vector using default logic to estimate `inline_capacity` and `bucket_size`, which may be
    /// inaccurate.
    /// This is exactly the same as empty() but is more standardized as all other data structures have new().
    public fun new<T: store>(): SmartVector<T> {
        empty()
    }

    #[deprecated]
    /// Create an empty vector using default logic to estimate `inline_capacity` and `bucket_size`, which may be
    /// inaccurate.
    public fun empty<T: store>(): SmartVector<T> {
        SmartVector {
            inline_vec: vector[],
            big_vec: option::none(),
            inline_capacity: option::none(),
            bucket_size: option::none(),
        }
    }

    /// Create an empty vector with customized config.
    /// When inline_capacity = 0, SmartVector degrades to a wrapper of BigVector.
    public fun empty_with_config<T: store>(inline_capacity: u64, bucket_size: u64): SmartVector<T> {
        assert!(bucket_size > 0, error::invalid_argument(EZERO_BUCKET_SIZE));
        SmartVector {
            inline_vec: vector[],
            big_vec: option::none(),
            inline_capacity: option::some(inline_capacity),
            bucket_size: option::some(bucket_size),
        }
    }

    /// Create a vector of length 1 containing the passed in T.
    public fun singleton<T: store>(element: T): SmartVector<T> {
        let v = empty();
        push_back(&mut v, element);
        v
    }

    /// Destroy the vector `v`.
    /// Aborts if `v` is not empty.
    public fun destroy_empty<T>(v: SmartVector<T>) {
        assert!(is_empty(&v), error::invalid_argument(EVECTOR_NOT_EMPTY));
        let SmartVector { inline_vec, big_vec, inline_capacity: _, bucket_size: _ } = v;
        vector::destroy_empty(inline_vec);
        option::destroy_none(big_vec);
    }

    /// Destroy a vector completely when T has `drop`.
    public fun destroy<T: drop>(v: SmartVector<T>) {
        clear(&mut v);
        destroy_empty(v);
    }

    /// Clear a vector completely when T has `drop`.
    public fun clear<T: drop>(v: &mut SmartVector<T>) {
        v.inline_vec = vector[];
        if (option::is_some(&v.big_vec)) {
            big_vector::destroy(option::extract(&mut v.big_vec));
        }
    }

    /// Acquire an immutable reference to the `i`th T of the vector `v`.
    /// Aborts if `i` is out of bounds.
    public fun borrow<T>(v: &SmartVector<T>, i: u64): &T {
        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        let inline_len = vector::length(&v.inline_vec);
        if (i < inline_len) {
            vector::borrow(&v.inline_vec, i)
        } else {
            big_vector::borrow(option::borrow(&v.big_vec), i - inline_len)
        }
    }

    /// Return a mutable reference to the `i`th T in the vector `v`.
    /// Aborts if `i` is out of bounds.
    public fun borrow_mut<T>(v: &mut SmartVector<T>, i: u64): &mut T {
        assert!(i < length(v), error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        let inline_len = vector::length(&v.inline_vec);
        if (i < inline_len) {
            vector::borrow_mut(&mut v.inline_vec, i)
        } else {
            big_vector::borrow_mut(option::borrow_mut(&mut v.big_vec), i - inline_len)
        }
    }

    /// Empty and destroy the other vector, and push each of the Ts in the other vector onto the lhs vector in the
    /// same order as they occurred in other.
    /// Disclaimer: This function may be costly. Use it at your own discretion.
    public fun append<T: store>(lhs: &mut SmartVector<T>, other: SmartVector<T>) {
        let other_len = length(&other);
        let half_other_len = other_len / 2;
        let i = 0;
        while (i < half_other_len) {
            push_back(lhs, swap_remove(&mut other, i));
            i = i + 1;
        };
        while (i < other_len) {
            push_back(lhs, pop_back(&mut other));
            i = i + 1;
        };
        destroy_empty(other);
    }

    /// Add multiple values to the vector at once.
    public fun add_all<T: store>(v: &mut SmartVector<T>, vals: vector<T>) {
        vector::for_each(vals, |val| { push_back(v, val); })
    }

    /// Convert a smart vector to a native vector, which is supposed to be called mostly by view functions to get an
    /// atomic view of the whole vector.
    /// Disclaimer: This function may be costly as the smart vector may be huge in size. Use it at your own discretion.
    public fun to_vector<T: store + copy>(v: &SmartVector<T>): vector<T> {
        let res = v.inline_vec;
        if (option::is_some(&v.big_vec)) {
            let big_vec = option::borrow(&v.big_vec);
            vector::append(&mut res, big_vector::to_vector(big_vec));
        };
        res
    }

    /// Add T `val` to the end of the vector `v`. It grows the buckets when the current buckets are full.
    /// This operation will cost more gas when it adds new bucket.
    public fun push_back<T: store>(v: &mut SmartVector<T>, val: T) {
        let len = length(v);
        let inline_len = vector::length(&v.inline_vec);
        if (len == inline_len) {
            let bucket_size = if (option::is_some(&v.inline_capacity)) {
                if (len < *option::borrow(&v.inline_capacity)) {
                    vector::push_back(&mut v.inline_vec, val);
                    return
                };
                *option::borrow(&v.bucket_size)
            } else {
                let val_size = size_of_val(&val);
                if (val_size * (inline_len + 1) < 150 /* magic number */) {
                    vector::push_back(&mut v.inline_vec, val);
                    return
                };
                let estimated_avg_size = max((size_of_val(&v.inline_vec) + val_size) / (inline_len + 1), 1);
                max(1024 /* free_write_quota */ / estimated_avg_size, 1)
            };
            option::fill(&mut v.big_vec, big_vector::empty(bucket_size));
        };
        big_vector::push_back(option::borrow_mut(&mut v.big_vec), val);
    }

    /// Pop an T from the end of vector `v`. It does shrink the buckets if they're empty.
    /// Aborts if `v` is empty.
    public fun pop_back<T>(v: &mut SmartVector<T>): T {
        assert!(!is_empty(v), error::invalid_state(EVECTOR_EMPTY));
        let big_vec_wrapper = &mut v.big_vec;
        if (option::is_some(big_vec_wrapper)) {
            let big_vec = option::extract(big_vec_wrapper);
            let val = big_vector::pop_back(&mut big_vec);
            if (big_vector::is_empty(&big_vec)) {
                big_vector::destroy_empty(big_vec)
            } else {
                option::fill(big_vec_wrapper, big_vec);
            };
            val
        } else {
            vector::pop_back(&mut v.inline_vec)
        }
    }

    /// Remove the T at index i in the vector v and return the owned value that was previously stored at i in v.
    /// All Ts occurring at indices greater than i will be shifted down by 1. Will abort if i is out of bounds.
    /// Disclaimer: This function may be costly. Use it at your own discretion.
    public fun remove<T>(v: &mut SmartVector<T>, i: u64): T {
        let len = length(v);
        assert!(i < len, error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        let inline_len = vector::length(&v.inline_vec);
        if (i < inline_len) {
            vector::remove(&mut v.inline_vec, i)
        } else {
            let big_vec_wrapper = &mut v.big_vec;
            let big_vec = option::extract(big_vec_wrapper);
            let val = big_vector::remove(&mut big_vec, i - inline_len);
            if (big_vector::is_empty(&big_vec)) {
                big_vector::destroy_empty(big_vec)
            } else {
                option::fill(big_vec_wrapper, big_vec);
            };
            val
        }
    }

    /// Swap the `i`th T of the vector `v` with the last T and then pop the vector.
    /// This is O(1), but does not preserve ordering of Ts in the vector.
    /// Aborts if `i` is out of bounds.
    public fun swap_remove<T>(v: &mut SmartVector<T>, i: u64): T {
        let len = length(v);
        assert!(i < len, error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        let inline_len = vector::length(&v.inline_vec);
        let big_vec_wrapper = &mut v.big_vec;
        let inline_vec = &mut v.inline_vec;
        if (i >= inline_len) {
            let big_vec = option::extract(big_vec_wrapper);
            let val = big_vector::swap_remove(&mut big_vec, i - inline_len);
            if (big_vector::is_empty(&big_vec)) {
                big_vector::destroy_empty(big_vec)
            } else {
                option::fill(big_vec_wrapper, big_vec);
            };
            val
        } else {
            if (inline_len < len) {
                let big_vec = option::extract(big_vec_wrapper);
                let last_from_big_vec = big_vector::pop_back(&mut big_vec);
                if (big_vector::is_empty(&big_vec)) {
                    big_vector::destroy_empty(big_vec)
                } else {
                    option::fill(big_vec_wrapper, big_vec);
                };
                vector::push_back(inline_vec, last_from_big_vec);
            };
            vector::swap_remove(inline_vec, i)
        }
    }

    /// Swap the Ts at the i'th and j'th indices in the vector v. Will abort if either of i or j are out of bounds
    /// for v.
    public fun swap<T: store>(v: &mut SmartVector<T>, i: u64, j: u64) {
        if (i > j) {
            return swap(v, j, i)
        };
        let len = length(v);
        assert!(j < len, error::invalid_argument(EINDEX_OUT_OF_BOUNDS));
        let inline_len = vector::length(&v.inline_vec);
        if (i >= inline_len) {
            big_vector::swap(option::borrow_mut(&mut v.big_vec), i - inline_len, j - inline_len);
        } else if (j < inline_len) {
            vector::swap(&mut v.inline_vec, i, j);
        } else {
            let big_vec = option::borrow_mut(&mut v.big_vec);
            let inline_vec = &mut v.inline_vec;
            let element_i = vector::swap_remove(inline_vec, i);
            let element_j = big_vector::swap_remove(big_vec, j - inline_len);
            vector::push_back(inline_vec, element_j);
            vector::swap(inline_vec, i, inline_len - 1);
            big_vector::push_back(big_vec, element_i);
            big_vector::swap(big_vec, j - inline_len, len - inline_len - 1);
        }
    }

    /// Reverse the order of the Ts in the vector v in-place.
    /// Disclaimer: This function may be costly. Use it at your own discretion.
    public fun reverse<T: store>(v: &mut SmartVector<T>) {
        let inline_len = vector::length(&v.inline_vec);
        let i = 0;
        let new_inline_vec = vector[];
        // Push the last `inline_len` Ts into a temp vector.
        while (i < inline_len) {
            vector::push_back(&mut new_inline_vec, pop_back(v));
            i = i + 1;
        };
        vector::reverse(&mut new_inline_vec);
        // Reverse the big_vector left if exists.
        if (option::is_some(&v.big_vec)) {
            big_vector::reverse(option::borrow_mut(&mut v.big_vec));
        };
        // Mem::swap the two vectors.
        let temp_vec = vector[];
        while (!vector::is_empty(&mut v.inline_vec)) {
            vector::push_back(&mut temp_vec, vector::pop_back(&mut v.inline_vec));
        };
        vector::reverse(&mut temp_vec);
        while (!vector::is_empty(&mut new_inline_vec)) {
            vector::push_back(&mut v.inline_vec, vector::pop_back(&mut new_inline_vec));
        };
        vector::destroy_empty(new_inline_vec);
        // Push the rest Ts originally left in inline_vector back to the end of the smart vector.
        while (!vector::is_empty(&mut temp_vec)) {
            push_back(v, vector::pop_back(&mut temp_vec));
        };
        vector::destroy_empty(temp_vec);
    }

    /// Return `(true, i)` if `val` is in the vector `v` at index `i`.
    /// Otherwise, returns `(false, 0)`.
    /// Disclaimer: This function may be costly. Use it at your own discretion.
    public fun index_of<T>(v: &SmartVector<T>, val: &T): (bool, u64) {
        let (found, i) = vector::index_of(&v.inline_vec, val);
        if (found) {
            (true, i)
        } else if (option::is_some(&v.big_vec)) {
            let (found, i) = big_vector::index_of(option::borrow(&v.big_vec), val);
            (found, i + vector::length(&v.inline_vec))
        } else {
            (false, 0)
        }
    }

    /// Return true if `val` is in the vector `v`.
    /// Disclaimer: This function may be costly. Use it at your own discretion.
    public fun contains<T>(v: &SmartVector<T>, val: &T): bool {
        if (is_empty(v)) return false;
        let (exist, _) = index_of(v, val);
        exist
    }

    /// Return the length of the vector.
    public fun length<T>(v: &SmartVector<T>): u64 {
        vector::length(&v.inline_vec) + if (option::is_none(&v.big_vec)) {
            0
        } else {
            big_vector::length(option::borrow(&v.big_vec))
        }
    }

    /// Return `true` if the vector `v` has no Ts and `false` otherwise.
    public fun is_empty<T>(v: &SmartVector<T>): bool {
        length(v) == 0
    }

    /// Apply the function to each T in the vector, consuming it.
    public inline fun for_each<T: store>(v: SmartVector<T>, f: |T|) {
        aptos_std::smart_vector::reverse(&mut v); // We need to reverse the vector to consume it efficiently
        aptos_std::smart_vector::for_each_reverse(v, |e| f(e));
    }

    /// Apply the function to each T in the vector, consuming it.
    public inline fun for_each_reverse<T>(v: SmartVector<T>, f: |T|) {
        let len = aptos_std::smart_vector::length(&v);
        while (len > 0) {
            f(aptos_std::smart_vector::pop_back(&mut v));
            len = len - 1;
        };
        aptos_std::smart_vector::destroy_empty(v)
    }

    /// Apply the function to a reference of each T in the vector.
    public inline fun for_each_ref<T>(v: &SmartVector<T>, f: |&T|) {
        let i = 0;
        let len = aptos_std::smart_vector::length(v);
        while (i < len) {
            f(aptos_std::smart_vector::borrow(v, i));
            i = i + 1
        }
    }

    /// Apply the function to a mutable reference to each T in the vector.
    public inline fun for_each_mut<T>(v: &mut SmartVector<T>, f: |&mut T|) {
        let i = 0;
        let len = aptos_std::smart_vector::length(v);
        while (i < len) {
            f(aptos_std::smart_vector::borrow_mut(v, i));
            i = i + 1
        }
    }

    /// Apply the function to a reference of each T in the vector with its index.
    public inline fun enumerate_ref<T>(v: &SmartVector<T>, f: |u64, &T|) {
        let i = 0;
        let len = aptos_std::smart_vector::length(v);
        while (i < len) {
            f(i, aptos_std::smart_vector::borrow(v, i));
            i = i + 1;
        };
    }

    /// Apply the function to a mutable reference of each T in the vector with its index.
    public inline fun enumerate_mut<T>(v: &mut SmartVector<T>, f: |u64, &mut T|) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            f(i, borrow_mut(v, i));
            i = i + 1;
        };
    }

    /// Fold the function over the Ts. For example, `fold(vector[1,2,3], 0, f)` will execute
    /// `f(f(f(0, 1), 2), 3)`
    public inline fun fold<Accumulator, T: store>(
        v: SmartVector<T>,
        init: Accumulator,
        f: |Accumulator, T|Accumulator
    ): Accumulator {
        let accu = init;
        aptos_std::smart_vector::for_each(v, |elem| accu = f(accu, elem));
        accu
    }

    /// Fold right like fold above but working right to left. For example, `fold(vector[1,2,3], 0, f)` will execute
    /// `f(1, f(2, f(3, 0)))`
    public inline fun foldr<Accumulator, T>(
        v: SmartVector<T>,
        init: Accumulator,
        f: |T, Accumulator|Accumulator
    ): Accumulator {
        let accu = init;
        aptos_std::smart_vector::for_each_reverse(v, |elem| accu = f(elem, accu));
        accu
    }

    /// Map the function over the references of the Ts of the vector, producing a new vector without modifying the
    /// original vector.
    public inline fun map_ref<T1, T2: store>(
        v: &SmartVector<T1>,
        f: |&T1|T2
    ): SmartVector<T2> {
        let result = aptos_std::smart_vector::new<T2>();
        aptos_std::smart_vector::for_each_ref(v, |elem| aptos_std::smart_vector::push_back(&mut result, f(elem)));
        result
    }

    /// Map the function over the Ts of the vector, producing a new vector.
    public inline fun map<T1: store, T2: store>(
        v: SmartVector<T1>,
        f: |T1|T2
    ): SmartVector<T2> {
        let result = aptos_std::smart_vector::new<T2>();
        aptos_std::smart_vector::for_each(v, |elem| push_back(&mut result, f(elem)));
        result
    }

    /// Filter the vector using the boolean function, removing all Ts for which `p(e)` is not true.
    public inline fun filter<T: store + drop>(
        v: SmartVector<T>,
        p: |&T|bool
    ): SmartVector<T> {
        let result = aptos_std::smart_vector::new<T>();
        aptos_std::smart_vector::for_each(v, |elem| {
            if (p(&elem)) aptos_std::smart_vector::push_back(&mut result, elem);
        });
        result
    }

    public inline fun zip<T1: store, T2: store>(v1: SmartVector<T1>, v2: SmartVector<T2>, f: |T1, T2|) {
        // We need to reverse the vectors to consume it efficiently
        aptos_std::smart_vector::reverse(&mut v1);
        aptos_std::smart_vector::reverse(&mut v2);
        aptos_std::smart_vector::zip_reverse(v1, v2, |e1, e2| f(e1, e2));
    }

    /// Apply the function to each pair of elements in the two given vectors in the reverse order, consuming them.
    /// This errors out if the vectors are not of the same length.
    public inline fun zip_reverse<T1, T2>(
        v1: SmartVector<T1>,
        v2: SmartVector<T2>,
        f: |T1, T2|,
    ) {
        let len = aptos_std::smart_vector::length(&v1);
        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(len == aptos_std::smart_vector::length(&v2), 0x20005);
        while (len > 0) {
            f(aptos_std::smart_vector::pop_back(&mut v1), aptos_std::smart_vector::pop_back(&mut v2));
            len = len - 1;
        };
        aptos_std::smart_vector::destroy_empty(v1);
        aptos_std::smart_vector::destroy_empty(v2);
    }

    /// Apply the function to the references of each pair of elements in the two given vectors.
    /// This errors out if the vectors are not of the same length.
    public inline fun zip_ref<T1, T2>(
        v1: &SmartVector<T1>,
        v2: &SmartVector<T2>,
        f: |&T1, &T2|,
    ) {
        let len = aptos_std::smart_vector::length(v1);
        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(len == aptos_std::smart_vector::length(v2), 0x20005);
        let i = 0;
        while (i < len) {
            f(aptos_std::smart_vector::borrow(v1, i), aptos_std::smart_vector::borrow(v2, i));
            i = i + 1
        }
    }

    /// Apply the function to mutable references to each pair of elements in the two given vectors.
    /// This errors out if the vectors are not of the same length.
    public inline fun zip_mut<T1, T2>(
        v1: &mut SmartVector<T1>,
        v2: &mut SmartVector<T2>,
        f: |&mut T1, &mut T2|,
    ) {
        let i = 0;
        let len = aptos_std::smart_vector::length(v1);
        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(len == aptos_std::smart_vector::length(v2), 0x20005);
        while (i < len) {
            f(aptos_std::smart_vector::borrow_mut(v1, i), aptos_std::smart_vector::borrow_mut(v2, i));
            i = i + 1
        }
    }

    /// Map the function over the element pairs of the two vectors, producing a new vector.
    public inline fun zip_map<T1: store, T2: store, NewT: store>(
        v1: SmartVector<T1>,
        v2: SmartVector<T2>,
        f: |T1, T2|NewT
    ): SmartVector<NewT> {
        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(aptos_std::smart_vector::length(&v1) == aptos_std::smart_vector::length(&v2), 0x20005);

        let result = aptos_std::smart_vector::new<NewT>();
        aptos_std::smart_vector::zip(v1, v2, |e1, e2| push_back(&mut result, f(e1, e2)));
        result
    }

    /// Map the function over the references of the element pairs of two vectors, producing a new vector from the return
    /// values without modifying the original vectors.
    public inline fun zip_map_ref<T1, T2, NewT: store>(
        v1: &SmartVector<T1>,
        v2: &SmartVector<T2>,
        f: |&T1, &T2|NewT
    ): SmartVector<NewT> {
        // We can't use the constant ESMART_VECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(aptos_std::smart_vector::length(v1) == aptos_std::smart_vector::length(v2), 0x20005);

        let result = aptos_std::smart_vector::new<NewT>();
        aptos_std::smart_vector::zip_ref(v1, v2, |e1, e2| push_back(&mut result, f(e1, e2)));
        result
    }

    #[test]
    fun smart_vector_test() {
        let v = empty();
        let i = 0;
        while (i < 100) {
            push_back(&mut v, i);
            i = i + 1;
        };
        let j = 0;
        while (j < 100) {
            let val = borrow(&v, j);
            assert!(*val == j, 0);
            j = j + 1;
        };
        while (i > 0) {
            i = i - 1;
            let (exist, index) = index_of(&v, &i);
            let j = pop_back(&mut v);
            assert!(exist, 0);
            assert!(index == i, 0);
            assert!(j == i, 0);
        };
        while (i < 100) {
            push_back(&mut v, i);
            i = i + 1;
        };
        let last_index = length(&v) - 1;
        assert!(swap_remove(&mut v, last_index) == 99, 0);
        assert!(swap_remove(&mut v, 0) == 0, 0);
        while (length(&v) > 0) {
            // the vector is always [N, 1, 2, ... N-1] with repetitive swap_remove(&mut v, 0)
            let expected = length(&v);
            let val = swap_remove(&mut v, 0);
            assert!(val == expected, 0);
        };
        destroy_empty(v);
    }

    #[test]
    fun smart_vector_append_edge_case_test() {
        let v1 = empty();
        let v2 = singleton(1u64);
        let v3 = empty();
        let v4 = empty();
        append(&mut v3, v4);
        assert!(length(&v3) == 0, 0);
        append(&mut v2, v3);
        assert!(length(&v2) == 1, 0);
        append(&mut v1, v2);
        assert!(length(&v1) == 1, 0);
        destroy(v1);
    }

    #[test]
    fun smart_vector_append_test() {
        let v1 = empty();
        let v2 = empty();
        let i = 0;
        while (i < 7) {
            push_back(&mut v1, i);
            i = i + 1;
        };
        while (i < 25) {
            push_back(&mut v2, i);
            i = i + 1;
        };
        append(&mut v1, v2);
        assert!(length(&v1) == 25, 0);
        i = 0;
        while (i < 25) {
            assert!(*borrow(&v1, i) == i, 0);
            i = i + 1;
        };
        destroy(v1);
    }

    #[test]
    fun smart_vector_remove_test() {
        let v = empty();
        let i = 0u64;
        while (i < 101) {
            push_back(&mut v, i);
            i = i + 1;
        };
        let inline_len = vector::length(&v.inline_vec);
        remove(&mut v, 100);
        remove(&mut v, 90);
        remove(&mut v, 80);
        remove(&mut v, 70);
        remove(&mut v, 60);
        remove(&mut v, 50);
        remove(&mut v, 40);
        remove(&mut v, 30);
        remove(&mut v, 20);
        assert!(vector::length(&v.inline_vec) == inline_len, 0);
        remove(&mut v, 10);
        assert!(vector::length(&v.inline_vec) + 1 == inline_len, 0);
        remove(&mut v, 0);
        assert!(vector::length(&v.inline_vec) + 2 == inline_len, 0);
        assert!(length(&v) == 90, 0);

        let index = 0;
        i = 0;
        while (i < 101) {
            if (i % 10 != 0) {
                assert!(*borrow(&v, index) == i, 0);
                index = index + 1;
            };
            i = i + 1;
        };
        destroy(v);
    }

    #[test]
    fun smart_vector_reverse_test() {
        let v = empty();
        let i = 0u64;
        while (i < 10) {
            push_back(&mut v, i);
            i = i + 1;
        };
        reverse(&mut v);
        let k = 0;
        while (k < 10) {
            assert!(*vector::borrow(&v.inline_vec, k) == 9 - k, 0);
            k = k + 1;
        };
        while (i < 100) {
            push_back(&mut v, i);
            i = i + 1;
        };
        while (!vector::is_empty(&v.inline_vec)) {
            remove(&mut v, 0);
        };
        reverse(&mut v);
        i = 0;
        let len = length(&v);
        while (i + 1 < len) {
            assert!(
                *big_vector::borrow(option::borrow(&v.big_vec), i) == *big_vector::borrow(
                    option::borrow(&v.big_vec),
                    i + 1
                ) + 1,
                0
            );
            i = i + 1;
        };
        destroy(v);
    }

    #[test]
    fun smart_vector_add_all_test() {
        let v = empty_with_config(1, 2);
        add_all(&mut v, vector[1, 2, 3, 4, 5, 6]);
        assert!(length(&v) == 6, 0);
        let i = 0;
        while (i < 6) {
            assert!(*borrow(&v, i) == i + 1, 0);
            i = i + 1;
        };
        destroy(v);
    }

    #[test]
    fun smart_vector_to_vector_test() {
        let v1 = empty_with_config(7, 11);
        let i = 0;
        while (i < 100) {
            push_back(&mut v1, i);
            i = i + 1;
        };
        let v2 = to_vector(&v1);
        let j = 0;
        while (j < 100) {
            assert!(*vector::borrow(&v2, j) == j, 0);
            j = j + 1;
        };
        destroy(v1);
    }

    #[test]
    fun smart_vector_swap_test() {
        let v = empty();
        let i = 0;
        while (i < 101) {
            push_back(&mut v, i);
            i = i + 1;
        };
        i = 0;
        while (i < 51) {
            swap(&mut v, i, 100 - i);
            i = i + 1;
        };
        i = 0;
        while (i < 101) {
            assert!(*borrow(&v, i) == 100 - i, 0);
            i = i + 1;
        };
        destroy(v);
    }

    #[test]
    fun smart_vector_index_of_test() {
        let v = empty();
        let i = 0;
        while (i < 100) {
            push_back(&mut v, i);
            let (found, idx) = index_of(&mut v, &i);
            assert!(found && idx == i, 0);
            i = i + 1;
        };
        destroy(v);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/data_structures/smart_vector.spec.move
================================================
spec aptos_std::smart_vector {

    spec SmartVector {
        // `bucket_size` shouldn't be 0, if specified.
        invariant option::is_none(bucket_size)
            || (option::is_some(bucket_size) && option::borrow(bucket_size) != 0);
        // vector length should be <= `inline_capacity`, if specified.
        invariant option::is_none(inline_capacity)
            || (len(inline_vec) <= option::borrow(inline_capacity));
        // both `inline_capacity` and `bucket_size` should either exist or shouldn't exist at all.
        invariant (option::is_none(inline_capacity) && option::is_none(bucket_size))
            || (option::is_some(inline_capacity) && option::is_some(bucket_size));
    }

    spec length {
        aborts_if option::is_some(v.big_vec) && len(v.inline_vec) + big_vector::length(option::spec_borrow(v.big_vec)) > MAX_U64;
    }

    spec empty {
        aborts_if false;
    }

    spec empty_with_config {
        aborts_if bucket_size == 0;
    }

    spec destroy_empty {
        aborts_if !(is_empty(v));
        aborts_if len(v.inline_vec) != 0
            || option::is_some(v.big_vec);
    }

    spec borrow {
        aborts_if i >= length(v);
        aborts_if option::is_some(v.big_vec) && (
            (len(v.inline_vec) + big_vector::length<T>(option::borrow(v.big_vec))) > MAX_U64
        );
    }

    spec push_back<T: store>(v: &mut SmartVector<T>, val: T) {
        // use aptos_std::big_vector;
        // use aptos_std::type_info;
        pragma verify = false; // TODO: set to false because of timeout
        // pragma aborts_if_is_partial;
        // let pre_length = length(v);
        // let pre_inline_len = len(v.inline_vec);
        // let pre_big_vec = option::spec_borrow(v.big_vec);
        // let post post_big_vec = option::spec_borrow(v.big_vec);
        // let size_val = type_info::spec_size_of_val(val);
        // include pre_length != pre_inline_len ==> big_vector::PushbackAbortsIf<T> {
        //     v: pre_big_vec
        // };
        // aborts_if pre_length == pre_inline_len && option::is_none(v.inline_capacity) && (pre_length + 1) > MAX_U64;
        // aborts_if pre_length == pre_inline_len && option::is_none(v.inline_capacity) && size_val * (pre_length + 1) > MAX_U64;
        // aborts_if pre_length == pre_inline_len && option::is_none(v.inline_capacity) && size_val * (pre_length + 1) >= 150 && size_val + type_info::spec_size_of_val(v.inline_vec) > MAX_U64;
        // aborts_if option::is_some(v.big_vec) && len(v.inline_vec) + big_vector::length(option::spec_borrow(v.big_vec)) > MAX_U64;
        // aborts_if pre_length == pre_inline_len && option::is_none(v.inline_capacity) && size_val * (pre_length + 1) >= 150 && option::is_some(v.big_vec);
        // aborts_if pre_length == pre_inline_len && option::is_some(v.inline_capacity) && pre_length >= option::spec_borrow(v.inline_capacity) && option::is_some(v.big_vec);
        // ensures pre_length != pre_inline_len ==> option::is_some(v.big_vec);
        // ensures pre_length != pre_inline_len ==> big_vector::spec_at(post_big_vec, post_big_vec.end_index-1) == val;
    }

    spec pop_back {
        use aptos_std::table_with_length;

        pragma verify_duration_estimate = 120; // TODO: set because of timeout (property proved)

        aborts_if  option::is_some(v.big_vec)
            &&
            (table_with_length::spec_len(option::borrow(v.big_vec).buckets) == 0);
        aborts_if is_empty(v);
        aborts_if option::is_some(v.big_vec) && (
            (len(v.inline_vec) + big_vector::length<T>(option::borrow(v.big_vec))) > MAX_U64
        );

        ensures length(v) == length(old(v)) - 1;
    }

    spec swap_remove {
        pragma verify = false; // TODO: set because of timeout
        aborts_if i >= length(v);
        aborts_if option::is_some(v.big_vec) && (
            (len(v.inline_vec) + big_vector::length<T>(option::borrow(v.big_vec))) > MAX_U64
        );
        ensures length(v) == length(old(v)) - 1;
    }

    spec swap {
        // TODO: temporarily mocked up.
        pragma verify = false;
    }

    spec append {
        pragma verify = false;
    }

    spec remove {
        pragma verify = false;
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/data_structures/tests/smart_table_test.move
================================================
#[test_only]
module aptos_std::smart_table_test {
    use aptos_std::smart_table::{Self, SmartTable};

    #[test_only]
    public fun make_smart_table(): SmartTable<u64, u64> {
        let table = smart_table::new_with_config<u64, u64>(0, 50, 10);
        let i = 0u64;
        while (i < 100) {
            smart_table::add(&mut table, i, i);
            i = i + 1;
        };
        table
    }

    #[test]
    public fun smart_table_for_each_ref_test() {
        let t = make_smart_table();
        let s = 0;
        smart_table::for_each_ref(&t, |x, y| {
            s = s + *x + *y;
        });
        assert!(s == 9900, 0);
        smart_table::destroy(t);
    }

    #[test]
    public fun smart_table_for_each_mut_test() {
        let t = make_smart_table();
        smart_table::for_each_mut(&mut t, |_key, val| {
            let val: &mut u64 = val;
            *val = *val + 1
        });
        smart_table::for_each_ref(&t, |key, val| {
            assert!(*key + 1 == *val, *key);
        });
        smart_table::destroy(t);
    }

    #[test]
    public fun smart_table_test_map_ref_test() {
        let t = make_smart_table();
        let r = smart_table::map_ref(&t, |val| *val + 1);
        smart_table::for_each_ref(&r, |key, val| {
            assert!(*key + 1 == *val, *key);
        });
        smart_table::destroy(t);
        smart_table::destroy(r);
    }

    #[test]
    public fun smart_table_any_test() {
        let t = make_smart_table();
        let r = smart_table::any(&t, |_k, v| *v >= 99);
        assert!(r, 0);
        smart_table::destroy(t);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/sources/data_structures/tests/smart_vector_test.move
================================================
#[test_only]
module aptos_std::smart_vector_test {
    use aptos_std::smart_vector as V;
    use aptos_std::smart_vector::SmartVector;

    #[test_only]
    fun make_smart_vector(k: u64): SmartVector<u64> {
        let v = V::new<u64>();
        let i = 1u64;
        while (i <= k) {
            V::push_back(&mut v, i);
            i = i + 1;
        };
        v
    }

    #[test]
    fun smart_vector_for_each_test() {
        let v = make_smart_vector(100);
        let i = 0;
        V::for_each(v, |x| {
            assert!(i + 1 == x, 0);
            i = i + 1;
        });
    }

    #[test]
    fun smart_vector_for_each_reverse_test() {
        let v = make_smart_vector(100);
        let i = 0;
        V::for_each_reverse(v, |x| {
            assert!(i == 100 - x, 0);
            i = i + 1;
        });
    }

    #[test]
    fun smart_vector_for_each_ref_test() {
        let v = make_smart_vector(100);
        let s = 0;
        V::for_each_ref(&v, |x| {
            s = s + *x;
        });
        assert!(s == 5050, 0);
        V::destroy(v);
    }

    #[test]
    fun smart_vector_for_each_mut_test() {
        let v = make_smart_vector(100);
        V::for_each_mut(&mut v, |x| {
            let x: &mut u64 = x;
            *x = *x + 1;
        });
        assert!(V::fold(v, 0, |s, x| {
            s + x
        }) == 5150, 0);
    }

    #[test]
    fun smart_vector_enumerate_ref_test() {
        let v = make_smart_vector(100);
        V::enumerate_ref(&v, |i, x| {
            assert!(i + 1 == *x, 0);
        });
        V::destroy(v);
    }

    #[test]
    fun smart_vector_enumerate_mut_test() {
        let v = make_smart_vector(100);
        V::enumerate_mut(&mut v, |i, x| {
            let x: &mut u64 = x;
            assert!(i + 1 == *x, 0);
            *x = *x + 1;
        });
        assert!(V::fold(v, 0, |s, x| {
            s + x
        }) == 5150, 0);
    }

    #[test]
    fun smart_vector_fold_test() {
        let v = make_smart_vector(100);
        let i = 0;
        let sum = V::fold(v, 0, |s, x| {
            assert!(i + 1 == x, 0);
            i = i + 1;
            s + x
        });
        assert!(sum == 5050, 0);
    }

    #[test]
    fun smart_vector_for_foldr_test() {
        let v = make_smart_vector(100);
        let i = 0;
        let sum = V::foldr(v, 0, |x, s| {
            assert!(i == 100 - x, i);
            i = i + 1;
            s + x
        });
        assert!(sum == 5050, 0);
    }

    #[test]
    fun smart_vector_map_test() {
        let v = make_smart_vector(100);
        let mapped_v = V::map(v, |x| { x * 2 });
        let sum = V::fold(mapped_v, 0, |s, x| {
            s + x
        });
        assert!(sum == 10100, 0);
    }

    #[test]
    fun smart_vector_map_ref_test() {
        let v = make_smart_vector(100);
        let mapped_v = V::map_ref(&v, |x|  *x * 2);
        assert!(V::fold(v, 0, |s, x| {
            s + x
        }) == 5050, 0);
        assert!(V::fold(mapped_v, 0, |s, x| {
            s + x
        }) == 10100, 0);
    }

    #[test]
    fun smart_vector_filter_test() {
        let v = make_smart_vector(100);
        let filtered_v = V::filter(v, |x| *x % 10 == 0);
        V::enumerate_ref(&filtered_v, |i, x| {
            assert!((i + 1) * 10 == *x, 0);
        });
        V::destroy(filtered_v);
    }

    #[test]
    fun smart_vector_test_zip() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(100);
        let s = 0;
        V::zip(v1, v2, |e1, e2| {
            let e1: u64 = e1;
            let e2: u64 = e2;
            s = s + e1 / e2
        });
        assert!(s == 100, 0);
    }

    #[test]
    // zip is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::ESMART_VECTORS_LENGTH_MISMATCH, location = Self)]
    fun smart_vector_test_zip_mismatching_lengths_should_fail() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(99);
        let s = 0;
        V::zip(v1, v2, |e1, e2| {
            let e1: u64 = e1;
            let e2: u64 = e2;
            s = s + e1 / e2
        });
    }

    #[test]
    fun smart_vector_test_zip_ref() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(100);
        let s = 0;
        V::zip_ref(&v1, &v2, |e1, e2| s = s + *e1 / *e2);
        assert!(s == 100, 0);
        V::destroy(v1);
        V::destroy(v2);
    }

    #[test]
    // zip_ref is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::ESMART_VECTORS_LENGTH_MISMATCH, location = Self)]
    fun smart_vector_test_zip_ref_mismatching_lengths_should_fail() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(99);
        let s = 0;
        V::zip_ref(&v1, &v2, |e1, e2| s = s + *e1 / *e2);
        V::destroy(v1);
        V::destroy(v2);
    }

    #[test]
    fun smart_vector_test_zip_mut() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(100);
        V::zip_mut(&mut v1, &mut v2, |e1, e2| {
            let e1: &mut u64 = e1;
            let e2: &mut u64 = e2;
            *e1 = *e1 + 1;
            *e2 = *e2 - 1;
        });
        V::zip_ref(&v1, &v2, |e1, e2| assert!(*e1 == *e2 + 2, 0));
        V::destroy(v1);
        V::destroy(v2);
    }

    #[test]
    fun smart_vector_test_zip_map() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(100);
        let result = V::zip_map(v1, v2, |e1, e2| e1 / e2);
        V::for_each(result, |v| assert!(v == 1, 0));
    }

    #[test]
    fun smart_vector_test_zip_map_ref() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(100);
        let result = V::zip_map_ref(&v1, &v2, |e1, e2| *e1 / *e2);
        V::for_each(result, |v| assert!(v == 1, 0));
        V::destroy(v1);
        V::destroy(v2);
    }

    #[test]
    // zip_mut is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::ESMART_VECTORS_LENGTH_MISMATCH, location = Self)]
    fun smart_vector_test_zip_mut_mismatching_lengths_should_fail() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(99);
        let s = 0;
        V::zip_mut(&mut v1, &mut v2, |e1, e2| s = s + *e1 / *e2);
        V::destroy(v1);
        V::destroy(v2);
    }

    #[test]
    // zip_map is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::ESMART_VECTORS_LENGTH_MISMATCH, location = Self)]
    fun smart_vector_test_zip_map_mismatching_lengths_should_fail() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(99);
        V::destroy(V::zip_map(v1, v2, |e1, e2| e1 / e2));
    }

    #[test]
    // zip_map_ref is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::ESMART_VECTORS_LENGTH_MISMATCH, location = Self)]
    fun smart_vector_test_zip_map_ref_mismatching_lengths_should_fail() {
        let v1 = make_smart_vector(100);
        let v2 = make_smart_vector(99);
        V::destroy(V::zip_map_ref(&v1, &v2, |e1, e2| *e1 / *e2));
        V::destroy(v1);
        V::destroy(v2);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/tests/fixedpoint64_tests.move
================================================
#[test_only]
module aptos_std::fixed_point64_tests {
    use aptos_std::fixed_point64;

    const POW2_64: u128 = 1 << 64;
    const MAX_U128: u128 = 340282366920938463463374607431768211455;

    #[test]
    #[expected_failure(abort_code = fixed_point64::EDENOMINATOR)]
    fun create_div_zero() {
        // A denominator of zero should cause an arithmetic error.
        fixed_point64::create_from_rational(2, 0);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point64::ERATIO_OUT_OF_RANGE)]
    fun create_overflow() {
        // The maximum value is 2^32 - 1. Check that anything larger aborts
        // with an overflow.
        fixed_point64::create_from_rational(POW2_64, 1); // 2^64
    }

    #[test]
    #[expected_failure(abort_code = fixed_point64::ERATIO_OUT_OF_RANGE)]
    fun create_underflow() {
        // The minimum non-zero value is 2^-32. Check that anything smaller
        // aborts.
        fixed_point64::create_from_rational(1, 2 * POW2_64); // 2^-65
    }

    #[test]
    fun create_zero() {
        let x = fixed_point64::create_from_rational(0, 1);
        assert!(fixed_point64::is_zero(x), 0);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point64::EDIVISION_BY_ZERO)]
    fun divide_by_zero() {
        // Dividing by zero should cause an arithmetic error.
        let f = fixed_point64::create_from_raw_value(0);
        fixed_point64::divide_u128(1, f);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point64::EDIVISION)]
    fun divide_overflow_small_divisore() {
        let f = fixed_point64::create_from_raw_value(1); // 2^-64
        // Divide 2^64 by the minimum fractional value. This should overflow.
        fixed_point64::divide_u128(POW2_64, f);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point64::EDIVISION)]
    fun divide_overflow_large_numerator() {
        let f = fixed_point64::create_from_rational(1, 2); // 0.5
        // Divide the maximum u128 value by 0.5. This should overflow.
        fixed_point64::divide_u128(MAX_U128, f);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point64::EMULTIPLICATION)]
    fun multiply_overflow_small_multiplier() {
        let f = fixed_point64::create_from_rational(3, 2); // 1.5
        // Multiply the maximum u64 value by 1.5. This should overflow.
        fixed_point64::multiply_u128(MAX_U128, f);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point64::EMULTIPLICATION)]
    fun multiply_overflow_large_multiplier() {
        let f = fixed_point64::create_from_raw_value(MAX_U128);
        // Multiply 2^65 by the maximum fixed-point value. This should overflow.
        fixed_point64::multiply_u128(2 * POW2_64, f);
    }

    #[test]
    fun exact_multiply() {
        let f = fixed_point64::create_from_rational(3, 4); // 0.75
        let nine = fixed_point64::multiply_u128(12, f); // 12 * 0.75
        assert!(nine == 9, 0);
    }

    #[test]
    fun exact_divide() {
        let f = fixed_point64::create_from_rational(3, 4); // 0.75
        let twelve = fixed_point64::divide_u128(9, f); // 9 / 0.75
        assert!(twelve == 12, 0);
    }

    #[test]
    fun multiply_truncates() {
        let f = fixed_point64::create_from_rational(1, 3); // 0.333...
        let not_three = fixed_point64::multiply_u128(9, copy f); // 9 * 0.333...
        // multiply_u128 does NOT round -- it truncates -- so values that
        // are not perfectly representable in binary may be off by one.
        assert!(not_three == 2, 0);

        // Try again with a fraction slightly larger than 1/3.
        let f = fixed_point64::create_from_raw_value(fixed_point64::get_raw_value(f) + 1);
        let three = fixed_point64::multiply_u128(9, f);
        assert!(three == 3, 1);
    }

    #[test]
    fun create_from_rational_max_numerator_denominator() {
        // Test creating a 1.0 fraction from the maximum u64 value.
        let f = fixed_point64::create_from_rational(MAX_U128, MAX_U128);
        let one = fixed_point64::get_raw_value(f);
        assert!(one == POW2_64, 0); // 0x1.00000000
    }

    #[test]
    fun min_can_return_smaller_fixed_point_number() {
        let one = fixed_point64::create_from_rational(1, 1);
        let two = fixed_point64::create_from_rational(2, 1);
        let smaller_number1 = fixed_point64::min(one, two);
        let val1 = fixed_point64::get_raw_value(smaller_number1);
        assert!(val1 == POW2_64, 0);  // 0x1.00000000
        let smaller_number2 = fixed_point64::min(two, one);
        let val2 = fixed_point64::get_raw_value(smaller_number2);
        assert!(val2 == POW2_64, 0);  // 0x1.00000000
    }

    #[test]
    fun max_can_return_larger_fixed_point_number() {
        let one = fixed_point64::create_from_rational(1, 1);
        let two = fixed_point64::create_from_rational(2, 1);
        let larger_number1 = fixed_point64::max(one, two);
        let larger_number2 = fixed_point64::max(two, one);
        let val1 = fixed_point64::get_raw_value(larger_number1);
        assert!(val1 == 2 * POW2_64, 0);  // 0x2.00000000
        let val2 = fixed_point64::get_raw_value(larger_number2);
        assert!(val2 == 2 * POW2_64, 0);  // 0x2.00000000
    }

    #[test]
    fun floor_can_return_the_correct_number_zero() {
        let point_five = fixed_point64::create_from_rational(1, 2);
        let val = fixed_point64::floor(point_five);
        assert!(val == 0, 0);
    }

    #[test]
    fun create_from_u128_create_correct_fixed_point_number() {
        let one = fixed_point64::create_from_u128(1);
        let val = fixed_point64::get_raw_value(one);
        assert!(val == POW2_64, 0);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point64::ERATIO_OUT_OF_RANGE)]
    fun create_from_u128_throw_error_when_number_too_large() {
        fixed_point64::create_from_u128(POW2_64);
    }

    #[test]
    fun floor_can_return_the_correct_number_one() {
        let three_point_five = fixed_point64::create_from_rational(7, 2); // 3.5
        let val = fixed_point64::floor(three_point_five);
        assert!(val == 3, 0);
    }

    #[test]
    fun ceil_can_round_up_correctly() {
        let point_five = fixed_point64::create_from_rational(1, 2); // 0.5
        let val = fixed_point64::ceil(point_five);
        assert!(val == 1, 0);
    }

    #[test]
    fun ceil_will_not_change_if_number_already_integer() {
        let one = fixed_point64::create_from_rational(1, 1); // 0.5
        let val = fixed_point64::ceil(one);
        assert!(val == 1, 0);
    }

    #[test]
    fun round_can_round_up_correctly() {
        let point_five = fixed_point64::create_from_rational(1, 2); // 0.5
        let val = fixed_point64::round(point_five);
        assert!(val == 1, 0);
    }

    #[test]
    fun round_can_round_down_correctly() {
        let num = fixed_point64::create_from_rational(499, 1000); // 0.499
        let val = fixed_point64::round(num);
        assert!(val == 0, 0);
    }
}


================================================
File: aptos-move/framework/aptos-stdlib/tests/math64_tests.move
================================================
#[test_only]
module aptos_std::math64_tests {
    use aptos_std::math64;

    #[test]
    fun test_nested_mul_div() {
       let a = math64::mul_div(1, 1, 1);
       assert!(math64::mul_div(1, a, 1) == 1, 0);
    }

    #[test]
    fun test_nested_mul_div2() {
	assert!(math64::mul_div(1, math64::mul_div(1, 1, 1),1) == 1, 0);
    }

    #[test]
    fun test_nested_mul_div3() {
        let a = math64::mul_div(1, math64::mul_div(1, 1, 1),1);
        assert!(a == 1, 0);
    }
}


