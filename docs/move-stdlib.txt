Directory structure:
└── move-stdlib/
    ├── Cargo.toml
    ├── Move.toml
    ├── doc/
    │   ├── acl.md
    │   ├── bcs.md
    │   ├── bit_vector.md
    │   ├── error.md
    │   ├── features.md
    │   ├── fixed_point32.md
    │   ├── hash.md
    │   ├── option.md
    │   ├── overview.md
    │   ├── signer.md
    │   ├── string.md
    │   └── vector.md
    ├── doc_template/
    │   ├── overview.md
    │   └── references.md
    ├── sources/
    │   ├── acl.move
    │   ├── acl.spec.move
    │   ├── bcs.move
    │   ├── bit_vector.move
    │   ├── error.move
    │   ├── fixed_point32.move
    │   ├── hash.move
    │   ├── option.move
    │   ├── signer.move
    │   ├── string.move
    │   ├── string.spec.move
    │   ├── unit_test.move
    │   ├── vector.move
    │   └── configs/
    │       ├── features.move
    │       └── features.spec.move
    ├── src/
    │   ├── lib.rs
    │   └── natives/
    │       ├── bcs.rs
    │       ├── hash.rs
    │       ├── mod.rs
    │       ├── signer.rs
    │       ├── string.rs
    │       └── unit_test.rs
    └── tests/
        ├── bcs_tests.move
        ├── bit_vector_tests.move
        ├── fixedpoint32_tests.move
        ├── hash_tests.move
        ├── option_tests.move
        ├── string_tests.move
        └── vector_tests.move

================================================
File: aptos-move/framework/move-stdlib/Cargo.toml
================================================
[package]
name = "aptos-move-stdlib"
version = "0.1.1"
edition = "2021"
authors = ["Diem Association <opensource@diem.com>"]
description = "Diem stdlib"
repository = "https://github.com/diem/diem"
homepage = "https://diem.com"
license = "Apache-2.0"
publish = false

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
aptos-gas-schedule = { workspace = true }
aptos-native-interface = { workspace = true }
move-core-types = { path = "../../../third_party/move/move-core/types" }
move-vm-runtime = { path = "../../../third_party/move/move-vm/runtime" }
move-vm-types = { path = "../../../third_party/move/move-vm/types" }
sha2 = "0.9.3"
sha3 = "0.9.1"
smallvec = "1.6.1"

[dev-dependencies]
dir-diff = "0.3.2"
file_diff = "1.0.0"
move-cli = { path = "../../../third_party/move/tools/move-cli" }
move-package = { path = "../../../third_party/move/tools/move-package" }
move-unit-test = { path = "../../../third_party/move/tools/move-unit-test" }
tempfile = "3.2.0"

[features]
testing = []

================================================
File: aptos-move/framework/move-stdlib/Move.toml
================================================
[package]
name = "MoveStdlib"
version = "1.5.0"

[addresses]
vm = "0x0"
std = "0x1"


================================================
File: aptos-move/framework/move-stdlib/doc/acl.md
================================================

<a id="0x1_acl"></a>

# Module `0x1::acl`

Access control list (acl) module. An acl is a list of account addresses who
have the access permission to a certain object.
This module uses a <code><a href="vector.md#0x1_vector">vector</a></code> to represent the list, but can be refactored to
use a "set" instead when it's available in the language in the future.


-  [Struct `ACL`](#0x1_acl_ACL)
-  [Constants](#@Constants_0)
-  [Function `empty`](#0x1_acl_empty)
-  [Function `add`](#0x1_acl_add)
-  [Function `remove`](#0x1_acl_remove)
-  [Function `contains`](#0x1_acl_contains)
-  [Function `assert_contains`](#0x1_acl_assert_contains)
-  [Specification](#@Specification_1)
    -  [Struct `ACL`](#@Specification_1_ACL)
    -  [Function `add`](#@Specification_1_add)
    -  [Function `remove`](#@Specification_1_remove)
    -  [Function `contains`](#@Specification_1_contains)
    -  [Function `assert_contains`](#@Specification_1_assert_contains)


<pre><code><b>use</b> <a href="error.md#0x1_error">0x1::error</a>;
<b>use</b> <a href="vector.md#0x1_vector">0x1::vector</a>;
</code></pre>



<a id="0x1_acl_ACL"></a>

## Struct `ACL`



<pre><code><b>struct</b> <a href="acl.md#0x1_acl_ACL">ACL</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>list: <a href="vector.md#0x1_vector">vector</a>&lt;<b>address</b>&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_acl_ECONTAIN"></a>

The ACL already contains the address.


<pre><code><b>const</b> <a href="acl.md#0x1_acl_ECONTAIN">ECONTAIN</a>: u64 = 0;
</code></pre>



<a id="0x1_acl_ENOT_CONTAIN"></a>

The ACL does not contain the address.


<pre><code><b>const</b> <a href="acl.md#0x1_acl_ENOT_CONTAIN">ENOT_CONTAIN</a>: u64 = 1;
</code></pre>



<a id="0x1_acl_empty"></a>

## Function `empty`

Return an empty ACL.


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_empty">empty</a>(): <a href="acl.md#0x1_acl_ACL">acl::ACL</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_empty">empty</a>(): <a href="acl.md#0x1_acl_ACL">ACL</a> {
    <a href="acl.md#0x1_acl_ACL">ACL</a>{ list: <a href="vector.md#0x1_vector_empty">vector::empty</a>&lt;<b>address</b>&gt;() }
}
</code></pre>



</details>

<a id="0x1_acl_add"></a>

## Function `add`

Add the address to the ACL.


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_add">add</a>(<a href="acl.md#0x1_acl">acl</a>: &<b>mut</b> <a href="acl.md#0x1_acl_ACL">acl::ACL</a>, addr: <b>address</b>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_add">add</a>(<a href="acl.md#0x1_acl">acl</a>: &<b>mut</b> <a href="acl.md#0x1_acl_ACL">ACL</a>, addr: <b>address</b>) {
    <b>assert</b>!(!<a href="vector.md#0x1_vector_contains">vector::contains</a>(&<b>mut</b> <a href="acl.md#0x1_acl">acl</a>.list, &addr), <a href="error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="acl.md#0x1_acl_ECONTAIN">ECONTAIN</a>));
    <a href="vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> <a href="acl.md#0x1_acl">acl</a>.list, addr);
}
</code></pre>



</details>

<a id="0x1_acl_remove"></a>

## Function `remove`

Remove the address from the ACL.


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_remove">remove</a>(<a href="acl.md#0x1_acl">acl</a>: &<b>mut</b> <a href="acl.md#0x1_acl_ACL">acl::ACL</a>, addr: <b>address</b>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_remove">remove</a>(<a href="acl.md#0x1_acl">acl</a>: &<b>mut</b> <a href="acl.md#0x1_acl_ACL">ACL</a>, addr: <b>address</b>) {
    <b>let</b> (found, index) = <a href="vector.md#0x1_vector_index_of">vector::index_of</a>(&<b>mut</b> <a href="acl.md#0x1_acl">acl</a>.list, &addr);
    <b>assert</b>!(found, <a href="error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="acl.md#0x1_acl_ENOT_CONTAIN">ENOT_CONTAIN</a>));
    <a href="vector.md#0x1_vector_remove">vector::remove</a>(&<b>mut</b> <a href="acl.md#0x1_acl">acl</a>.list, index);
}
</code></pre>



</details>

<a id="0x1_acl_contains"></a>

## Function `contains`

Return true iff the ACL contains the address.


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_contains">contains</a>(<a href="acl.md#0x1_acl">acl</a>: &<a href="acl.md#0x1_acl_ACL">acl::ACL</a>, addr: <b>address</b>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_contains">contains</a>(<a href="acl.md#0x1_acl">acl</a>: &<a href="acl.md#0x1_acl_ACL">ACL</a>, addr: <b>address</b>): bool {
    <a href="vector.md#0x1_vector_contains">vector::contains</a>(&<a href="acl.md#0x1_acl">acl</a>.list, &addr)
}
</code></pre>



</details>

<a id="0x1_acl_assert_contains"></a>

## Function `assert_contains`

assert! that the ACL has the address.


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_assert_contains">assert_contains</a>(<a href="acl.md#0x1_acl">acl</a>: &<a href="acl.md#0x1_acl_ACL">acl::ACL</a>, addr: <b>address</b>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_assert_contains">assert_contains</a>(<a href="acl.md#0x1_acl">acl</a>: &<a href="acl.md#0x1_acl_ACL">ACL</a>, addr: <b>address</b>) {
    <b>assert</b>!(<a href="acl.md#0x1_acl_contains">contains</a>(<a href="acl.md#0x1_acl">acl</a>, addr), <a href="error.md#0x1_error_invalid_argument">error::invalid_argument</a>(<a href="acl.md#0x1_acl_ENOT_CONTAIN">ENOT_CONTAIN</a>));
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_ACL"></a>

### Struct `ACL`


<pre><code><b>struct</b> <a href="acl.md#0x1_acl_ACL">ACL</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<dl>
<dt>
<code>list: <a href="vector.md#0x1_vector">vector</a>&lt;<b>address</b>&gt;</code>
</dt>
<dd>

</dd>
</dl>



<pre><code><b>invariant</b> <b>forall</b> i in 0..len(list), j in 0..len(list): list[i] == list[j] ==&gt; i == j;
</code></pre>




<a id="0x1_acl_spec_contains"></a>


<pre><code><b>fun</b> <a href="acl.md#0x1_acl_spec_contains">spec_contains</a>(<a href="acl.md#0x1_acl">acl</a>: <a href="acl.md#0x1_acl_ACL">ACL</a>, addr: <b>address</b>): bool {
   <b>exists</b> a in <a href="acl.md#0x1_acl">acl</a>.list: a == addr
}
</code></pre>



<a id="@Specification_1_add"></a>

### Function `add`


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_add">add</a>(<a href="acl.md#0x1_acl">acl</a>: &<b>mut</b> <a href="acl.md#0x1_acl_ACL">acl::ACL</a>, addr: <b>address</b>)
</code></pre>




<pre><code><b>aborts_if</b> <a href="acl.md#0x1_acl_spec_contains">spec_contains</a>(<a href="acl.md#0x1_acl">acl</a>, addr) <b>with</b> <a href="error.md#0x1_error_INVALID_ARGUMENT">error::INVALID_ARGUMENT</a>;
<b>ensures</b> <a href="acl.md#0x1_acl_spec_contains">spec_contains</a>(<a href="acl.md#0x1_acl">acl</a>, addr);
</code></pre>



<a id="@Specification_1_remove"></a>

### Function `remove`


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_remove">remove</a>(<a href="acl.md#0x1_acl">acl</a>: &<b>mut</b> <a href="acl.md#0x1_acl_ACL">acl::ACL</a>, addr: <b>address</b>)
</code></pre>




<pre><code><b>aborts_if</b> !<a href="acl.md#0x1_acl_spec_contains">spec_contains</a>(<a href="acl.md#0x1_acl">acl</a>, addr) <b>with</b> <a href="error.md#0x1_error_INVALID_ARGUMENT">error::INVALID_ARGUMENT</a>;
<b>ensures</b> !<a href="acl.md#0x1_acl_spec_contains">spec_contains</a>(<a href="acl.md#0x1_acl">acl</a>, addr);
</code></pre>



<a id="@Specification_1_contains"></a>

### Function `contains`


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_contains">contains</a>(<a href="acl.md#0x1_acl">acl</a>: &<a href="acl.md#0x1_acl_ACL">acl::ACL</a>, addr: <b>address</b>): bool
</code></pre>




<pre><code><b>ensures</b> result == <a href="acl.md#0x1_acl_spec_contains">spec_contains</a>(<a href="acl.md#0x1_acl">acl</a>, addr);
</code></pre>



<a id="@Specification_1_assert_contains"></a>

### Function `assert_contains`


<pre><code><b>public</b> <b>fun</b> <a href="acl.md#0x1_acl_assert_contains">assert_contains</a>(<a href="acl.md#0x1_acl">acl</a>: &<a href="acl.md#0x1_acl_ACL">acl::ACL</a>, addr: <b>address</b>)
</code></pre>




<pre><code><b>aborts_if</b> !<a href="acl.md#0x1_acl_spec_contains">spec_contains</a>(<a href="acl.md#0x1_acl">acl</a>, addr) <b>with</b> <a href="error.md#0x1_error_INVALID_ARGUMENT">error::INVALID_ARGUMENT</a>;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/bcs.md
================================================

<a id="0x1_bcs"></a>

# Module `0x1::bcs`

Utility for converting a Move value to its binary representation in BCS (Binary Canonical
Serialization). BCS is the binary encoding for Move resources and other non-module values
published on-chain. See https://github.com/aptos-labs/bcs#binary-canonical-serialization-bcs for more
details on BCS.


-  [Function `to_bytes`](#0x1_bcs_to_bytes)
-  [Specification](#@Specification_0)


<pre><code></code></pre>



<a id="0x1_bcs_to_bytes"></a>

## Function `to_bytes`

Return the binary representation of <code>v</code> in BCS (Binary Canonical Serialization) format


<pre><code><b>public</b> <b>fun</b> <a href="bcs.md#0x1_bcs_to_bytes">to_bytes</a>&lt;MoveValue&gt;(v: &MoveValue): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>public</b> <b>fun</b> <a href="bcs.md#0x1_bcs_to_bytes">to_bytes</a>&lt;MoveValue&gt;(v: &MoveValue): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>

<a id="@Specification_0"></a>

## Specification



Native function which is defined in the prover's prelude.


<a id="0x1_bcs_serialize"></a>


<pre><code><b>native</b> <b>fun</b> <a href="bcs.md#0x1_bcs_serialize">serialize</a>&lt;MoveValue&gt;(v: &MoveValue): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/bit_vector.md
================================================

<a id="0x1_bit_vector"></a>

# Module `0x1::bit_vector`



-  [Struct `BitVector`](#0x1_bit_vector_BitVector)
-  [Constants](#@Constants_0)
-  [Function `new`](#0x1_bit_vector_new)
-  [Function `set`](#0x1_bit_vector_set)
-  [Function `unset`](#0x1_bit_vector_unset)
-  [Function `shift_left`](#0x1_bit_vector_shift_left)
-  [Function `is_index_set`](#0x1_bit_vector_is_index_set)
-  [Function `length`](#0x1_bit_vector_length)
-  [Function `longest_set_sequence_starting_at`](#0x1_bit_vector_longest_set_sequence_starting_at)
-  [Function `shift_left_for_verification_only`](#0x1_bit_vector_shift_left_for_verification_only)
-  [Specification](#@Specification_1)
    -  [Struct `BitVector`](#@Specification_1_BitVector)
    -  [Function `new`](#@Specification_1_new)
    -  [Function `set`](#@Specification_1_set)
    -  [Function `unset`](#@Specification_1_unset)
    -  [Function `shift_left`](#@Specification_1_shift_left)
    -  [Function `is_index_set`](#@Specification_1_is_index_set)
    -  [Function `longest_set_sequence_starting_at`](#@Specification_1_longest_set_sequence_starting_at)
    -  [Function `shift_left_for_verification_only`](#@Specification_1_shift_left_for_verification_only)


<pre><code></code></pre>



<a id="0x1_bit_vector_BitVector"></a>

## Struct `BitVector`



<pre><code><b>struct</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>length: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>bit_field: <a href="vector.md#0x1_vector">vector</a>&lt;bool&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_bit_vector_EINDEX"></a>

The provided index is out of bounds


<pre><code><b>const</b> <a href="bit_vector.md#0x1_bit_vector_EINDEX">EINDEX</a>: u64 = 131072;
</code></pre>



<a id="0x1_bit_vector_ELENGTH"></a>

An invalid length of bitvector was given


<pre><code><b>const</b> <a href="bit_vector.md#0x1_bit_vector_ELENGTH">ELENGTH</a>: u64 = 131073;
</code></pre>



<a id="0x1_bit_vector_MAX_SIZE"></a>

The maximum allowed bitvector size


<pre><code><b>const</b> <a href="bit_vector.md#0x1_bit_vector_MAX_SIZE">MAX_SIZE</a>: u64 = 1024;
</code></pre>



<a id="0x1_bit_vector_WORD_SIZE"></a>



<pre><code><b>const</b> <a href="bit_vector.md#0x1_bit_vector_WORD_SIZE">WORD_SIZE</a>: u64 = 1;
</code></pre>



<a id="0x1_bit_vector_new"></a>

## Function `new`



<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_new">new</a>(length: u64): <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_new">new</a>(length: u64): <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a> {
    <b>assert</b>!(length &gt; 0, <a href="bit_vector.md#0x1_bit_vector_ELENGTH">ELENGTH</a>);
    <b>assert</b>!(<a href="bit_vector.md#0x1_bit_vector_length">length</a> &lt; <a href="bit_vector.md#0x1_bit_vector_MAX_SIZE">MAX_SIZE</a>, <a href="bit_vector.md#0x1_bit_vector_ELENGTH">ELENGTH</a>);
    <b>let</b> counter = 0;
    <b>let</b> bit_field = <a href="vector.md#0x1_vector_empty">vector::empty</a>();
    <b>while</b> ({<b>spec</b> {
        <b>invariant</b> counter &lt;= length;
        <b>invariant</b> len(bit_field) == counter;
    };
        (counter &lt; length)}) {
        <a href="vector.md#0x1_vector_push_back">vector::push_back</a>(&<b>mut</b> bit_field, <b>false</b>);
        counter = counter + 1;
    };
    <b>spec</b> {
        <b>assert</b> counter == length;
        <b>assert</b> len(bit_field) == length;
    };

    <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a> {
        length,
        bit_field,
    }
}
</code></pre>



</details>

<a id="0x1_bit_vector_set"></a>

## Function `set`

Set the bit at <code>bit_index</code> in the <code>bitvector</code> regardless of its previous state.


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_set">set</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, bit_index: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_set">set</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>, bit_index: u64) {
    <b>assert</b>!(bit_index &lt; <a href="vector.md#0x1_vector_length">vector::length</a>(&bitvector.bit_field), <a href="bit_vector.md#0x1_bit_vector_EINDEX">EINDEX</a>);
    <b>let</b> x = <a href="vector.md#0x1_vector_borrow_mut">vector::borrow_mut</a>(&<b>mut</b> bitvector.bit_field, bit_index);
    *x = <b>true</b>;
}
</code></pre>



</details>

<a id="0x1_bit_vector_unset"></a>

## Function `unset`

Unset the bit at <code>bit_index</code> in the <code>bitvector</code> regardless of its previous state.


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_unset">unset</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, bit_index: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_unset">unset</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>, bit_index: u64) {
    <b>assert</b>!(bit_index &lt; <a href="vector.md#0x1_vector_length">vector::length</a>(&bitvector.bit_field), <a href="bit_vector.md#0x1_bit_vector_EINDEX">EINDEX</a>);
    <b>let</b> x = <a href="vector.md#0x1_vector_borrow_mut">vector::borrow_mut</a>(&<b>mut</b> bitvector.bit_field, bit_index);
    *x = <b>false</b>;
}
</code></pre>



</details>

<a id="0x1_bit_vector_shift_left"></a>

## Function `shift_left`

Shift the <code>bitvector</code> left by <code>amount</code>. If <code>amount</code> is greater than the
bitvector's length the bitvector will be zeroed out.


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_shift_left">shift_left</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, amount: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_shift_left">shift_left</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>, amount: u64) {
    <b>if</b> (amount &gt;= bitvector.length) {
        <a href="vector.md#0x1_vector_for_each_mut">vector::for_each_mut</a>(&<b>mut</b> bitvector.bit_field, |elem| {
            *elem = <b>false</b>;
        });
    } <b>else</b> {
        <b>let</b> i = amount;

        <b>while</b> (i &lt; bitvector.length) {
            <b>if</b> (<a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector, i)) <a href="bit_vector.md#0x1_bit_vector_set">set</a>(bitvector, i - amount)
            <b>else</b> <a href="bit_vector.md#0x1_bit_vector_unset">unset</a>(bitvector, i - amount);
            i = i + 1;
        };

        i = bitvector.length - amount;

        <b>while</b> (i &lt; bitvector.length) {
            <a href="bit_vector.md#0x1_bit_vector_unset">unset</a>(bitvector, i);
            i = i + 1;
        };
    }
}
</code></pre>



</details>

<a id="0x1_bit_vector_is_index_set"></a>

## Function `is_index_set`

Return the value of the bit at <code>bit_index</code> in the <code>bitvector</code>. <code><b>true</b></code>
represents "1" and <code><b>false</b></code> represents a 0


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector: &<a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, bit_index: u64): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector: &<a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>, bit_index: u64): bool {
    <b>assert</b>!(bit_index &lt; <a href="vector.md#0x1_vector_length">vector::length</a>(&bitvector.bit_field), <a href="bit_vector.md#0x1_bit_vector_EINDEX">EINDEX</a>);
    *<a href="vector.md#0x1_vector_borrow">vector::borrow</a>(&bitvector.bit_field, bit_index)
}
</code></pre>



</details>

<a id="0x1_bit_vector_length"></a>

## Function `length`

Return the length (number of usable bits) of this bitvector


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_length">length</a>(bitvector: &<a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_length">length</a>(bitvector: &<a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>): u64 {
    <a href="vector.md#0x1_vector_length">vector::length</a>(&bitvector.bit_field)
}
</code></pre>



</details>

<a id="0x1_bit_vector_longest_set_sequence_starting_at"></a>

## Function `longest_set_sequence_starting_at`

Returns the length of the longest sequence of set bits starting at (and
including) <code>start_index</code> in the <code>bitvector</code>. If there is no such
sequence, then <code>0</code> is returned.


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_longest_set_sequence_starting_at">longest_set_sequence_starting_at</a>(bitvector: &<a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, start_index: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_longest_set_sequence_starting_at">longest_set_sequence_starting_at</a>(bitvector: &<a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>, start_index: u64): u64 {
    <b>assert</b>!(start_index &lt; bitvector.length, <a href="bit_vector.md#0x1_bit_vector_EINDEX">EINDEX</a>);
    <b>let</b> index = start_index;

    // Find the greatest index in the <a href="vector.md#0x1_vector">vector</a> such that all indices less than it are set.
    <b>while</b> ({
        <b>spec</b> {
            <b>invariant</b> index &gt;= start_index;
            <b>invariant</b> index == start_index || <a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector, index - 1);
            <b>invariant</b> index == start_index || index - 1 &lt; <a href="vector.md#0x1_vector_length">vector::length</a>(bitvector.bit_field);
            <b>invariant</b> <b>forall</b> j in start_index..index: <a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector, j);
            <b>invariant</b> <b>forall</b> j in start_index..index: j &lt; <a href="vector.md#0x1_vector_length">vector::length</a>(bitvector.bit_field);
        };
        index &lt; bitvector.length
    }) {
        <b>if</b> (!<a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector, index)) <b>break</b>;
        index = index + 1;
    };

    index - start_index
}
</code></pre>



</details>

<a id="0x1_bit_vector_shift_left_for_verification_only"></a>

## Function `shift_left_for_verification_only`



<pre><code>#[verify_only]
<b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_shift_left_for_verification_only">shift_left_for_verification_only</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, amount: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_shift_left_for_verification_only">shift_left_for_verification_only</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>, amount: u64) {
    <b>if</b> (amount &gt;= bitvector.length) {
        <b>let</b> len = <a href="vector.md#0x1_vector_length">vector::length</a>(&bitvector.bit_field);
        <b>let</b> i = 0;
        <b>while</b> ({
            <b>spec</b> {
                <b>invariant</b> len == bitvector.length;
                <b>invariant</b> <b>forall</b> k in 0..i: !bitvector.bit_field[k];
                <b>invariant</b> <b>forall</b> k in i..bitvector.length: bitvector.bit_field[k] == <b>old</b>(bitvector).bit_field[k];
            };
            i &lt; len
        }) {
            <b>let</b> elem = <a href="vector.md#0x1_vector_borrow_mut">vector::borrow_mut</a>(&<b>mut</b> bitvector.bit_field, i);
            *elem = <b>false</b>;
            i = i + 1;
        };
    } <b>else</b> {
        <b>let</b> i = amount;

        <b>while</b> ({
            <b>spec</b> {
                <b>invariant</b> i &gt;= amount;
                <b>invariant</b> bitvector.length == <b>old</b>(bitvector).length;
                <b>invariant</b> <b>forall</b> j in amount..i: <b>old</b>(bitvector).bit_field[j] == bitvector.bit_field[j - amount];
                <b>invariant</b> <b>forall</b> j in (i-amount)..bitvector.length : <b>old</b>(bitvector).bit_field[j] == bitvector.bit_field[j];
                <b>invariant</b> <b>forall</b> k in 0..i-amount: bitvector.bit_field[k] == <b>old</b>(bitvector).bit_field[k + amount];
            };
            i &lt; bitvector.length
        }) {
            <b>if</b> (<a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector, i)) <a href="bit_vector.md#0x1_bit_vector_set">set</a>(bitvector, i - amount)
            <b>else</b> <a href="bit_vector.md#0x1_bit_vector_unset">unset</a>(bitvector, i - amount);
            i = i + 1;
        };


        i = bitvector.length - amount;

        <b>while</b> ({
            <b>spec</b> {
                <b>invariant</b> <b>forall</b> j in bitvector.length - amount..i: !bitvector.bit_field[j];
                <b>invariant</b> <b>forall</b> k in 0..bitvector.length - amount: bitvector.bit_field[k] == <b>old</b>(bitvector).bit_field[k + amount];
                <b>invariant</b> i &gt;= bitvector.length - amount;
            };
            i &lt; bitvector.length
        }) {
            <a href="bit_vector.md#0x1_bit_vector_unset">unset</a>(bitvector, i);
            i = i + 1;
        }
    }
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_BitVector"></a>

### Struct `BitVector`


<pre><code><b>struct</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<dl>
<dt>
<code>length: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>bit_field: <a href="vector.md#0x1_vector">vector</a>&lt;bool&gt;</code>
</dt>
<dd>

</dd>
</dl>



<pre><code><b>invariant</b> length == len(bit_field);
</code></pre>



<a id="@Specification_1_new"></a>

### Function `new`


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_new">new</a>(length: u64): <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>
</code></pre>




<pre><code><b>include</b> <a href="bit_vector.md#0x1_bit_vector_NewAbortsIf">NewAbortsIf</a>;
<b>ensures</b> result.length == length;
<b>ensures</b> len(result.bit_field) == length;
</code></pre>




<a id="0x1_bit_vector_NewAbortsIf"></a>


<pre><code><b>schema</b> <a href="bit_vector.md#0x1_bit_vector_NewAbortsIf">NewAbortsIf</a> {
    length: u64;
    <b>aborts_if</b> <a href="bit_vector.md#0x1_bit_vector_length">length</a> &lt;= 0 <b>with</b> <a href="bit_vector.md#0x1_bit_vector_ELENGTH">ELENGTH</a>;
    <b>aborts_if</b> length &gt;= <a href="bit_vector.md#0x1_bit_vector_MAX_SIZE">MAX_SIZE</a> <b>with</b> <a href="bit_vector.md#0x1_bit_vector_ELENGTH">ELENGTH</a>;
}
</code></pre>



<a id="@Specification_1_set"></a>

### Function `set`


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_set">set</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, bit_index: u64)
</code></pre>




<pre><code><b>include</b> <a href="bit_vector.md#0x1_bit_vector_SetAbortsIf">SetAbortsIf</a>;
<b>ensures</b> bitvector.bit_field[bit_index];
</code></pre>




<a id="0x1_bit_vector_SetAbortsIf"></a>


<pre><code><b>schema</b> <a href="bit_vector.md#0x1_bit_vector_SetAbortsIf">SetAbortsIf</a> {
    bitvector: <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>;
    bit_index: u64;
    <b>aborts_if</b> bit_index &gt;= <a href="bit_vector.md#0x1_bit_vector_length">length</a>(bitvector) <b>with</b> <a href="bit_vector.md#0x1_bit_vector_EINDEX">EINDEX</a>;
}
</code></pre>



<a id="@Specification_1_unset"></a>

### Function `unset`


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_unset">unset</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, bit_index: u64)
</code></pre>




<pre><code><b>include</b> <a href="bit_vector.md#0x1_bit_vector_UnsetAbortsIf">UnsetAbortsIf</a>;
<b>ensures</b> !bitvector.bit_field[bit_index];
</code></pre>




<a id="0x1_bit_vector_UnsetAbortsIf"></a>


<pre><code><b>schema</b> <a href="bit_vector.md#0x1_bit_vector_UnsetAbortsIf">UnsetAbortsIf</a> {
    bitvector: <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>;
    bit_index: u64;
    <b>aborts_if</b> bit_index &gt;= <a href="bit_vector.md#0x1_bit_vector_length">length</a>(bitvector) <b>with</b> <a href="bit_vector.md#0x1_bit_vector_EINDEX">EINDEX</a>;
}
</code></pre>



<a id="@Specification_1_shift_left"></a>

### Function `shift_left`


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_shift_left">shift_left</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, amount: u64)
</code></pre>




<pre><code><b>pragma</b> verify = <b>false</b>;
</code></pre>



<a id="@Specification_1_is_index_set"></a>

### Function `is_index_set`


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector: &<a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, bit_index: u64): bool
</code></pre>




<pre><code><b>include</b> <a href="bit_vector.md#0x1_bit_vector_IsIndexSetAbortsIf">IsIndexSetAbortsIf</a>;
<b>ensures</b> result == bitvector.bit_field[bit_index];
</code></pre>




<a id="0x1_bit_vector_IsIndexSetAbortsIf"></a>


<pre><code><b>schema</b> <a href="bit_vector.md#0x1_bit_vector_IsIndexSetAbortsIf">IsIndexSetAbortsIf</a> {
    bitvector: <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>;
    bit_index: u64;
    <b>aborts_if</b> bit_index &gt;= <a href="bit_vector.md#0x1_bit_vector_length">length</a>(bitvector) <b>with</b> <a href="bit_vector.md#0x1_bit_vector_EINDEX">EINDEX</a>;
}
</code></pre>




<a id="0x1_bit_vector_spec_is_index_set"></a>


<pre><code><b>fun</b> <a href="bit_vector.md#0x1_bit_vector_spec_is_index_set">spec_is_index_set</a>(bitvector: <a href="bit_vector.md#0x1_bit_vector_BitVector">BitVector</a>, bit_index: u64): bool {
   <b>if</b> (bit_index &gt;= <a href="bit_vector.md#0x1_bit_vector_length">length</a>(bitvector)) {
       <b>false</b>
   } <b>else</b> {
       bitvector.bit_field[bit_index]
   }
}
</code></pre>



<a id="@Specification_1_longest_set_sequence_starting_at"></a>

### Function `longest_set_sequence_starting_at`


<pre><code><b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_longest_set_sequence_starting_at">longest_set_sequence_starting_at</a>(bitvector: &<a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, start_index: u64): u64
</code></pre>




<pre><code><b>aborts_if</b> start_index &gt;= bitvector.length;
<b>ensures</b> <b>forall</b> i in start_index..result: <a href="bit_vector.md#0x1_bit_vector_is_index_set">is_index_set</a>(bitvector, i);
</code></pre>



<a id="@Specification_1_shift_left_for_verification_only"></a>

### Function `shift_left_for_verification_only`


<pre><code>#[verify_only]
<b>public</b> <b>fun</b> <a href="bit_vector.md#0x1_bit_vector_shift_left_for_verification_only">shift_left_for_verification_only</a>(bitvector: &<b>mut</b> <a href="bit_vector.md#0x1_bit_vector_BitVector">bit_vector::BitVector</a>, amount: u64)
</code></pre>




<pre><code><b>aborts_if</b> <b>false</b>;
<b>ensures</b> amount &gt;= bitvector.length ==&gt; (<b>forall</b> k in 0..bitvector.length: !bitvector.bit_field[k]);
<b>ensures</b> amount &lt; bitvector.length ==&gt;
    (<b>forall</b> i in bitvector.length - amount..bitvector.length: !bitvector.bit_field[i]);
<b>ensures</b> amount &lt; bitvector.length ==&gt;
    (<b>forall</b> i in 0..bitvector.length - amount: bitvector.bit_field[i] == <b>old</b>(bitvector).bit_field[i + amount]);
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/error.md
================================================

<a id="0x1_error"></a>

# Module `0x1::error`

This module defines a set of canonical error codes which are optional to use by applications for the
<code><b>abort</b></code> and <code><b>assert</b>!</code> features.

Canonical error codes use the 3 lowest bytes of the u64 abort code range (the upper 5 bytes are free for other use).
Of those, the highest byte represents the *error category* and the lower two bytes the *error reason*.
Given an error category <code>0x1</code> and a reason <code>0x3</code>, a canonical abort code looks as <code>0x10003</code>.

A module can use a canonical code with a constant declaration of the following form:

```
///  An invalid ASCII character was encountered when creating a string.
const EINVALID_CHARACTER: u64 = 0x010003;
```

This code is both valid in the worlds with and without canonical errors. It can be used as a plain module local
error reason understand by the existing error map tooling, or as a canonical code.

The actual canonical categories have been adopted from Google's canonical error codes, which in turn are derived
from Unix error codes [see here](https://cloud.google.com/apis/design/errors#handling_errors). Each code has an
associated HTTP error code which can be used in REST apis. The mapping from error code to http code is not 1:1;
error codes here are a bit richer than HTTP codes.


-  [Constants](#@Constants_0)
-  [Function `canonical`](#0x1_error_canonical)
-  [Function `invalid_argument`](#0x1_error_invalid_argument)
-  [Function `out_of_range`](#0x1_error_out_of_range)
-  [Function `invalid_state`](#0x1_error_invalid_state)
-  [Function `unauthenticated`](#0x1_error_unauthenticated)
-  [Function `permission_denied`](#0x1_error_permission_denied)
-  [Function `not_found`](#0x1_error_not_found)
-  [Function `aborted`](#0x1_error_aborted)
-  [Function `already_exists`](#0x1_error_already_exists)
-  [Function `resource_exhausted`](#0x1_error_resource_exhausted)
-  [Function `internal`](#0x1_error_internal)
-  [Function `not_implemented`](#0x1_error_not_implemented)
-  [Function `unavailable`](#0x1_error_unavailable)
-  [Specification](#@Specification_1)
    -  [Function `canonical`](#@Specification_1_canonical)


<pre><code></code></pre>



<a id="@Constants_0"></a>

## Constants


<a id="0x1_error_ABORTED"></a>

Concurrency conflict, such as read-modify-write conflict (http: 409)


<pre><code><b>const</b> <a href="error.md#0x1_error_ABORTED">ABORTED</a>: u64 = 7;
</code></pre>



<a id="0x1_error_ALREADY_EXISTS"></a>

The resource that a client tried to create already exists (http: 409)


<pre><code><b>const</b> <a href="error.md#0x1_error_ALREADY_EXISTS">ALREADY_EXISTS</a>: u64 = 8;
</code></pre>



<a id="0x1_error_CANCELLED"></a>

Request cancelled by the client (http: 499)


<pre><code><b>const</b> <a href="error.md#0x1_error_CANCELLED">CANCELLED</a>: u64 = 10;
</code></pre>



<a id="0x1_error_INTERNAL"></a>

Internal error (http: 500)


<pre><code><b>const</b> <a href="error.md#0x1_error_INTERNAL">INTERNAL</a>: u64 = 11;
</code></pre>



<a id="0x1_error_INVALID_ARGUMENT"></a>

Caller specified an invalid argument (http: 400)


<pre><code><b>const</b> <a href="error.md#0x1_error_INVALID_ARGUMENT">INVALID_ARGUMENT</a>: u64 = 1;
</code></pre>



<a id="0x1_error_INVALID_STATE"></a>

The system is not in a state where the operation can be performed (http: 400)


<pre><code><b>const</b> <a href="error.md#0x1_error_INVALID_STATE">INVALID_STATE</a>: u64 = 3;
</code></pre>



<a id="0x1_error_NOT_FOUND"></a>

A specified resource is not found (http: 404)


<pre><code><b>const</b> <a href="error.md#0x1_error_NOT_FOUND">NOT_FOUND</a>: u64 = 6;
</code></pre>



<a id="0x1_error_NOT_IMPLEMENTED"></a>

Feature not implemented (http: 501)


<pre><code><b>const</b> <a href="error.md#0x1_error_NOT_IMPLEMENTED">NOT_IMPLEMENTED</a>: u64 = 12;
</code></pre>



<a id="0x1_error_OUT_OF_RANGE"></a>

An input or result of a computation is out of range (http: 400)


<pre><code><b>const</b> <a href="error.md#0x1_error_OUT_OF_RANGE">OUT_OF_RANGE</a>: u64 = 2;
</code></pre>



<a id="0x1_error_PERMISSION_DENIED"></a>

client does not have sufficient permission (http: 403)


<pre><code><b>const</b> <a href="error.md#0x1_error_PERMISSION_DENIED">PERMISSION_DENIED</a>: u64 = 5;
</code></pre>



<a id="0x1_error_RESOURCE_EXHAUSTED"></a>

Out of gas or other forms of quota (http: 429)


<pre><code><b>const</b> <a href="error.md#0x1_error_RESOURCE_EXHAUSTED">RESOURCE_EXHAUSTED</a>: u64 = 9;
</code></pre>



<a id="0x1_error_UNAUTHENTICATED"></a>

Request not authenticated due to missing, invalid, or expired auth token (http: 401)


<pre><code><b>const</b> <a href="error.md#0x1_error_UNAUTHENTICATED">UNAUTHENTICATED</a>: u64 = 4;
</code></pre>



<a id="0x1_error_UNAVAILABLE"></a>

The service is currently unavailable. Indicates that a retry could solve the issue (http: 503)


<pre><code><b>const</b> <a href="error.md#0x1_error_UNAVAILABLE">UNAVAILABLE</a>: u64 = 13;
</code></pre>



<a id="0x1_error_canonical"></a>

## Function `canonical`

Construct a canonical error code from a category and a reason.


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_canonical">canonical</a>(category: u64, reason: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_canonical">canonical</a>(category: u64, reason: u64): u64 {
  (category &lt;&lt; 16) + reason
}
</code></pre>



</details>

<a id="0x1_error_invalid_argument"></a>

## Function `invalid_argument`

Functions to construct a canonical error code of the given category.


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_invalid_argument">invalid_argument</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_invalid_argument">invalid_argument</a>(r: u64): u64 {  <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_INVALID_ARGUMENT">INVALID_ARGUMENT</a>, r) }
</code></pre>



</details>

<a id="0x1_error_out_of_range"></a>

## Function `out_of_range`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_out_of_range">out_of_range</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_out_of_range">out_of_range</a>(r: u64): u64 {  <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_OUT_OF_RANGE">OUT_OF_RANGE</a>, r) }
</code></pre>



</details>

<a id="0x1_error_invalid_state"></a>

## Function `invalid_state`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_invalid_state">invalid_state</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_invalid_state">invalid_state</a>(r: u64): u64 {  <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_INVALID_STATE">INVALID_STATE</a>, r) }
</code></pre>



</details>

<a id="0x1_error_unauthenticated"></a>

## Function `unauthenticated`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_unauthenticated">unauthenticated</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_unauthenticated">unauthenticated</a>(r: u64): u64 { <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_UNAUTHENTICATED">UNAUTHENTICATED</a>, r) }
</code></pre>



</details>

<a id="0x1_error_permission_denied"></a>

## Function `permission_denied`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_permission_denied">permission_denied</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_permission_denied">permission_denied</a>(r: u64): u64 { <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_PERMISSION_DENIED">PERMISSION_DENIED</a>, r) }
</code></pre>



</details>

<a id="0x1_error_not_found"></a>

## Function `not_found`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_not_found">not_found</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_not_found">not_found</a>(r: u64): u64 { <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_NOT_FOUND">NOT_FOUND</a>, r) }
</code></pre>



</details>

<a id="0x1_error_aborted"></a>

## Function `aborted`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_aborted">aborted</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_aborted">aborted</a>(r: u64): u64 { <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_ABORTED">ABORTED</a>, r) }
</code></pre>



</details>

<a id="0x1_error_already_exists"></a>

## Function `already_exists`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_already_exists">already_exists</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_already_exists">already_exists</a>(r: u64): u64 { <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_ALREADY_EXISTS">ALREADY_EXISTS</a>, r) }
</code></pre>



</details>

<a id="0x1_error_resource_exhausted"></a>

## Function `resource_exhausted`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_resource_exhausted">resource_exhausted</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_resource_exhausted">resource_exhausted</a>(r: u64): u64 {  <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_RESOURCE_EXHAUSTED">RESOURCE_EXHAUSTED</a>, r) }
</code></pre>



</details>

<a id="0x1_error_internal"></a>

## Function `internal`



<pre><code><b>public</b> <b>fun</b> <b>internal</b>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <b>internal</b>(r: u64): u64 {  <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_INTERNAL">INTERNAL</a>, r) }
</code></pre>



</details>

<a id="0x1_error_not_implemented"></a>

## Function `not_implemented`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_not_implemented">not_implemented</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_not_implemented">not_implemented</a>(r: u64): u64 {  <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_NOT_IMPLEMENTED">NOT_IMPLEMENTED</a>, r) }
</code></pre>



</details>

<a id="0x1_error_unavailable"></a>

## Function `unavailable`



<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_unavailable">unavailable</a>(r: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_unavailable">unavailable</a>(r: u64): u64 { <a href="error.md#0x1_error_canonical">canonical</a>(<a href="error.md#0x1_error_UNAVAILABLE">UNAVAILABLE</a>, r) }
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_canonical"></a>

### Function `canonical`


<pre><code><b>public</b> <b>fun</b> <a href="error.md#0x1_error_canonical">canonical</a>(category: u64, reason: u64): u64
</code></pre>




<pre><code><b>pragma</b> opaque = <b>true</b>;
<b>let</b> shl_res = category &lt;&lt; 16;
<b>ensures</b> [concrete] result == shl_res + reason;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == category;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/fixed_point32.md
================================================

<a id="0x1_fixed_point32"></a>

# Module `0x1::fixed_point32`

Defines a fixed-point numeric type with a 32-bit integer part and
a 32-bit fractional part.


-  [Struct `FixedPoint32`](#0x1_fixed_point32_FixedPoint32)
-  [Constants](#@Constants_0)
-  [Function `multiply_u64`](#0x1_fixed_point32_multiply_u64)
-  [Function `divide_u64`](#0x1_fixed_point32_divide_u64)
-  [Function `create_from_rational`](#0x1_fixed_point32_create_from_rational)
-  [Function `create_from_raw_value`](#0x1_fixed_point32_create_from_raw_value)
-  [Function `get_raw_value`](#0x1_fixed_point32_get_raw_value)
-  [Function `is_zero`](#0x1_fixed_point32_is_zero)
-  [Function `min`](#0x1_fixed_point32_min)
-  [Function `max`](#0x1_fixed_point32_max)
-  [Function `create_from_u64`](#0x1_fixed_point32_create_from_u64)
-  [Function `floor`](#0x1_fixed_point32_floor)
-  [Function `ceil`](#0x1_fixed_point32_ceil)
-  [Function `round`](#0x1_fixed_point32_round)
-  [Specification](#@Specification_1)
    -  [Function `multiply_u64`](#@Specification_1_multiply_u64)
    -  [Function `divide_u64`](#@Specification_1_divide_u64)
    -  [Function `create_from_rational`](#@Specification_1_create_from_rational)
    -  [Function `create_from_raw_value`](#@Specification_1_create_from_raw_value)
    -  [Function `min`](#@Specification_1_min)
    -  [Function `max`](#@Specification_1_max)
    -  [Function `create_from_u64`](#@Specification_1_create_from_u64)
    -  [Function `floor`](#@Specification_1_floor)
    -  [Function `ceil`](#@Specification_1_ceil)
    -  [Function `round`](#@Specification_1_round)


<pre><code></code></pre>



<a id="0x1_fixed_point32_FixedPoint32"></a>

## Struct `FixedPoint32`

Define a fixed-point numeric type with 32 fractional bits.
This is just a u64 integer but it is wrapped in a struct to
make a unique type. This is a binary representation, so decimal
values may not be exactly representable, but it provides more
than 9 decimal digits of precision both before and after the
decimal point (18 digits total). For comparison, double precision
floating-point has less than 16 decimal digits of precision, so
be careful about using floating-point to convert these values to
decimal.


<pre><code><b>struct</b> <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>value: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_fixed_point32_MAX_U64"></a>



<pre><code><b>const</b> <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a>: u128 = 18446744073709551615;
</code></pre>



<a id="0x1_fixed_point32_EDENOMINATOR"></a>

The denominator provided was zero


<pre><code><b>const</b> <a href="fixed_point32.md#0x1_fixed_point32_EDENOMINATOR">EDENOMINATOR</a>: u64 = 65537;
</code></pre>



<a id="0x1_fixed_point32_EDIVISION"></a>

The quotient value would be too large to be held in a <code>u64</code>


<pre><code><b>const</b> <a href="fixed_point32.md#0x1_fixed_point32_EDIVISION">EDIVISION</a>: u64 = 131074;
</code></pre>



<a id="0x1_fixed_point32_EDIVISION_BY_ZERO"></a>

A division by zero was encountered


<pre><code><b>const</b> <a href="fixed_point32.md#0x1_fixed_point32_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>: u64 = 65540;
</code></pre>



<a id="0x1_fixed_point32_EMULTIPLICATION"></a>

The multiplied value would be too large to be held in a <code>u64</code>


<pre><code><b>const</b> <a href="fixed_point32.md#0x1_fixed_point32_EMULTIPLICATION">EMULTIPLICATION</a>: u64 = 131075;
</code></pre>



<a id="0x1_fixed_point32_ERATIO_OUT_OF_RANGE"></a>

The computed ratio when converting to a <code><a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a></code> would be unrepresentable


<pre><code><b>const</b> <a href="fixed_point32.md#0x1_fixed_point32_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>: u64 = 131077;
</code></pre>



<a id="0x1_fixed_point32_multiply_u64"></a>

## Function `multiply_u64`

Multiply a u64 integer by a fixed-point number, truncating any
fractional part of the product. This will abort if the product
overflows.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_multiply_u64">multiply_u64</a>(val: u64, multiplier: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_multiply_u64">multiply_u64</a>(val: u64, multiplier: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
    // The product of two 64 bit values <b>has</b> 128 bits, so perform the
    // multiplication <b>with</b> u128 types and keep the full 128 bit product
    // <b>to</b> avoid losing accuracy.
    <b>let</b> unscaled_product = (val <b>as</b> u128) * (multiplier.value <b>as</b> u128);
    // The unscaled product <b>has</b> 32 fractional bits (from the multiplier)
    // so rescale it by shifting away the low bits.
    <b>let</b> product = unscaled_product &gt;&gt; 32;
    // Check whether the value is too large.
    <b>assert</b>!(product &lt;= <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a>, <a href="fixed_point32.md#0x1_fixed_point32_EMULTIPLICATION">EMULTIPLICATION</a>);
    (product <b>as</b> u64)
}
</code></pre>



</details>

<a id="0x1_fixed_point32_divide_u64"></a>

## Function `divide_u64`

Divide a u64 integer by a fixed-point number, truncating any
fractional part of the quotient. This will abort if the divisor
is zero or if the quotient overflows.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_divide_u64">divide_u64</a>(val: u64, divisor: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_divide_u64">divide_u64</a>(val: u64, divisor: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
    // Check for division by zero.
    <b>assert</b>!(divisor.value != 0, <a href="fixed_point32.md#0x1_fixed_point32_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>);
    // First convert <b>to</b> 128 bits and then shift left <b>to</b>
    // add 32 fractional zero bits <b>to</b> the dividend.
    <b>let</b> scaled_value = (val <b>as</b> u128) &lt;&lt; 32;
    <b>let</b> quotient = scaled_value / (divisor.value <b>as</b> u128);
    // Check whether the value is too large.
    <b>assert</b>!(quotient &lt;= <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a>, <a href="fixed_point32.md#0x1_fixed_point32_EDIVISION">EDIVISION</a>);
    // the value may be too large, which will cause the cast <b>to</b> fail
    // <b>with</b> an arithmetic <a href="error.md#0x1_error">error</a>.
    (quotient <b>as</b> u64)
}
</code></pre>



</details>

<a id="0x1_fixed_point32_create_from_rational"></a>

## Function `create_from_rational`

Create a fixed-point value from a rational number specified by its
numerator and denominator. Calling this function should be preferred
for using <code><a href="fixed_point32.md#0x1_fixed_point32_create_from_raw_value">Self::create_from_raw_value</a></code> which is also available.
This will abort if the denominator is zero. It will also
abort if the numerator is nonzero and the ratio is not in the range
2^-32 .. 2^32-1. When specifying decimal fractions, be careful about
rounding errors: if you round to display N digits after the decimal
point, you can use a denominator of 10^N to avoid numbers where the
very small imprecision in the binary representation could change the
rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_rational">create_from_rational</a>(numerator: u64, denominator: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_rational">create_from_rational</a>(numerator: u64, denominator: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
    // If the denominator is zero, this will <b>abort</b>.
    // Scale the numerator <b>to</b> have 64 fractional bits and the denominator
    // <b>to</b> have 32 fractional bits, so that the quotient will have 32
    // fractional bits.
    <b>let</b> scaled_numerator = (numerator <b>as</b> u128) &lt;&lt; 64;
    <b>let</b> scaled_denominator = (denominator <b>as</b> u128) &lt;&lt; 32;
    <b>assert</b>!(scaled_denominator != 0, <a href="fixed_point32.md#0x1_fixed_point32_EDENOMINATOR">EDENOMINATOR</a>);
    <b>let</b> quotient = scaled_numerator / scaled_denominator;
    <b>assert</b>!(quotient != 0 || numerator == 0, <a href="fixed_point32.md#0x1_fixed_point32_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>);
    // Return the quotient <b>as</b> a fixed-point number. We first need <b>to</b> check whether the cast
    // can succeed.
    <b>assert</b>!(quotient &lt;= <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a>, <a href="fixed_point32.md#0x1_fixed_point32_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>);
    <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> { value: (quotient <b>as</b> u64) }
}
</code></pre>



</details>

<a id="0x1_fixed_point32_create_from_raw_value"></a>

## Function `create_from_raw_value`

Create a fixedpoint value from a raw value.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_raw_value">create_from_raw_value</a>(value: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_raw_value">create_from_raw_value</a>(value: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
    <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> { value }
}
</code></pre>



</details>

<a id="0x1_fixed_point32_get_raw_value"></a>

## Function `get_raw_value`

Accessor for the raw u64 value. Other less common operations, such as
adding or subtracting FixedPoint32 values, can be done using the raw
values directly.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_get_raw_value">get_raw_value</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_get_raw_value">get_raw_value</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
    num.value
}
</code></pre>



</details>

<a id="0x1_fixed_point32_is_zero"></a>

## Function `is_zero`

Returns true if the ratio is zero.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_is_zero">is_zero</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_is_zero">is_zero</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): bool {
    num.value == 0
}
</code></pre>



</details>

<a id="0x1_fixed_point32_min"></a>

## Function `min`

Returns the smaller of the two FixedPoint32 numbers.


<pre><code><b>public</b> <b>fun</b> <b>min</b>(num1: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>, num2: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <b>min</b>(num1: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>, num2: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
    <b>if</b> (num1.value &lt; num2.value) {
        num1
    } <b>else</b> {
        num2
    }
}
</code></pre>



</details>

<a id="0x1_fixed_point32_max"></a>

## Function `max`

Returns the larger of the two FixedPoint32 numbers.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_max">max</a>(num1: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>, num2: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_max">max</a>(num1: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>, num2: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
    <b>if</b> (num1.value &gt; num2.value) {
        num1
    } <b>else</b> {
        num2
    }
}
</code></pre>



</details>

<a id="0x1_fixed_point32_create_from_u64"></a>

## Function `create_from_u64`

Create a fixedpoint value from a u64 value.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_u64">create_from_u64</a>(val: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_u64">create_from_u64</a>(val: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
    <b>let</b> value = (val <b>as</b> u128) &lt;&lt; 32;
    <b>assert</b>!(value &lt;= <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a>, <a href="fixed_point32.md#0x1_fixed_point32_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>);
    <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {value: (value <b>as</b> u64)}
}
</code></pre>



</details>

<a id="0x1_fixed_point32_floor"></a>

## Function `floor`

Returns the largest integer less than or equal to a given number.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_floor">floor</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_floor">floor</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
    num.value &gt;&gt; 32
}
</code></pre>



</details>

<a id="0x1_fixed_point32_ceil"></a>

## Function `ceil`

Rounds up the given FixedPoint32 to the next largest integer.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_ceil">ceil</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_ceil">ceil</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
    <b>let</b> floored_num = <a href="fixed_point32.md#0x1_fixed_point32_floor">floor</a>(num) &lt;&lt; 32;
    <b>if</b> (num.value == floored_num) {
        <b>return</b> floored_num &gt;&gt; 32
    };
    <b>let</b> val = ((floored_num <b>as</b> u128) + (1 &lt;&lt; 32));
    (val &gt;&gt; 32 <b>as</b> u64)
}
</code></pre>



</details>

<a id="0x1_fixed_point32_round"></a>

## Function `round`

Returns the value of a FixedPoint32 to the nearest integer.


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_round">round</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_round">round</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
    <b>let</b> floored_num = <a href="fixed_point32.md#0x1_fixed_point32_floor">floor</a>(num) &lt;&lt; 32;
    <b>let</b> boundary = floored_num + ((1 &lt;&lt; 32) / 2);
    <b>if</b> (num.value &lt; boundary) {
        floored_num &gt;&gt; 32
    } <b>else</b> {
        <a href="fixed_point32.md#0x1_fixed_point32_ceil">ceil</a>(num)
    }
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification




<pre><code><b>pragma</b> aborts_if_is_strict;
</code></pre>



<a id="@Specification_1_multiply_u64"></a>

### Function `multiply_u64`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_multiply_u64">multiply_u64</a>(val: u64, multiplier: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="fixed_point32.md#0x1_fixed_point32_MultiplyAbortsIf">MultiplyAbortsIf</a>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_multiply_u64">spec_multiply_u64</a>(val, multiplier);
</code></pre>




<a id="0x1_fixed_point32_MultiplyAbortsIf"></a>


<pre><code><b>schema</b> <a href="fixed_point32.md#0x1_fixed_point32_MultiplyAbortsIf">MultiplyAbortsIf</a> {
    val: num;
    multiplier: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>;
    <b>aborts_if</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_multiply_u64">spec_multiply_u64</a>(val, multiplier) &gt; <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a> <b>with</b> <a href="fixed_point32.md#0x1_fixed_point32_EMULTIPLICATION">EMULTIPLICATION</a>;
}
</code></pre>




<a id="0x1_fixed_point32_spec_multiply_u64"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_multiply_u64">spec_multiply_u64</a>(val: num, multiplier: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): num {
   (val * multiplier.value) &gt;&gt; 32
}
</code></pre>



<a id="@Specification_1_divide_u64"></a>

### Function `divide_u64`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_divide_u64">divide_u64</a>(val: u64, divisor: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="fixed_point32.md#0x1_fixed_point32_DivideAbortsIf">DivideAbortsIf</a>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_divide_u64">spec_divide_u64</a>(val, divisor);
</code></pre>




<a id="0x1_fixed_point32_DivideAbortsIf"></a>


<pre><code><b>schema</b> <a href="fixed_point32.md#0x1_fixed_point32_DivideAbortsIf">DivideAbortsIf</a> {
    val: num;
    divisor: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>;
    <b>aborts_if</b> divisor.value == 0 <b>with</b> <a href="fixed_point32.md#0x1_fixed_point32_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>;
    <b>aborts_if</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_divide_u64">spec_divide_u64</a>(val, divisor) &gt; <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a> <b>with</b> <a href="fixed_point32.md#0x1_fixed_point32_EDIVISION">EDIVISION</a>;
}
</code></pre>




<a id="0x1_fixed_point32_spec_divide_u64"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_divide_u64">spec_divide_u64</a>(val: num, divisor: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): num {
   (val &lt;&lt; 32) / divisor.value
}
</code></pre>



<a id="@Specification_1_create_from_rational"></a>

### Function `create_from_rational`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_rational">create_from_rational</a>(numerator: u64, denominator: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="fixed_point32.md#0x1_fixed_point32_CreateFromRationalAbortsIf">CreateFromRationalAbortsIf</a>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_create_from_rational">spec_create_from_rational</a>(numerator, denominator);
</code></pre>




<a id="0x1_fixed_point32_CreateFromRationalAbortsIf"></a>


<pre><code><b>schema</b> <a href="fixed_point32.md#0x1_fixed_point32_CreateFromRationalAbortsIf">CreateFromRationalAbortsIf</a> {
    numerator: u64;
    denominator: u64;
    <b>let</b> scaled_numerator = (numerator <b>as</b> u128)&lt;&lt; 64;
    <b>let</b> scaled_denominator = (denominator <b>as</b> u128) &lt;&lt; 32;
    <b>let</b> quotient = scaled_numerator / scaled_denominator;
    <b>aborts_if</b> scaled_denominator == 0 <b>with</b> <a href="fixed_point32.md#0x1_fixed_point32_EDENOMINATOR">EDENOMINATOR</a>;
    <b>aborts_if</b> quotient == 0 && scaled_numerator != 0 <b>with</b> <a href="fixed_point32.md#0x1_fixed_point32_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>;
    <b>aborts_if</b> quotient &gt; <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a> <b>with</b> <a href="fixed_point32.md#0x1_fixed_point32_ERATIO_OUT_OF_RANGE">ERATIO_OUT_OF_RANGE</a>;
}
</code></pre>




<a id="0x1_fixed_point32_spec_create_from_rational"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_create_from_rational">spec_create_from_rational</a>(numerator: num, denominator: num): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
   <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>{value: (numerator &lt;&lt; 64) / (denominator &lt;&lt; 32)}
}
</code></pre>



<a id="@Specification_1_create_from_raw_value"></a>

### Function `create_from_raw_value`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_raw_value">create_from_raw_value</a>(value: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result.value == value;
</code></pre>



<a id="@Specification_1_min"></a>

### Function `min`


<pre><code><b>public</b> <b>fun</b> <b>min</b>(num1: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>, num2: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_min">spec_min</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point32_spec_min"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_min">spec_min</a>(num1: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>, num2: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
   <b>if</b> (num1.value &lt; num2.value) {
       num1
   } <b>else</b> {
       num2
   }
}
</code></pre>



<a id="@Specification_1_max"></a>

### Function `max`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_max">max</a>(num1: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>, num2: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_max">spec_max</a>(num1, num2);
</code></pre>




<a id="0x1_fixed_point32_spec_max"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_max">spec_max</a>(num1: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>, num2: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
   <b>if</b> (num1.value &gt; num2.value) {
       num1
   } <b>else</b> {
       num2
   }
}
</code></pre>



<a id="@Specification_1_create_from_u64"></a>

### Function `create_from_u64`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_create_from_u64">create_from_u64</a>(val: u64): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="fixed_point32.md#0x1_fixed_point32_CreateFromU64AbortsIf">CreateFromU64AbortsIf</a>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_create_from_u64">spec_create_from_u64</a>(val);
</code></pre>




<a id="0x1_fixed_point32_CreateFromU64AbortsIf"></a>


<pre><code><b>schema</b> <a href="fixed_point32.md#0x1_fixed_point32_CreateFromU64AbortsIf">CreateFromU64AbortsIf</a> {
    val: num;
    <b>let</b> scaled_value = (val <b>as</b> u128) &lt;&lt; 32;
    <b>aborts_if</b> scaled_value &gt; <a href="fixed_point32.md#0x1_fixed_point32_MAX_U64">MAX_U64</a>;
}
</code></pre>




<a id="0x1_fixed_point32_spec_create_from_u64"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_create_from_u64">spec_create_from_u64</a>(val: num): <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {
   <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a> {value: val &lt;&lt; 32}
}
</code></pre>



<a id="@Specification_1_floor"></a>

### Function `floor`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_floor">floor</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_floor">spec_floor</a>(num);
</code></pre>




<a id="0x1_fixed_point32_spec_floor"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_floor">spec_floor</a>(val: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
   <b>let</b> fractional = val.value % (1 &lt;&lt; 32);
   <b>if</b> (fractional == 0) {
       val.value &gt;&gt; 32
   } <b>else</b> {
       (val.value - fractional) &gt;&gt; 32
   }
}
</code></pre>



<a id="@Specification_1_ceil"></a>

### Function `ceil`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_ceil">ceil</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>




<pre><code><b>pragma</b> verify_duration_estimate = 120;
<b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_ceil">spec_ceil</a>(num);
</code></pre>




<a id="0x1_fixed_point32_spec_ceil"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_ceil">spec_ceil</a>(val: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
   <b>let</b> fractional = val.value % (1 &lt;&lt; 32);
   <b>let</b> one = 1 &lt;&lt; 32;
   <b>if</b> (fractional == 0) {
       val.value &gt;&gt; 32
   } <b>else</b> {
       (val.value - fractional + one) &gt;&gt; 32
   }
}
</code></pre>



<a id="@Specification_1_round"></a>

### Function `round`


<pre><code><b>public</b> <b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_round">round</a>(num: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">fixed_point32::FixedPoint32</a>): u64
</code></pre>




<pre><code><b>pragma</b> verify_duration_estimate = 120;
<b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="fixed_point32.md#0x1_fixed_point32_spec_round">spec_round</a>(num);
</code></pre>




<a id="0x1_fixed_point32_spec_round"></a>


<pre><code><b>fun</b> <a href="fixed_point32.md#0x1_fixed_point32_spec_round">spec_round</a>(val: <a href="fixed_point32.md#0x1_fixed_point32_FixedPoint32">FixedPoint32</a>): u64 {
   <b>let</b> fractional = val.value % (1 &lt;&lt; 32);
   <b>let</b> boundary = (1 &lt;&lt; 32) / 2;
   <b>let</b> one = 1 &lt;&lt; 32;
   <b>if</b> (fractional &lt; boundary) {
       (val.value - fractional) &gt;&gt; 32
   } <b>else</b> {
       (val.value - fractional + one) &gt;&gt; 32
   }
}
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/hash.md
================================================

<a id="0x1_hash"></a>

# Module `0x1::hash`

Module which defines SHA hashes for byte vectors.

The functions in this module are natively declared both in the Move runtime
as in the Move prover's prelude.


-  [Function `sha2_256`](#0x1_hash_sha2_256)
-  [Function `sha3_256`](#0x1_hash_sha3_256)


<pre><code></code></pre>



<a id="0x1_hash_sha2_256"></a>

## Function `sha2_256`



<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_hash_sha2_256">sha2_256</a>(data: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>public</b> <b>fun</b> <a href="hash.md#0x1_hash_sha2_256">sha2_256</a>(data: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>

<a id="0x1_hash_sha3_256"></a>

## Function `sha3_256`



<pre><code><b>public</b> <b>fun</b> <a href="hash.md#0x1_hash_sha3_256">sha3_256</a>(data: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>public</b> <b>fun</b> <a href="hash.md#0x1_hash_sha3_256">sha3_256</a>(data: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/option.md
================================================

<a id="0x1_option"></a>

# Module `0x1::option`

This module defines the Option type and its methods to represent and handle an optional value.


-  [Struct `Option`](#0x1_option_Option)
-  [Constants](#@Constants_0)
-  [Function `none`](#0x1_option_none)
-  [Function `some`](#0x1_option_some)
-  [Function `from_vec`](#0x1_option_from_vec)
-  [Function `is_none`](#0x1_option_is_none)
-  [Function `is_some`](#0x1_option_is_some)
-  [Function `contains`](#0x1_option_contains)
-  [Function `borrow`](#0x1_option_borrow)
-  [Function `borrow_with_default`](#0x1_option_borrow_with_default)
-  [Function `get_with_default`](#0x1_option_get_with_default)
-  [Function `fill`](#0x1_option_fill)
-  [Function `extract`](#0x1_option_extract)
-  [Function `borrow_mut`](#0x1_option_borrow_mut)
-  [Function `swap`](#0x1_option_swap)
-  [Function `swap_or_fill`](#0x1_option_swap_or_fill)
-  [Function `destroy_with_default`](#0x1_option_destroy_with_default)
-  [Function `destroy_some`](#0x1_option_destroy_some)
-  [Function `destroy_none`](#0x1_option_destroy_none)
-  [Function `to_vec`](#0x1_option_to_vec)
-  [Function `for_each`](#0x1_option_for_each)
-  [Function `for_each_ref`](#0x1_option_for_each_ref)
-  [Function `for_each_mut`](#0x1_option_for_each_mut)
-  [Function `fold`](#0x1_option_fold)
-  [Function `map`](#0x1_option_map)
-  [Function `map_ref`](#0x1_option_map_ref)
-  [Function `filter`](#0x1_option_filter)
-  [Function `any`](#0x1_option_any)
-  [Function `destroy`](#0x1_option_destroy)
-  [Specification](#@Specification_1)
    -  [Helper Schema](#@Helper_Schema_2)
    -  [Struct `Option`](#@Specification_1_Option)
    -  [Function `none`](#@Specification_1_none)
    -  [Function `some`](#@Specification_1_some)
    -  [Function `from_vec`](#@Specification_1_from_vec)
    -  [Function `is_none`](#@Specification_1_is_none)
    -  [Function `is_some`](#@Specification_1_is_some)
    -  [Function `contains`](#@Specification_1_contains)
    -  [Function `borrow`](#@Specification_1_borrow)
    -  [Function `borrow_with_default`](#@Specification_1_borrow_with_default)
    -  [Function `get_with_default`](#@Specification_1_get_with_default)
    -  [Function `fill`](#@Specification_1_fill)
    -  [Function `extract`](#@Specification_1_extract)
    -  [Function `borrow_mut`](#@Specification_1_borrow_mut)
    -  [Function `swap`](#@Specification_1_swap)
    -  [Function `swap_or_fill`](#@Specification_1_swap_or_fill)
    -  [Function `destroy_with_default`](#@Specification_1_destroy_with_default)
    -  [Function `destroy_some`](#@Specification_1_destroy_some)
    -  [Function `destroy_none`](#@Specification_1_destroy_none)
    -  [Function `to_vec`](#@Specification_1_to_vec)


<pre><code><b>use</b> <a href="vector.md#0x1_vector">0x1::vector</a>;
</code></pre>



<a id="0x1_option_Option"></a>

## Struct `Option`

Abstraction of a value that may or may not be present. Implemented with a vector of size
zero or one because Move bytecode does not have ADTs.


<pre><code><b>struct</b> <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>vec: <a href="vector.md#0x1_vector">vector</a>&lt;Element&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_option_EOPTION_IS_SET"></a>

The <code><a href="option.md#0x1_option_Option">Option</a></code> is in an invalid state for the operation attempted.
The <code><a href="option.md#0x1_option_Option">Option</a></code> is <code>Some</code> while it should be <code>None</code>.


<pre><code><b>const</b> <a href="option.md#0x1_option_EOPTION_IS_SET">EOPTION_IS_SET</a>: u64 = 262144;
</code></pre>



<a id="0x1_option_EOPTION_NOT_SET"></a>

The <code><a href="option.md#0x1_option_Option">Option</a></code> is in an invalid state for the operation attempted.
The <code><a href="option.md#0x1_option_Option">Option</a></code> is <code>None</code> while it should be <code>Some</code>.


<pre><code><b>const</b> <a href="option.md#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</a>: u64 = 262145;
</code></pre>



<a id="0x1_option_EOPTION_VEC_TOO_LONG"></a>

Cannot construct an option from a vector with 2 or more elements.


<pre><code><b>const</b> <a href="option.md#0x1_option_EOPTION_VEC_TOO_LONG">EOPTION_VEC_TOO_LONG</a>: u64 = 262146;
</code></pre>



<a id="0x1_option_none"></a>

## Function `none`

Return an empty <code><a href="option.md#0x1_option_Option">Option</a></code>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_none">none</a>&lt;Element&gt;(): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_none">none</a>&lt;Element&gt;(): <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; {
    <a href="option.md#0x1_option_Option">Option</a> { vec: <a href="vector.md#0x1_vector_empty">vector::empty</a>() }
}
</code></pre>



</details>

<a id="0x1_option_some"></a>

## Function `some`

Return an <code><a href="option.md#0x1_option_Option">Option</a></code> containing <code>e</code>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_some">some</a>&lt;Element&gt;(e: Element): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_some">some</a>&lt;Element&gt;(e: Element): <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; {
    <a href="option.md#0x1_option_Option">Option</a> { vec: <a href="vector.md#0x1_vector_singleton">vector::singleton</a>(e) }
}
</code></pre>



</details>

<a id="0x1_option_from_vec"></a>

## Function `from_vec`



<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_from_vec">from_vec</a>&lt;Element&gt;(vec: <a href="vector.md#0x1_vector">vector</a>&lt;Element&gt;): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_from_vec">from_vec</a>&lt;Element&gt;(vec: <a href="vector.md#0x1_vector">vector</a>&lt;Element&gt;): <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; {
    <b>assert</b>!(<a href="vector.md#0x1_vector_length">vector::length</a>(&vec) &lt;= 1, <a href="option.md#0x1_option_EOPTION_VEC_TOO_LONG">EOPTION_VEC_TOO_LONG</a>);
    <a href="option.md#0x1_option_Option">Option</a> { vec }
}
</code></pre>



</details>

<a id="0x1_option_is_none"></a>

## Function `is_none`

Return true if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_is_none">is_none</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_is_none">is_none</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): bool {
    <a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(&t.vec)
}
</code></pre>



</details>

<a id="0x1_option_is_some"></a>

## Function `is_some`

Return true if <code>t</code> holds a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_is_some">is_some</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_is_some">is_some</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): bool {
    !<a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(&t.vec)
}
</code></pre>



</details>

<a id="0x1_option_contains"></a>

## Function `contains`

Return true if the value in <code>t</code> is equal to <code>e_ref</code>
Always returns <code><b>false</b></code> if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_contains">contains</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, e_ref: &Element): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_contains">contains</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, e_ref: &Element): bool {
    <a href="vector.md#0x1_vector_contains">vector::contains</a>(&t.vec, e_ref)
}
</code></pre>



</details>

<a id="0x1_option_borrow"></a>

## Function `borrow`

Return an immutable reference to the value inside <code>t</code>
Aborts if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow">borrow</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): &Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow">borrow</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): &Element {
    <b>assert</b>!(<a href="option.md#0x1_option_is_some">is_some</a>(t), <a href="option.md#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</a>);
    <a href="vector.md#0x1_vector_borrow">vector::borrow</a>(&t.vec, 0)
}
</code></pre>



</details>

<a id="0x1_option_borrow_with_default"></a>

## Function `borrow_with_default`

Return a reference to the value inside <code>t</code> if it holds one
Return <code>default_ref</code> if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow_with_default">borrow_with_default</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, default_ref: &Element): &Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow_with_default">borrow_with_default</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, default_ref: &Element): &Element {
    <b>let</b> vec_ref = &t.vec;
    <b>if</b> (<a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(vec_ref)) default_ref
    <b>else</b> <a href="vector.md#0x1_vector_borrow">vector::borrow</a>(vec_ref, 0)
}
</code></pre>



</details>

<a id="0x1_option_get_with_default"></a>

## Function `get_with_default`

Return the value inside <code>t</code> if it holds one
Return <code>default</code> if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_get_with_default">get_with_default</a>&lt;Element: <b>copy</b>, drop&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, default: Element): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_get_with_default">get_with_default</a>&lt;Element: <b>copy</b> + drop&gt;(
    t: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;,
    default: Element,
): Element {
    <b>let</b> vec_ref = &t.vec;
    <b>if</b> (<a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(vec_ref)) default
    <b>else</b> *<a href="vector.md#0x1_vector_borrow">vector::borrow</a>(vec_ref, 0)
}
</code></pre>



</details>

<a id="0x1_option_fill"></a>

## Function `fill`

Convert the none option <code>t</code> to a some option by adding <code>e</code>.
Aborts if <code>t</code> already holds a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_fill">fill</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, e: Element)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_fill">fill</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, e: Element) {
    <b>let</b> vec_ref = &<b>mut</b> t.vec;
    <b>if</b> (<a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(vec_ref)) <a href="vector.md#0x1_vector_push_back">vector::push_back</a>(vec_ref, e)
    <b>else</b> <b>abort</b> <a href="option.md#0x1_option_EOPTION_IS_SET">EOPTION_IS_SET</a>
}
</code></pre>



</details>

<a id="0x1_option_extract"></a>

## Function `extract`

Convert a <code>some</code> option to a <code>none</code> by removing and returning the value stored inside <code>t</code>
Aborts if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_extract">extract</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_extract">extract</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): Element {
    <b>assert</b>!(<a href="option.md#0x1_option_is_some">is_some</a>(t), <a href="option.md#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</a>);
    <a href="vector.md#0x1_vector_pop_back">vector::pop_back</a>(&<b>mut</b> t.vec)
}
</code></pre>



</details>

<a id="0x1_option_borrow_mut"></a>

## Function `borrow_mut`

Return a mutable reference to the value inside <code>t</code>
Aborts if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow_mut">borrow_mut</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): &<b>mut</b> Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow_mut">borrow_mut</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): &<b>mut</b> Element {
    <b>assert</b>!(<a href="option.md#0x1_option_is_some">is_some</a>(t), <a href="option.md#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</a>);
    <a href="vector.md#0x1_vector_borrow_mut">vector::borrow_mut</a>(&<b>mut</b> t.vec, 0)
}
</code></pre>



</details>

<a id="0x1_option_swap"></a>

## Function `swap`

Swap the old value inside <code>t</code> with <code>e</code> and return the old value
Aborts if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_swap">swap</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, e: Element): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_swap">swap</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, e: Element): Element {
    <b>assert</b>!(<a href="option.md#0x1_option_is_some">is_some</a>(t), <a href="option.md#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</a>);
    <b>let</b> vec_ref = &<b>mut</b> t.vec;
    <b>let</b> old_value = <a href="vector.md#0x1_vector_pop_back">vector::pop_back</a>(vec_ref);
    <a href="vector.md#0x1_vector_push_back">vector::push_back</a>(vec_ref, e);
    old_value
}
</code></pre>



</details>

<a id="0x1_option_swap_or_fill"></a>

## Function `swap_or_fill`

Swap the old value inside <code>t</code> with <code>e</code> and return the old value;
or if there is no old value, fill it with <code>e</code>.
Different from swap(), swap_or_fill() allows for <code>t</code> not holding a value.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_swap_or_fill">swap_or_fill</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, e: Element): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_swap_or_fill">swap_or_fill</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, e: Element): <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; {
    <b>let</b> vec_ref = &<b>mut</b> t.vec;
    <b>let</b> old_value = <b>if</b> (<a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(vec_ref)) <a href="option.md#0x1_option_none">none</a>()
        <b>else</b> <a href="option.md#0x1_option_some">some</a>(<a href="vector.md#0x1_vector_pop_back">vector::pop_back</a>(vec_ref));
    <a href="vector.md#0x1_vector_push_back">vector::push_back</a>(vec_ref, e);
    old_value
}
</code></pre>



</details>

<a id="0x1_option_destroy_with_default"></a>

## Function `destroy_with_default`

Destroys <code>t.</code> If <code>t</code> holds a value, return it. Returns <code>default</code> otherwise


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_with_default">destroy_with_default</a>&lt;Element: drop&gt;(t: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, default: Element): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_with_default">destroy_with_default</a>&lt;Element: drop&gt;(t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, default: Element): Element {
    <b>let</b> <a href="option.md#0x1_option_Option">Option</a> { vec } = t;
    <b>if</b> (<a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(&<b>mut</b> vec)) default
    <b>else</b> <a href="vector.md#0x1_vector_pop_back">vector::pop_back</a>(&<b>mut</b> vec)
}
</code></pre>



</details>

<a id="0x1_option_destroy_some"></a>

## Function `destroy_some`

Unpack <code>t</code> and return its contents
Aborts if <code>t</code> does not hold a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_some">destroy_some</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_some">destroy_some</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): Element {
    <b>assert</b>!(<a href="option.md#0x1_option_is_some">is_some</a>(&t), <a href="option.md#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</a>);
    <b>let</b> <a href="option.md#0x1_option_Option">Option</a> { vec } = t;
    <b>let</b> elem = <a href="vector.md#0x1_vector_pop_back">vector::pop_back</a>(&<b>mut</b> vec);
    <a href="vector.md#0x1_vector_destroy_empty">vector::destroy_empty</a>(vec);
    elem
}
</code></pre>



</details>

<a id="0x1_option_destroy_none"></a>

## Function `destroy_none`

Unpack <code>t</code>
Aborts if <code>t</code> holds a value


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_none">destroy_none</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_none">destroy_none</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;) {
    <b>assert</b>!(<a href="option.md#0x1_option_is_none">is_none</a>(&t), <a href="option.md#0x1_option_EOPTION_IS_SET">EOPTION_IS_SET</a>);
    <b>let</b> <a href="option.md#0x1_option_Option">Option</a> { vec } = t;
    <a href="vector.md#0x1_vector_destroy_empty">vector::destroy_empty</a>(vec)
}
</code></pre>



</details>

<a id="0x1_option_to_vec"></a>

## Function `to_vec`

Convert <code>t</code> into a vector of length 1 if it is <code>Some</code>,
and an empty vector otherwise


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_to_vec">to_vec</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): <a href="vector.md#0x1_vector">vector</a>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_to_vec">to_vec</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): <a href="vector.md#0x1_vector">vector</a>&lt;Element&gt; {
    <b>let</b> <a href="option.md#0x1_option_Option">Option</a> { vec } = t;
    vec
}
</code></pre>



</details>

<a id="0x1_option_for_each"></a>

## Function `for_each`

Apply the function to the optional element, consuming it. Does nothing if no value present.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_for_each">for_each</a>&lt;Element&gt;(o: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, f: |Element|)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_for_each">for_each</a>&lt;Element&gt;(o: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, f: |Element|) {
    <b>if</b> (<a href="option.md#0x1_option_is_some">is_some</a>(&o)) {
        f(<a href="option.md#0x1_option_destroy_some">destroy_some</a>(o))
    } <b>else</b> {
        <a href="option.md#0x1_option_destroy_none">destroy_none</a>(o)
    }
}
</code></pre>



</details>

<a id="0x1_option_for_each_ref"></a>

## Function `for_each_ref`

Apply the function to the optional element reference. Does nothing if no value present.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_for_each_ref">for_each_ref</a>&lt;Element&gt;(o: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, f: |&Element|)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_for_each_ref">for_each_ref</a>&lt;Element&gt;(o: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, f: |&Element|) {
    <b>if</b> (<a href="option.md#0x1_option_is_some">is_some</a>(o)) {
        f(<a href="option.md#0x1_option_borrow">borrow</a>(o))
    }
}
</code></pre>



</details>

<a id="0x1_option_for_each_mut"></a>

## Function `for_each_mut`

Apply the function to the optional element reference. Does nothing if no value present.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_for_each_mut">for_each_mut</a>&lt;Element&gt;(o: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, f: |&<b>mut</b> Element|)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_for_each_mut">for_each_mut</a>&lt;Element&gt;(o: &<b>mut</b> <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, f: |&<b>mut</b> Element|) {
    <b>if</b> (<a href="option.md#0x1_option_is_some">is_some</a>(o)) {
        f(<a href="option.md#0x1_option_borrow_mut">borrow_mut</a>(o))
    }
}
</code></pre>



</details>

<a id="0x1_option_fold"></a>

## Function `fold`

Folds the function over the optional element.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_fold">fold</a>&lt;Accumulator, Element&gt;(o: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, init: Accumulator, f: |(Accumulator, Element)|Accumulator): Accumulator
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_fold">fold</a>&lt;Accumulator, Element&gt;(
    o: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;,
    init: Accumulator,
    f: |Accumulator,Element|Accumulator
): Accumulator {
    <b>if</b> (<a href="option.md#0x1_option_is_some">is_some</a>(&o)) {
        f(init, <a href="option.md#0x1_option_destroy_some">destroy_some</a>(o))
    } <b>else</b> {
        <a href="option.md#0x1_option_destroy_none">destroy_none</a>(o);
        init
    }
}
</code></pre>



</details>

<a id="0x1_option_map"></a>

## Function `map`

Maps the content of an option.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_map">map</a>&lt;Element, OtherElement&gt;(o: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, f: |Element|OtherElement): <a href="option.md#0x1_option_Option">option::Option</a>&lt;OtherElement&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_map">map</a>&lt;Element, OtherElement&gt;(o: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, f: |Element|OtherElement): <a href="option.md#0x1_option_Option">Option</a>&lt;OtherElement&gt; {
    <b>if</b> (<a href="option.md#0x1_option_is_some">is_some</a>(&o)) {
        <a href="option.md#0x1_option_some">some</a>(f(<a href="option.md#0x1_option_destroy_some">destroy_some</a>(o)))
    } <b>else</b> {
        <a href="option.md#0x1_option_destroy_none">destroy_none</a>(o);
        <a href="option.md#0x1_option_none">none</a>()
    }
}
</code></pre>



</details>

<a id="0x1_option_map_ref"></a>

## Function `map_ref`

Maps the content of an option without destroying the original option.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_map_ref">map_ref</a>&lt;Element, OtherElement&gt;(o: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, f: |&Element|OtherElement): <a href="option.md#0x1_option_Option">option::Option</a>&lt;OtherElement&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_map_ref">map_ref</a>&lt;Element, OtherElement&gt;(
    o: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, f: |&Element|OtherElement): <a href="option.md#0x1_option_Option">Option</a>&lt;OtherElement&gt; {
    <b>if</b> (<a href="option.md#0x1_option_is_some">is_some</a>(o)) {
        <a href="option.md#0x1_option_some">some</a>(f(<a href="option.md#0x1_option_borrow">borrow</a>(o)))
    } <b>else</b> {
        <a href="option.md#0x1_option_none">none</a>()
    }
}
</code></pre>



</details>

<a id="0x1_option_filter"></a>

## Function `filter`

Filters the content of an option


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_filter">filter</a>&lt;Element: drop&gt;(o: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, f: |&Element|bool): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_filter">filter</a>&lt;Element:drop&gt;(o: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, f: |&Element|bool): <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; {
    <b>if</b> (<a href="option.md#0x1_option_is_some">is_some</a>(&o) && f(<a href="option.md#0x1_option_borrow">borrow</a>(&o))) {
        o
    } <b>else</b> {
        <a href="option.md#0x1_option_none">none</a>()
    }
}
</code></pre>



</details>

<a id="0x1_option_any"></a>

## Function `any`

Returns true if the option contains an element which satisfies predicate.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_any">any</a>&lt;Element&gt;(o: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, p: |&Element|bool): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_any">any</a>&lt;Element&gt;(o: &<a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, p: |&Element|bool): bool {
    <a href="option.md#0x1_option_is_some">is_some</a>(o) && p(<a href="option.md#0x1_option_borrow">borrow</a>(o))
}
</code></pre>



</details>

<a id="0x1_option_destroy"></a>

## Function `destroy`

Utility function to destroy an option that is not droppable.


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy">destroy</a>&lt;Element&gt;(o: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, d: |Element|)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> inline <b>fun</b> <a href="option.md#0x1_option_destroy">destroy</a>&lt;Element&gt;(o: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, d: |Element|) {
    <b>let</b> vec = <a href="option.md#0x1_option_to_vec">to_vec</a>(o);
    <a href="vector.md#0x1_vector_destroy">vector::destroy</a>(vec, |e| d(e));
}
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification




<pre><code><b>pragma</b> aborts_if_is_strict;
</code></pre>



<a id="@Helper_Schema_2"></a>

### Helper Schema



<a id="0x1_option_AbortsIfNone"></a>


<pre><code><b>schema</b> <a href="option.md#0x1_option_AbortsIfNone">AbortsIfNone</a>&lt;Element&gt; {
    t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;;
    <b>aborts_if</b> <a href="option.md#0x1_option_spec_is_none">spec_is_none</a>(t) <b>with</b> <a href="option.md#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</a>;
}
</code></pre>



<a id="@Specification_1_Option"></a>

### Struct `Option`


<pre><code><b>struct</b> <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<dl>
<dt>
<code>vec: <a href="vector.md#0x1_vector">vector</a>&lt;Element&gt;</code>
</dt>
<dd>

</dd>
</dl>


The size of vector is always less than equal to 1
because it's 0 for "none" or 1 for "some".


<pre><code><b>invariant</b> len(vec) &lt;= 1;
</code></pre>



<a id="@Specification_1_none"></a>

### Function `none`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_none">none</a>&lt;Element&gt;(): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_none">spec_none</a>&lt;Element&gt;();
</code></pre>




<a id="0x1_option_spec_none"></a>


<pre><code><b>fun</b> <a href="option.md#0x1_option_spec_none">spec_none</a>&lt;Element&gt;(): <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; {
   <a href="option.md#0x1_option_Option">Option</a>{ vec: vec() }
}
</code></pre>



<a id="@Specification_1_some"></a>

### Function `some`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_some">some</a>&lt;Element&gt;(e: Element): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_some">spec_some</a>(e);
</code></pre>




<a id="0x1_option_spec_some"></a>


<pre><code><b>fun</b> <a href="option.md#0x1_option_spec_some">spec_some</a>&lt;Element&gt;(e: Element): <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt; {
   <a href="option.md#0x1_option_Option">Option</a>{ vec: vec(e) }
}
</code></pre>



<a id="@Specification_1_from_vec"></a>

### Function `from_vec`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_from_vec">from_vec</a>&lt;Element&gt;(vec: <a href="vector.md#0x1_vector">vector</a>&lt;Element&gt;): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>




<pre><code><b>aborts_if</b> <a href="vector.md#0x1_vector_length">vector::length</a>(vec) &gt; 1;
</code></pre>



<a id="@Specification_1_is_none"></a>

### Function `is_none`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_is_none">is_none</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_is_none">spec_is_none</a>(t);
</code></pre>




<a id="0x1_option_spec_is_none"></a>


<pre><code><b>fun</b> <a href="option.md#0x1_option_spec_is_none">spec_is_none</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): bool {
   <a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(t.vec)
}
</code></pre>



<a id="@Specification_1_is_some"></a>

### Function `is_some`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_is_some">is_some</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_is_some">spec_is_some</a>(t);
</code></pre>




<a id="0x1_option_spec_is_some"></a>


<pre><code><b>fun</b> <a href="option.md#0x1_option_spec_is_some">spec_is_some</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): bool {
   !<a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(t.vec)
}
</code></pre>



<a id="@Specification_1_contains"></a>

### Function `contains`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_contains">contains</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, e_ref: &Element): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_contains">spec_contains</a>(t, e_ref);
</code></pre>




<a id="0x1_option_spec_contains"></a>


<pre><code><b>fun</b> <a href="option.md#0x1_option_spec_contains">spec_contains</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;, e: Element): bool {
   <a href="option.md#0x1_option_is_some">is_some</a>(t) && <a href="option.md#0x1_option_borrow">borrow</a>(t) == e
}
</code></pre>



<a id="@Specification_1_borrow"></a>

### Function `borrow`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow">borrow</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): &Element
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="option.md#0x1_option_AbortsIfNone">AbortsIfNone</a>&lt;Element&gt;;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t);
</code></pre>




<a id="0x1_option_spec_borrow"></a>


<pre><code><b>fun</b> <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">Option</a>&lt;Element&gt;): Element {
   t.vec[0]
}
</code></pre>



<a id="@Specification_1_borrow_with_default"></a>

### Function `borrow_with_default`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow_with_default">borrow_with_default</a>&lt;Element&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, default_ref: &Element): &Element
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == (<b>if</b> (<a href="option.md#0x1_option_spec_is_some">spec_is_some</a>(t)) <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t) <b>else</b> default_ref);
</code></pre>



<a id="@Specification_1_get_with_default"></a>

### Function `get_with_default`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_get_with_default">get_with_default</a>&lt;Element: <b>copy</b>, drop&gt;(t: &<a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, default: Element): Element
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == (<b>if</b> (<a href="option.md#0x1_option_spec_is_some">spec_is_some</a>(t)) <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t) <b>else</b> default);
</code></pre>



<a id="@Specification_1_fill"></a>

### Function `fill`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_fill">fill</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, e: Element)
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <a href="option.md#0x1_option_spec_is_some">spec_is_some</a>(t) <b>with</b> <a href="option.md#0x1_option_EOPTION_IS_SET">EOPTION_IS_SET</a>;
<b>ensures</b> <a href="option.md#0x1_option_spec_is_some">spec_is_some</a>(t);
<b>ensures</b> <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t) == e;
</code></pre>



<a id="@Specification_1_extract"></a>

### Function `extract`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_extract">extract</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): Element
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="option.md#0x1_option_AbortsIfNone">AbortsIfNone</a>&lt;Element&gt;;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(<b>old</b>(t));
<b>ensures</b> <a href="option.md#0x1_option_spec_is_none">spec_is_none</a>(t);
</code></pre>



<a id="@Specification_1_borrow_mut"></a>

### Function `borrow_mut`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_borrow_mut">borrow_mut</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): &<b>mut</b> Element
</code></pre>




<pre><code><b>include</b> <a href="option.md#0x1_option_AbortsIfNone">AbortsIfNone</a>&lt;Element&gt;;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t);
<b>ensures</b> t == <b>old</b>(t);
</code></pre>



<a id="@Specification_1_swap"></a>

### Function `swap`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_swap">swap</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, e: Element): Element
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="option.md#0x1_option_AbortsIfNone">AbortsIfNone</a>&lt;Element&gt;;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(<b>old</b>(t));
<b>ensures</b> <a href="option.md#0x1_option_spec_is_some">spec_is_some</a>(t);
<b>ensures</b> <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t) == e;
</code></pre>



<a id="@Specification_1_swap_or_fill"></a>

### Function `swap_or_fill`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_swap_or_fill">swap_or_fill</a>&lt;Element&gt;(t: &<b>mut</b> <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, e: Element): <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == <b>old</b>(t);
<b>ensures</b> <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t) == e;
</code></pre>



<a id="@Specification_1_destroy_with_default"></a>

### Function `destroy_with_default`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_with_default">destroy_with_default</a>&lt;Element: drop&gt;(t: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;, default: Element): Element
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == (<b>if</b> (<a href="option.md#0x1_option_spec_is_some">spec_is_some</a>(t)) <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t) <b>else</b> default);
</code></pre>



<a id="@Specification_1_destroy_some"></a>

### Function `destroy_some`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_some">destroy_some</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): Element
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>include</b> <a href="option.md#0x1_option_AbortsIfNone">AbortsIfNone</a>&lt;Element&gt;;
<b>ensures</b> result == <a href="option.md#0x1_option_spec_borrow">spec_borrow</a>(t);
</code></pre>



<a id="@Specification_1_destroy_none"></a>

### Function `destroy_none`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_destroy_none">destroy_none</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;)
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <a href="option.md#0x1_option_spec_is_some">spec_is_some</a>(t) <b>with</b> <a href="option.md#0x1_option_EOPTION_IS_SET">EOPTION_IS_SET</a>;
</code></pre>



<a id="@Specification_1_to_vec"></a>

### Function `to_vec`


<pre><code><b>public</b> <b>fun</b> <a href="option.md#0x1_option_to_vec">to_vec</a>&lt;Element&gt;(t: <a href="option.md#0x1_option_Option">option::Option</a>&lt;Element&gt;): <a href="vector.md#0x1_vector">vector</a>&lt;Element&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> <b>false</b>;
<b>ensures</b> result == t.vec;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/overview.md
================================================

<a id="@Move_Stdlib_Modules_0"></a>

# Move Stdlib Modules


This is the reference documentation of the Move standard library.
For on overview of the Move language, see the [Move Book][move-book].


<a id="@Index_1"></a>

## Index


-  [`0x1::acl`](acl.md#0x1_acl)
-  [`0x1::bcs`](bcs.md#0x1_bcs)
-  [`0x1::bit_vector`](bit_vector.md#0x1_bit_vector)
-  [`0x1::error`](error.md#0x1_error)
-  [`0x1::features`](features.md#0x1_features)
-  [`0x1::fixed_point32`](fixed_point32.md#0x1_fixed_point32)
-  [`0x1::hash`](hash.md#0x1_hash)
-  [`0x1::option`](option.md#0x1_option)
-  [`0x1::signer`](signer.md#0x1_signer)
-  [`0x1::string`](string.md#0x1_string)
-  [`0x1::vector`](vector.md#0x1_vector)


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/signer.md
================================================

<a id="0x1_signer"></a>

# Module `0x1::signer`



-  [Function `borrow_address`](#0x1_signer_borrow_address)
-  [Function `address_of`](#0x1_signer_address_of)
-  [Specification](#@Specification_0)


<pre><code></code></pre>



<a id="0x1_signer_borrow_address"></a>

## Function `borrow_address`

Borrows the address of the signer
Conceptually, you can think of the <code><a href="signer.md#0x1_signer">signer</a></code> as being a struct wrapper around an
address
```
struct signer has drop { addr: address }
```
<code>borrow_address</code> borrows this inner field


<pre><code><b>public</b> <b>fun</b> <a href="signer.md#0x1_signer_borrow_address">borrow_address</a>(s: &<a href="signer.md#0x1_signer">signer</a>): &<b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>public</b> <b>fun</b> <a href="signer.md#0x1_signer_borrow_address">borrow_address</a>(s: &<a href="signer.md#0x1_signer">signer</a>): &<b>address</b>;
</code></pre>



</details>

<a id="0x1_signer_address_of"></a>

## Function `address_of`



<pre><code><b>public</b> <b>fun</b> <a href="signer.md#0x1_signer_address_of">address_of</a>(s: &<a href="signer.md#0x1_signer">signer</a>): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="signer.md#0x1_signer_address_of">address_of</a>(s: &<a href="signer.md#0x1_signer">signer</a>): <b>address</b> {
    *<a href="signer.md#0x1_signer_borrow_address">borrow_address</a>(s)
}
</code></pre>



</details>

<a id="@Specification_0"></a>

## Specification

Return true only if <code>s</code> is a transaction signer. This is a spec function only available in spec.


<a id="0x1_signer_is_txn_signer"></a>


<pre><code><b>native</b> <b>fun</b> <a href="signer.md#0x1_signer_is_txn_signer">is_txn_signer</a>(s: <a href="signer.md#0x1_signer">signer</a>): bool;
</code></pre>


Return true only if <code>a</code> is a transaction signer address. This is a spec function only available in spec.


<a id="0x1_signer_is_txn_signer_addr"></a>


<pre><code><b>native</b> <b>fun</b> <a href="signer.md#0x1_signer_is_txn_signer_addr">is_txn_signer_addr</a>(a: <b>address</b>): bool;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc/string.md
================================================

<a id="0x1_string"></a>

# Module `0x1::string`

The <code><a href="string.md#0x1_string">string</a></code> module defines the <code><a href="string.md#0x1_string_String">String</a></code> type which represents UTF8 encoded strings.


-  [Struct `String`](#0x1_string_String)
-  [Constants](#@Constants_0)
-  [Function `utf8`](#0x1_string_utf8)
-  [Function `try_utf8`](#0x1_string_try_utf8)
-  [Function `bytes`](#0x1_string_bytes)
-  [Function `is_empty`](#0x1_string_is_empty)
-  [Function `length`](#0x1_string_length)
-  [Function `append`](#0x1_string_append)
-  [Function `append_utf8`](#0x1_string_append_utf8)
-  [Function `insert`](#0x1_string_insert)
-  [Function `sub_string`](#0x1_string_sub_string)
-  [Function `index_of`](#0x1_string_index_of)
-  [Function `internal_check_utf8`](#0x1_string_internal_check_utf8)
-  [Function `internal_is_char_boundary`](#0x1_string_internal_is_char_boundary)
-  [Function `internal_sub_string`](#0x1_string_internal_sub_string)
-  [Function `internal_index_of`](#0x1_string_internal_index_of)
-  [Specification](#@Specification_1)
    -  [Function `internal_check_utf8`](#@Specification_1_internal_check_utf8)
    -  [Function `internal_is_char_boundary`](#@Specification_1_internal_is_char_boundary)
    -  [Function `internal_sub_string`](#@Specification_1_internal_sub_string)
    -  [Function `internal_index_of`](#@Specification_1_internal_index_of)


<pre><code><b>use</b> <a href="option.md#0x1_option">0x1::option</a>;
<b>use</b> <a href="vector.md#0x1_vector">0x1::vector</a>;
</code></pre>



<a id="0x1_string_String"></a>

## Struct `String`

A <code><a href="string.md#0x1_string_String">String</a></code> holds a sequence of bytes which is guaranteed to be in utf8 format.


<pre><code><b>struct</b> <a href="string.md#0x1_string_String">String</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bytes: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_string_EINVALID_INDEX"></a>

Index out of range.


<pre><code><b>const</b> <a href="string.md#0x1_string_EINVALID_INDEX">EINVALID_INDEX</a>: u64 = 2;
</code></pre>



<a id="0x1_string_EINVALID_UTF8"></a>

An invalid UTF8 encoding.


<pre><code><b>const</b> <a href="string.md#0x1_string_EINVALID_UTF8">EINVALID_UTF8</a>: u64 = 1;
</code></pre>



<a id="0x1_string_utf8"></a>

## Function `utf8`

Creates a new string from a sequence of bytes. Aborts if the bytes do not represent valid utf8.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_utf8">utf8</a>(bytes: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_utf8">utf8</a>(bytes: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="string.md#0x1_string_String">String</a> {
    <b>assert</b>!(<a href="string.md#0x1_string_internal_check_utf8">internal_check_utf8</a>(&bytes), <a href="string.md#0x1_string_EINVALID_UTF8">EINVALID_UTF8</a>);
    <a href="string.md#0x1_string_String">String</a>{bytes}
}
</code></pre>



</details>

<a id="0x1_string_try_utf8"></a>

## Function `try_utf8`

Tries to create a new string from a sequence of bytes.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_try_utf8">try_utf8</a>(bytes: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="option.md#0x1_option_Option">option::Option</a>&lt;<a href="string.md#0x1_string_String">string::String</a>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_try_utf8">try_utf8</a>(bytes: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): Option&lt;<a href="string.md#0x1_string_String">String</a>&gt; {
    <b>if</b> (<a href="string.md#0x1_string_internal_check_utf8">internal_check_utf8</a>(&bytes)) {
        <a href="option.md#0x1_option_some">option::some</a>(<a href="string.md#0x1_string_String">String</a>{bytes})
    } <b>else</b> {
        <a href="option.md#0x1_option_none">option::none</a>()
    }
}
</code></pre>



</details>

<a id="0x1_string_bytes"></a>

## Function `bytes`

Returns a reference to the underlying byte vector.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_bytes">bytes</a>(s: &<a href="string.md#0x1_string_String">string::String</a>): &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_bytes">bytes</a>(s: &<a href="string.md#0x1_string_String">String</a>): &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt; {
    &s.bytes
}
</code></pre>



</details>

<a id="0x1_string_is_empty"></a>

## Function `is_empty`

Checks whether this string is empty.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_is_empty">is_empty</a>(s: &<a href="string.md#0x1_string_String">string::String</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_is_empty">is_empty</a>(s: &<a href="string.md#0x1_string_String">String</a>): bool {
    <a href="vector.md#0x1_vector_is_empty">vector::is_empty</a>(&s.bytes)
}
</code></pre>



</details>

<a id="0x1_string_length"></a>

## Function `length`

Returns the length of this string, in bytes.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_length">length</a>(s: &<a href="string.md#0x1_string_String">string::String</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_length">length</a>(s: &<a href="string.md#0x1_string_String">String</a>): u64 {
    <a href="vector.md#0x1_vector_length">vector::length</a>(&s.bytes)
}
</code></pre>



</details>

<a id="0x1_string_append"></a>

## Function `append`

Appends a string.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_append">append</a>(s: &<b>mut</b> <a href="string.md#0x1_string_String">string::String</a>, r: <a href="string.md#0x1_string_String">string::String</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_append">append</a>(s: &<b>mut</b> <a href="string.md#0x1_string_String">String</a>, r: <a href="string.md#0x1_string_String">String</a>) {
    <a href="vector.md#0x1_vector_append">vector::append</a>(&<b>mut</b> s.bytes, r.bytes)
}
</code></pre>



</details>

<a id="0x1_string_append_utf8"></a>

## Function `append_utf8`

Appends bytes which must be in valid utf8 format.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_append_utf8">append_utf8</a>(s: &<b>mut</b> <a href="string.md#0x1_string_String">string::String</a>, bytes: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_append_utf8">append_utf8</a>(s: &<b>mut</b> <a href="string.md#0x1_string_String">String</a>, bytes: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;) {
    <a href="string.md#0x1_string_append">append</a>(s, <a href="string.md#0x1_string_utf8">utf8</a>(bytes))
}
</code></pre>



</details>

<a id="0x1_string_insert"></a>

## Function `insert`

Insert the other string at the byte index in given string. The index must be at a valid utf8 char
boundary.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_insert">insert</a>(s: &<b>mut</b> <a href="string.md#0x1_string_String">string::String</a>, at: u64, o: <a href="string.md#0x1_string_String">string::String</a>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_insert">insert</a>(s: &<b>mut</b> <a href="string.md#0x1_string_String">String</a>, at: u64, o: <a href="string.md#0x1_string_String">String</a>) {
    <b>let</b> bytes = &s.bytes;
    <b>assert</b>!(at &lt;= <a href="vector.md#0x1_vector_length">vector::length</a>(bytes) && <a href="string.md#0x1_string_internal_is_char_boundary">internal_is_char_boundary</a>(bytes, at), <a href="string.md#0x1_string_EINVALID_INDEX">EINVALID_INDEX</a>);
    <b>let</b> l = <a href="string.md#0x1_string_length">length</a>(s);
    <b>let</b> front = <a href="string.md#0x1_string_sub_string">sub_string</a>(s, 0, at);
    <b>let</b> end = <a href="string.md#0x1_string_sub_string">sub_string</a>(s, at, l);
    <a href="string.md#0x1_string_append">append</a>(&<b>mut</b> front, o);
    <a href="string.md#0x1_string_append">append</a>(&<b>mut</b> front, end);
    *s = front;
}
</code></pre>



</details>

<a id="0x1_string_sub_string"></a>

## Function `sub_string`

Returns a sub-string using the given byte indices, where <code>i</code> is the first byte position and <code>j</code> is the start
of the first byte not included (or the length of the string). The indices must be at valid utf8 char boundaries,
guaranteeing that the result is valid utf8.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_sub_string">sub_string</a>(s: &<a href="string.md#0x1_string_String">string::String</a>, i: u64, j: u64): <a href="string.md#0x1_string_String">string::String</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_sub_string">sub_string</a>(s: &<a href="string.md#0x1_string_String">String</a>, i: u64, j: u64): <a href="string.md#0x1_string_String">String</a> {
    <b>let</b> bytes = &s.bytes;
    <b>let</b> l = <a href="vector.md#0x1_vector_length">vector::length</a>(bytes);
    <b>assert</b>!(
        j &lt;= l && i &lt;= j && <a href="string.md#0x1_string_internal_is_char_boundary">internal_is_char_boundary</a>(bytes, i) && <a href="string.md#0x1_string_internal_is_char_boundary">internal_is_char_boundary</a>(bytes, j),
        <a href="string.md#0x1_string_EINVALID_INDEX">EINVALID_INDEX</a>
    );
    <a href="string.md#0x1_string_String">String</a> { bytes: <a href="string.md#0x1_string_internal_sub_string">internal_sub_string</a>(bytes, i, j) }
}
</code></pre>



</details>

<a id="0x1_string_index_of"></a>

## Function `index_of`

Computes the index of the first occurrence of a string. Returns <code><a href="string.md#0x1_string_length">length</a>(s)</code> if no occurrence found.


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_index_of">index_of</a>(s: &<a href="string.md#0x1_string_String">string::String</a>, r: &<a href="string.md#0x1_string_String">string::String</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_index_of">index_of</a>(s: &<a href="string.md#0x1_string_String">String</a>, r: &<a href="string.md#0x1_string_String">String</a>): u64 {
    <a href="string.md#0x1_string_internal_index_of">internal_index_of</a>(&s.bytes, &r.bytes)
}
</code></pre>



</details>

<a id="0x1_string_internal_check_utf8"></a>

## Function `internal_check_utf8`



<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_internal_check_utf8">internal_check_utf8</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>native</b> <b>fun</b> <a href="string.md#0x1_string_internal_check_utf8">internal_check_utf8</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool;
</code></pre>



</details>

<a id="0x1_string_internal_is_char_boundary"></a>

## Function `internal_is_char_boundary`



<pre><code><b>fun</b> <a href="string.md#0x1_string_internal_is_char_boundary">internal_is_char_boundary</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, i: u64): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="string.md#0x1_string_internal_is_char_boundary">internal_is_char_boundary</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, i: u64): bool;
</code></pre>



</details>

<a id="0x1_string_internal_sub_string"></a>

## Function `internal_sub_string`



<pre><code><b>fun</b> <a href="string.md#0x1_string_internal_sub_string">internal_sub_string</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, i: u64, j: u64): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="string.md#0x1_string_internal_sub_string">internal_sub_string</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, i: u64, j: u64): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;;
</code></pre>



</details>

<a id="0x1_string_internal_index_of"></a>

## Function `internal_index_of`



<pre><code><b>fun</b> <a href="string.md#0x1_string_internal_index_of">internal_index_of</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, r: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>native</b> <b>fun</b> <a href="string.md#0x1_string_internal_index_of">internal_index_of</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, r: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64;
</code></pre>



</details>

<a id="@Specification_1"></a>

## Specification


<a id="@Specification_1_internal_check_utf8"></a>

### Function `internal_check_utf8`


<pre><code><b>public</b> <b>fun</b> <a href="string.md#0x1_string_internal_check_utf8">internal_check_utf8</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="string.md#0x1_string_spec_internal_check_utf8">spec_internal_check_utf8</a>(v);
</code></pre>



<a id="@Specification_1_internal_is_char_boundary"></a>

### Function `internal_is_char_boundary`


<pre><code><b>fun</b> <a href="string.md#0x1_string_internal_is_char_boundary">internal_is_char_boundary</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, i: u64): bool
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="string.md#0x1_string_spec_internal_is_char_boundary">spec_internal_is_char_boundary</a>(v, i);
</code></pre>



<a id="@Specification_1_internal_sub_string"></a>

### Function `internal_sub_string`


<pre><code><b>fun</b> <a href="string.md#0x1_string_internal_sub_string">internal_sub_string</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, i: u64, j: u64): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="string.md#0x1_string_spec_internal_sub_string">spec_internal_sub_string</a>(v, i, j);
</code></pre>



<a id="@Specification_1_internal_index_of"></a>

### Function `internal_index_of`


<pre><code><b>fun</b> <a href="string.md#0x1_string_internal_index_of">internal_index_of</a>(v: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, r: &<a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64
</code></pre>




<pre><code><b>pragma</b> opaque;
<b>aborts_if</b> [abstract] <b>false</b>;
<b>ensures</b> [abstract] result == <a href="string.md#0x1_string_spec_internal_index_of">spec_internal_index_of</a>(v, r);
</code></pre>




<a id="0x1_string_spec_utf8"></a>


<pre><code><b>fun</b> <a href="string.md#0x1_string_spec_utf8">spec_utf8</a>(bytes: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): <a href="string.md#0x1_string_String">String</a> {
   <a href="string.md#0x1_string_String">String</a>{bytes}
}
</code></pre>




<a id="0x1_string_spec_internal_check_utf8"></a>


<pre><code><b>fun</b> <a href="string.md#0x1_string_spec_internal_check_utf8">spec_internal_check_utf8</a>(v: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): bool;
<a id="0x1_string_spec_internal_is_char_boundary"></a>
<b>fun</b> <a href="string.md#0x1_string_spec_internal_is_char_boundary">spec_internal_is_char_boundary</a>(v: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, i: u64): bool;
<a id="0x1_string_spec_internal_sub_string"></a>
<b>fun</b> <a href="string.md#0x1_string_spec_internal_sub_string">spec_internal_sub_string</a>(v: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, i: u64, j: u64): <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;;
<a id="0x1_string_spec_internal_index_of"></a>
<b>fun</b> <a href="string.md#0x1_string_spec_internal_index_of">spec_internal_index_of</a>(v: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;, r: <a href="vector.md#0x1_vector">vector</a>&lt;u8&gt;): u64;
</code></pre>


[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/doc_template/overview.md
================================================
# Move Stdlib Modules

This is the reference documentation of the Move standard library.
For on overview of the Move language, see the [Move Book][move-book].

## Index

> {{move-index}}


================================================
File: aptos-move/framework/move-stdlib/doc_template/references.md
================================================
[move-book]: https://aptos.dev/move/book/SUMMARY


================================================
File: aptos-move/framework/move-stdlib/sources/acl.move
================================================
/// Access control list (acl) module. An acl is a list of account addresses who
/// have the access permission to a certain object.
/// This module uses a `vector` to represent the list, but can be refactored to
/// use a "set" instead when it's available in the language in the future.

module std::acl {
    use std::vector;
    use std::error;

    /// The ACL already contains the address.
    const ECONTAIN: u64 = 0;
    /// The ACL does not contain the address.
    const ENOT_CONTAIN: u64 = 1;

    struct ACL has store, drop, copy {
        list: vector<address>
    }

    /// Return an empty ACL.
    public fun empty(): ACL {
        ACL{ list: vector::empty<address>() }
    }

    /// Add the address to the ACL.
    public fun add(acl: &mut ACL, addr: address) {
        assert!(!vector::contains(&mut acl.list, &addr), error::invalid_argument(ECONTAIN));
        vector::push_back(&mut acl.list, addr);
    }

    /// Remove the address from the ACL.
    public fun remove(acl: &mut ACL, addr: address) {
        let (found, index) = vector::index_of(&mut acl.list, &addr);
        assert!(found, error::invalid_argument(ENOT_CONTAIN));
        vector::remove(&mut acl.list, index);
    }

    /// Return true iff the ACL contains the address.
    public fun contains(acl: &ACL, addr: address): bool {
        vector::contains(&acl.list, &addr)
    }

    /// assert! that the ACL has the address.
    public fun assert_contains(acl: &ACL, addr: address) {
        assert!(contains(acl, addr), error::invalid_argument(ENOT_CONTAIN));
    }
}


================================================
File: aptos-move/framework/move-stdlib/sources/acl.spec.move
================================================
spec std::acl {
    spec ACL {
        invariant forall i in 0..len(list), j in 0..len(list): list[i] == list[j] ==> i == j;
    }

    spec fun spec_contains(acl: ACL, addr: address): bool {
        exists a in acl.list: a == addr
    }

    spec contains(acl: &ACL, addr: address): bool {
        ensures result == spec_contains(acl, addr);
    }

    spec add(acl: &mut ACL, addr: address) {
        aborts_if spec_contains(acl, addr) with error::INVALID_ARGUMENT;
        ensures spec_contains(acl, addr);
    }

    spec remove(acl: &mut ACL, addr: address) {
        aborts_if !spec_contains(acl, addr) with error::INVALID_ARGUMENT;
        ensures !spec_contains(acl, addr);
    }

    spec assert_contains(acl: &ACL, addr: address) {
        aborts_if !spec_contains(acl, addr) with error::INVALID_ARGUMENT;
    }
}


================================================
File: aptos-move/framework/move-stdlib/sources/bcs.move
================================================
/// Utility for converting a Move value to its binary representation in BCS (Binary Canonical
/// Serialization). BCS is the binary encoding for Move resources and other non-module values
/// published on-chain. See https://github.com/aptos-labs/bcs#binary-canonical-serialization-bcs for more
/// details on BCS.
module std::bcs {
    /// Return the binary representation of `v` in BCS (Binary Canonical Serialization) format
    native public fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;

    // ==============================
    // Module Specification
    spec module {} // switch to module documentation context

    spec module {
        /// Native function which is defined in the prover's prelude.
        native fun serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }
}


================================================
File: aptos-move/framework/move-stdlib/sources/bit_vector.move
================================================
module std::bit_vector {
    use std::vector;

    /// The provided index is out of bounds
    const EINDEX: u64 = 0x20000;
    /// An invalid length of bitvector was given
    const ELENGTH: u64 = 0x20001;

    const WORD_SIZE: u64 = 1;
    /// The maximum allowed bitvector size
    const MAX_SIZE: u64 = 1024;

    spec BitVector {
        invariant length == len(bit_field);
    }

    struct BitVector has copy, drop, store {
        length: u64,
        bit_field: vector<bool>,
    }

    public fun new(length: u64): BitVector {
        assert!(length > 0, ELENGTH);
        assert!(length < MAX_SIZE, ELENGTH);
        let counter = 0;
        let bit_field = vector::empty();
        while ({spec {
            invariant counter <= length;
            invariant len(bit_field) == counter;
        };
            (counter < length)}) {
            vector::push_back(&mut bit_field, false);
            counter = counter + 1;
        };
        spec {
            assert counter == length;
            assert len(bit_field) == length;
        };

        BitVector {
            length,
            bit_field,
        }
    }
    spec new {
        include NewAbortsIf;
        ensures result.length == length;
        ensures len(result.bit_field) == length;
    }
    spec schema NewAbortsIf {
        length: u64;
        aborts_if length <= 0 with ELENGTH;
        aborts_if length >= MAX_SIZE with ELENGTH;
    }

    /// Set the bit at `bit_index` in the `bitvector` regardless of its previous state.
    public fun set(bitvector: &mut BitVector, bit_index: u64) {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
    }
    spec set {
        include SetAbortsIf;
        ensures bitvector.bit_field[bit_index];
    }
    spec schema SetAbortsIf {
        bitvector: BitVector;
        bit_index: u64;
        aborts_if bit_index >= length(bitvector) with EINDEX;
    }

    /// Unset the bit at `bit_index` in the `bitvector` regardless of its previous state.
    public fun unset(bitvector: &mut BitVector, bit_index: u64) {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
    }
    spec unset {
        include UnsetAbortsIf;
        ensures !bitvector.bit_field[bit_index];
    }
    spec schema UnsetAbortsIf {
        bitvector: BitVector;
        bit_index: u64;
        aborts_if bit_index >= length(bitvector) with EINDEX;
    }

    /// Shift the `bitvector` left by `amount`. If `amount` is greater than the
    /// bitvector's length the bitvector will be zeroed out.
    public fun shift_left(bitvector: &mut BitVector, amount: u64) {
        if (amount >= bitvector.length) {
            vector::for_each_mut(&mut bitvector.bit_field, |elem| {
                *elem = false;
            });
        } else {
            let i = amount;

            while (i < bitvector.length) {
                if (is_index_set(bitvector, i)) set(bitvector, i - amount)
                else unset(bitvector, i - amount);
                i = i + 1;
            };

            i = bitvector.length - amount;

            while (i < bitvector.length) {
                unset(bitvector, i);
                i = i + 1;
            };
        }
    }
    spec shift_left {
        // TODO: set to false because data invariant cannot be proved with inline function. Will remove it once inline is supported
        pragma verify = false;
    }

    /// Return the value of the bit at `bit_index` in the `bitvector`. `true`
    /// represents "1" and `false` represents a 0
    public fun is_index_set(bitvector: &BitVector, bit_index: u64): bool {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        *vector::borrow(&bitvector.bit_field, bit_index)
    }
    spec is_index_set {
        include IsIndexSetAbortsIf;
        ensures result == bitvector.bit_field[bit_index];
    }
    spec schema IsIndexSetAbortsIf {
        bitvector: BitVector;
        bit_index: u64;
        aborts_if bit_index >= length(bitvector) with EINDEX;
    }
    spec fun spec_is_index_set(bitvector: BitVector, bit_index: u64): bool {
        if (bit_index >= length(bitvector)) {
            false
        } else {
            bitvector.bit_field[bit_index]
        }
    }

    /// Return the length (number of usable bits) of this bitvector
    public fun length(bitvector: &BitVector): u64 {
        vector::length(&bitvector.bit_field)
    }

    /// Returns the length of the longest sequence of set bits starting at (and
    /// including) `start_index` in the `bitvector`. If there is no such
    /// sequence, then `0` is returned.
    public fun longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, EINDEX);
        let index = start_index;

        // Find the greatest index in the vector such that all indices less than it are set.
        while ({
            spec {
                invariant index >= start_index;
                invariant index == start_index || is_index_set(bitvector, index - 1);
                invariant index == start_index || index - 1 < vector::length(bitvector.bit_field);
                invariant forall j in start_index..index: is_index_set(bitvector, j);
                invariant forall j in start_index..index: j < vector::length(bitvector.bit_field);
            };
            index < bitvector.length
        }) {
            if (!is_index_set(bitvector, index)) break;
            index = index + 1;
        };

        index - start_index
    }

    spec longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {
        aborts_if start_index >= bitvector.length;
        ensures forall i in start_index..result: is_index_set(bitvector, i);
    }

    #[test_only]
    public fun word_size(): u64 {
        WORD_SIZE
    }

    #[verify_only]
    public fun shift_left_for_verification_only(bitvector: &mut BitVector, amount: u64) {
        if (amount >= bitvector.length) {
            let len = vector::length(&bitvector.bit_field);
            let i = 0;
            while ({
                spec {
                    invariant len == bitvector.length;
                    invariant forall k in 0..i: !bitvector.bit_field[k];
                    invariant forall k in i..bitvector.length: bitvector.bit_field[k] == old(bitvector).bit_field[k];
                };
                i < len
            }) {
                let elem = vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
            };
        } else {
            let i = amount;

            while ({
                spec {
                    invariant i >= amount;
                    invariant bitvector.length == old(bitvector).length;
                    invariant forall j in amount..i: old(bitvector).bit_field[j] == bitvector.bit_field[j - amount];
                    invariant forall j in (i-amount)..bitvector.length : old(bitvector).bit_field[j] == bitvector.bit_field[j];
                    invariant forall k in 0..i-amount: bitvector.bit_field[k] == old(bitvector).bit_field[k + amount];
                };
                i < bitvector.length
            }) {
                if (is_index_set(bitvector, i)) set(bitvector, i - amount)
                else unset(bitvector, i - amount);
                i = i + 1;
            };


            i = bitvector.length - amount;

            while ({
                spec {
                    invariant forall j in bitvector.length - amount..i: !bitvector.bit_field[j];
                    invariant forall k in 0..bitvector.length - amount: bitvector.bit_field[k] == old(bitvector).bit_field[k + amount];
                    invariant i >= bitvector.length - amount;
                };
                i < bitvector.length
            }) {
                unset(bitvector, i);
                i = i + 1;
            }
        }
    }
    spec shift_left_for_verification_only {
        aborts_if false;
        ensures amount >= bitvector.length ==> (forall k in 0..bitvector.length: !bitvector.bit_field[k]);
        ensures amount < bitvector.length ==>
            (forall i in bitvector.length - amount..bitvector.length: !bitvector.bit_field[i]);
        ensures amount < bitvector.length ==>
            (forall i in 0..bitvector.length - amount: bitvector.bit_field[i] == old(bitvector).bit_field[i + amount]);
    }
}


================================================
File: aptos-move/framework/move-stdlib/sources/error.move
================================================
/// This module defines a set of canonical error codes which are optional to use by applications for the
/// `abort` and `assert!` features.
///
/// Canonical error codes use the 3 lowest bytes of the u64 abort code range (the upper 5 bytes are free for other use).
/// Of those, the highest byte represents the *error category* and the lower two bytes the *error reason*.
/// Given an error category `0x1` and a reason `0x3`, a canonical abort code looks as `0x10003`.
///
/// A module can use a canonical code with a constant declaration of the following form:
///
/// ```
/// ///  An invalid ASCII character was encountered when creating a string.
/// const EINVALID_CHARACTER: u64 = 0x010003;
/// ```
///
/// This code is both valid in the worlds with and without canonical errors. It can be used as a plain module local
/// error reason understand by the existing error map tooling, or as a canonical code.
///
/// The actual canonical categories have been adopted from Google's canonical error codes, which in turn are derived
/// from Unix error codes [see here](https://cloud.google.com/apis/design/errors#handling_errors). Each code has an
/// associated HTTP error code which can be used in REST apis. The mapping from error code to http code is not 1:1;
/// error codes here are a bit richer than HTTP codes.
module std::error {

  /// Caller specified an invalid argument (http: 400)
  const INVALID_ARGUMENT: u64 = 0x1;

  /// An input or result of a computation is out of range (http: 400)
  const OUT_OF_RANGE: u64 = 0x2;

  /// The system is not in a state where the operation can be performed (http: 400)
  const INVALID_STATE: u64 = 0x3;

  /// Request not authenticated due to missing, invalid, or expired auth token (http: 401)
  const UNAUTHENTICATED: u64 = 0x4;

  /// client does not have sufficient permission (http: 403)
  const PERMISSION_DENIED: u64 = 0x5;

  /// A specified resource is not found (http: 404)
  const NOT_FOUND: u64 = 0x6;

  /// Concurrency conflict, such as read-modify-write conflict (http: 409)
  const ABORTED: u64 = 0x7;

  /// The resource that a client tried to create already exists (http: 409)
  const ALREADY_EXISTS: u64 = 0x8;

  /// Out of gas or other forms of quota (http: 429)
  const RESOURCE_EXHAUSTED: u64 = 0x9;

  /// Request cancelled by the client (http: 499)
  const CANCELLED: u64 = 0xA;

  /// Internal error (http: 500)
  const INTERNAL: u64 = 0xB;

  /// Feature not implemented (http: 501)
  const NOT_IMPLEMENTED: u64 = 0xC;

  /// The service is currently unavailable. Indicates that a retry could solve the issue (http: 503)
  const UNAVAILABLE: u64 = 0xD;

  /// Construct a canonical error code from a category and a reason.
  public fun canonical(category: u64, reason: u64): u64 {
    (category << 16) + reason
  }
  spec canonical {
    pragma opaque = true;
    let shl_res = category << 16;
    ensures [concrete] result == shl_res + reason;
    aborts_if [abstract] false;
    ensures [abstract] result == category;
  }

  /// Functions to construct a canonical error code of the given category.
  public fun invalid_argument(r: u64): u64 {  canonical(INVALID_ARGUMENT, r) }
  public fun out_of_range(r: u64): u64 {  canonical(OUT_OF_RANGE, r) }
  public fun invalid_state(r: u64): u64 {  canonical(INVALID_STATE, r) }
  public fun unauthenticated(r: u64): u64 { canonical(UNAUTHENTICATED, r) }
  public fun permission_denied(r: u64): u64 { canonical(PERMISSION_DENIED, r) }
  public fun not_found(r: u64): u64 { canonical(NOT_FOUND, r) }
  public fun aborted(r: u64): u64 { canonical(ABORTED, r) }
  public fun already_exists(r: u64): u64 { canonical(ALREADY_EXISTS, r) }
  public fun resource_exhausted(r: u64): u64 {  canonical(RESOURCE_EXHAUSTED, r) }
  public fun internal(r: u64): u64 {  canonical(INTERNAL, r) }
  public fun not_implemented(r: u64): u64 {  canonical(NOT_IMPLEMENTED, r) }
  public fun unavailable(r: u64): u64 { canonical(UNAVAILABLE, r) }
}


================================================
File: aptos-move/framework/move-stdlib/sources/fixed_point32.move
================================================
/// Defines a fixed-point numeric type with a 32-bit integer part and
/// a 32-bit fractional part.

module std::fixed_point32 {

    /// Define a fixed-point numeric type with 32 fractional bits.
    /// This is just a u64 integer but it is wrapped in a struct to
    /// make a unique type. This is a binary representation, so decimal
    /// values may not be exactly representable, but it provides more
    /// than 9 decimal digits of precision both before and after the
    /// decimal point (18 digits total). For comparison, double precision
    /// floating-point has less than 16 decimal digits of precision, so
    /// be careful about using floating-point to convert these values to
    /// decimal.
    struct FixedPoint32 has copy, drop, store { value: u64 }

    const MAX_U64: u128 = 18446744073709551615;

    /// The denominator provided was zero
    const EDENOMINATOR: u64 = 0x10001;
    /// The quotient value would be too large to be held in a `u64`
    const EDIVISION: u64 = 0x20002;
    /// The multiplied value would be too large to be held in a `u64`
    const EMULTIPLICATION: u64 = 0x20003;
    /// A division by zero was encountered
    const EDIVISION_BY_ZERO: u64 = 0x10004;
    /// The computed ratio when converting to a `FixedPoint32` would be unrepresentable
    const ERATIO_OUT_OF_RANGE: u64 = 0x20005;

    /// Multiply a u64 integer by a fixed-point number, truncating any
    /// fractional part of the product. This will abort if the product
    /// overflows.
    public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64 {
        // The product of two 64 bit values has 128 bits, so perform the
        // multiplication with u128 types and keep the full 128 bit product
        // to avoid losing accuracy.
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        // The unscaled product has 32 fractional bits (from the multiplier)
        // so rescale it by shifting away the low bits.
        let product = unscaled_product >> 32;
        // Check whether the value is too large.
        assert!(product <= MAX_U64, EMULTIPLICATION);
        (product as u64)
    }
    spec multiply_u64 {
        pragma opaque;
        include MultiplyAbortsIf;
        ensures result == spec_multiply_u64(val, multiplier);
    }
    spec schema MultiplyAbortsIf {
        val: num;
        multiplier: FixedPoint32;
        aborts_if spec_multiply_u64(val, multiplier) > MAX_U64 with EMULTIPLICATION;
    }
    spec fun spec_multiply_u64(val: num, multiplier: FixedPoint32): num {
        (val * multiplier.value) >> 32
    }

    public fun multiply_u64_return_fixpoint32(val: u64, multiplier: FixedPoint32): FixedPoint32 {
        // The product of two 64 bit values has 128 bits, so perform the
        // multiplication with u128 types and keep the full 128 bit product
        // to avoid losing accuracy.
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        // Check whether the value is too large.
        assert!(unscaled_product <= MAX_U64, EMULTIPLICATION);
        create_from_raw_value((unscaled_product as u64))
    }

    /// Divide a u64 integer by a fixed-point number, truncating any
    /// fractional part of the quotient. This will abort if the divisor
    /// is zero or if the quotient overflows.
    public fun divide_u64(val: u64, divisor: FixedPoint32): u64 {
        // Check for division by zero.
        assert!(divisor.value != 0, EDIVISION_BY_ZERO);
        // First convert to 128 bits and then shift left to
        // add 32 fractional zero bits to the dividend.
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        // Check whether the value is too large.
        assert!(quotient <= MAX_U64, EDIVISION);
        // the value may be too large, which will cause the cast to fail
        // with an arithmetic error.
        (quotient as u64)
    }
    spec divide_u64 {
        pragma opaque;
        include DivideAbortsIf;
        ensures result == spec_divide_u64(val, divisor);
    }
    spec schema DivideAbortsIf {
        val: num;
        divisor: FixedPoint32;
        aborts_if divisor.value == 0 with EDIVISION_BY_ZERO;
        aborts_if spec_divide_u64(val, divisor) > MAX_U64 with EDIVISION;
    }
    spec fun spec_divide_u64(val: num, divisor: FixedPoint32): num {
        (val << 32) / divisor.value
    }

    /// Create a fixed-point value from a rational number specified by its
    /// numerator and denominator. Calling this function should be preferred
    /// for using `Self::create_from_raw_value` which is also available.
    /// This will abort if the denominator is zero. It will also
    /// abort if the numerator is nonzero and the ratio is not in the range
    /// 2^-32 .. 2^32-1. When specifying decimal fractions, be careful about
    /// rounding errors: if you round to display N digits after the decimal
    /// point, you can use a denominator of 10^N to avoid numbers where the
    /// very small imprecision in the binary representation could change the
    /// rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.
    public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32 {
        // If the denominator is zero, this will abort.
        // Scale the numerator to have 64 fractional bits and the denominator
        // to have 32 fractional bits, so that the quotient will have 32
        // fractional bits.
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        // Return the quotient as a fixed-point number. We first need to check whether the cast
        // can succeed.
        assert!(quotient <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32 { value: (quotient as u64) }
    }
    spec create_from_rational {
        pragma opaque;
        include CreateFromRationalAbortsIf;
        ensures result == spec_create_from_rational(numerator, denominator);
    }
    spec schema CreateFromRationalAbortsIf {
        numerator: u64;
        denominator: u64;
        let scaled_numerator = (numerator as u128)<< 64;
        let scaled_denominator = (denominator as u128) << 32;
        let quotient = scaled_numerator / scaled_denominator;
        aborts_if scaled_denominator == 0 with EDENOMINATOR;
        aborts_if quotient == 0 && scaled_numerator != 0 with ERATIO_OUT_OF_RANGE;
        aborts_if quotient > MAX_U64 with ERATIO_OUT_OF_RANGE;
    }
    spec fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint32 {
        FixedPoint32{value: (numerator << 64) / (denominator << 32)}
    }

    /// Create a fixedpoint value from a raw value.
    public fun create_from_raw_value(value: u64): FixedPoint32 {
        FixedPoint32 { value }
    }
    spec create_from_raw_value {
        pragma opaque;
        aborts_if false;
        ensures result.value == value;
    }

    /// Accessor for the raw u64 value. Other less common operations, such as
    /// adding or subtracting FixedPoint32 values, can be done using the raw
    /// values directly.
    public fun get_raw_value(num: FixedPoint32): u64 {
        num.value
    }

    /// Returns true if the ratio is zero.
    public fun is_zero(num: FixedPoint32): bool {
        num.value == 0
    }

    /// Returns the smaller of the two FixedPoint32 numbers.
    public fun min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value) {
            num1
        } else {
            num2
        }
    }
    spec min {
        pragma opaque;
        aborts_if false;
        ensures result == spec_min(num1, num2);
    }
    spec fun spec_min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value) {
            num1
        } else {
            num2
        }
    }

    /// Returns the larger of the two FixedPoint32 numbers.
    public fun max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value) {
            num1
        } else {
            num2
        }
    }
    spec max {
        pragma opaque;
        aborts_if false;
        ensures result == spec_max(num1, num2);
    }
    spec fun spec_max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value) {
            num1
        } else {
            num2
        }
    }

    /// Create a fixedpoint value from a u64 value.
    public fun create_from_u64(val: u64): FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32 {value: (value as u64)}
    }
    spec create_from_u64 {
        pragma opaque;
        include CreateFromU64AbortsIf;
        ensures result == spec_create_from_u64(val);
    }
    spec schema CreateFromU64AbortsIf {
        val: num;
        let scaled_value = (val as u128) << 32;
        aborts_if scaled_value > MAX_U64;
    }
    spec fun spec_create_from_u64(val: num): FixedPoint32 {
        FixedPoint32 {value: val << 32}
    }

    /// Returns the largest integer less than or equal to a given number.
    public fun floor(num: FixedPoint32): u64 {
        num.value >> 32
    }
    spec floor {
        pragma opaque;
        aborts_if false;
        ensures result == spec_floor(num);
    }
    spec fun spec_floor(val: FixedPoint32): u64 {
        let fractional = val.value % (1 << 32);
        if (fractional == 0) {
            val.value >> 32
        } else {
            (val.value - fractional) >> 32
        }
    }

    /// Rounds up the given FixedPoint32 to the next largest integer.
    public fun ceil(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        if (num.value == floored_num) {
            return floored_num >> 32
        };
        let val = ((floored_num as u128) + (1 << 32));
        (val >> 32 as u64)
    }
    spec ceil {
        pragma verify_duration_estimate = 120;
        pragma opaque;
        aborts_if false;
        ensures result == spec_ceil(num);
    }
    spec fun spec_ceil(val: FixedPoint32): u64 {
        let fractional = val.value % (1 << 32);
        let one = 1 << 32;
        if (fractional == 0) {
            val.value >> 32
        } else {
            (val.value - fractional + one) >> 32
        }
    }

    /// Returns the value of a FixedPoint32 to the nearest integer.
    public fun round(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        let boundary = floored_num + ((1 << 32) / 2);
        if (num.value < boundary) {
            floored_num >> 32
        } else {
            ceil(num)
        }
    }
    spec round {
        pragma verify_duration_estimate = 120;
        pragma opaque;
        aborts_if false;
        ensures result == spec_round(num);
    }
    spec fun spec_round(val: FixedPoint32): u64 {
        let fractional = val.value % (1 << 32);
        let boundary = (1 << 32) / 2;
        let one = 1 << 32;
        if (fractional < boundary) {
            (val.value - fractional) >> 32
        } else {
            (val.value - fractional + one) >> 32
        }
    }

    // **************** SPECIFICATIONS ****************

    spec module {} // switch documentation context to module level

    spec module {
        pragma aborts_if_is_strict;
    }
}


================================================
File: aptos-move/framework/move-stdlib/sources/hash.move
================================================
/// Module which defines SHA hashes for byte vectors.
///
/// The functions in this module are natively declared both in the Move runtime
/// as in the Move prover's prelude.
module std::hash {
    native public fun sha2_256(data: vector<u8>): vector<u8>;
    native public fun sha3_256(data: vector<u8>): vector<u8>;
}


================================================
File: aptos-move/framework/move-stdlib/sources/option.move
================================================
/// This module defines the Option type and its methods to represent and handle an optional value.
module std::option {
    use std::vector;

    /// Abstraction of a value that may or may not be present. Implemented with a vector of size
    /// zero or one because Move bytecode does not have ADTs.
    struct Option<Element> has copy, drop, store {
        vec: vector<Element>
    }
    spec Option {
        /// The size of vector is always less than equal to 1
        /// because it's 0 for "none" or 1 for "some".
        invariant len(vec) <= 1;
    }

    /// The `Option` is in an invalid state for the operation attempted.
    /// The `Option` is `Some` while it should be `None`.
    const EOPTION_IS_SET: u64 = 0x40000;
    /// The `Option` is in an invalid state for the operation attempted.
    /// The `Option` is `None` while it should be `Some`.
    const EOPTION_NOT_SET: u64 = 0x40001;
    /// Cannot construct an option from a vector with 2 or more elements.
    const EOPTION_VEC_TOO_LONG: u64 = 0x40002;

    /// Return an empty `Option`
    public fun none<Element>(): Option<Element> {
        Option { vec: vector::empty() }
    }
    spec none {
        pragma opaque;
        aborts_if false;
        ensures result == spec_none<Element>();
    }
    spec fun spec_none<Element>(): Option<Element> {
        Option{ vec: vec() }
    }

    /// Return an `Option` containing `e`
    public fun some<Element>(e: Element): Option<Element> {
        Option { vec: vector::singleton(e) }
    }
    spec some {
        pragma opaque;
        aborts_if false;
        ensures result == spec_some(e);
    }
    spec fun spec_some<Element>(e: Element): Option<Element> {
        Option{ vec: vec(e) }
    }

    public fun from_vec<Element>(vec: vector<Element>): Option<Element> {
        assert!(vector::length(&vec) <= 1, EOPTION_VEC_TOO_LONG);
        Option { vec }
    }

    spec from_vec {
        aborts_if vector::length(vec) > 1;
    }

    /// Return true if `t` does not hold a value
    public fun is_none<Element>(t: &Option<Element>): bool {
        vector::is_empty(&t.vec)
    }
    spec is_none {
        pragma opaque;
        aborts_if false;
        ensures result == spec_is_none(t);
    }
    spec fun spec_is_none<Element>(t: Option<Element>): bool {
        vector::is_empty(t.vec)
    }

    /// Return true if `t` holds a value
    public fun is_some<Element>(t: &Option<Element>): bool {
        !vector::is_empty(&t.vec)
    }
    spec is_some {
        pragma opaque;
        aborts_if false;
        ensures result == spec_is_some(t);
    }
    spec fun spec_is_some<Element>(t: Option<Element>): bool {
        !vector::is_empty(t.vec)
    }

    /// Return true if the value in `t` is equal to `e_ref`
    /// Always returns `false` if `t` does not hold a value
    public fun contains<Element>(t: &Option<Element>, e_ref: &Element): bool {
        vector::contains(&t.vec, e_ref)
    }
    spec contains {
        pragma opaque;
        aborts_if false;
        ensures result == spec_contains(t, e_ref);
    }
    spec fun spec_contains<Element>(t: Option<Element>, e: Element): bool {
        is_some(t) && borrow(t) == e
    }

    /// Return an immutable reference to the value inside `t`
    /// Aborts if `t` does not hold a value
    public fun borrow<Element>(t: &Option<Element>): &Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow(&t.vec, 0)
    }
    spec borrow {
        pragma opaque;
        include AbortsIfNone<Element>;
        ensures result == spec_borrow(t);
    }
    spec fun spec_borrow<Element>(t: Option<Element>): Element {
        t.vec[0]
    }

    /// Return a reference to the value inside `t` if it holds one
    /// Return `default_ref` if `t` does not hold a value
    public fun borrow_with_default<Element>(t: &Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default_ref
        else vector::borrow(vec_ref, 0)
    }
    spec borrow_with_default {
        pragma opaque;
        aborts_if false;
        ensures result == (if (spec_is_some(t)) spec_borrow(t) else default_ref);
    }

    /// Return the value inside `t` if it holds one
    /// Return `default` if `t` does not hold a value
    public fun get_with_default<Element: copy + drop>(
        t: &Option<Element>,
        default: Element,
    ): Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default
        else *vector::borrow(vec_ref, 0)
    }
    spec get_with_default {
        pragma opaque;
        aborts_if false;
        ensures result == (if (spec_is_some(t)) spec_borrow(t) else default);
    }

    /// Convert the none option `t` to a some option by adding `e`.
    /// Aborts if `t` already holds a value
    public fun fill<Element>(t: &mut Option<Element>, e: Element) {
        let vec_ref = &mut t.vec;
        if (vector::is_empty(vec_ref)) vector::push_back(vec_ref, e)
        else abort EOPTION_IS_SET
    }
    spec fill {
        pragma opaque;
        aborts_if spec_is_some(t) with EOPTION_IS_SET;
        ensures spec_is_some(t);
        ensures spec_borrow(t) == e;
    }

    /// Convert a `some` option to a `none` by removing and returning the value stored inside `t`
    /// Aborts if `t` does not hold a value
    public fun extract<Element>(t: &mut Option<Element>): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::pop_back(&mut t.vec)
    }
    spec extract {
        pragma opaque;
        include AbortsIfNone<Element>;
        ensures result == spec_borrow(old(t));
        ensures spec_is_none(t);
    }

    /// Return a mutable reference to the value inside `t`
    /// Aborts if `t` does not hold a value
    public fun borrow_mut<Element>(t: &mut Option<Element>): &mut Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow_mut(&mut t.vec, 0)
    }
    spec borrow_mut {
        include AbortsIfNone<Element>;
        ensures result == spec_borrow(t);
        ensures t == old(t);
    }

    /// Swap the old value inside `t` with `e` and return the old value
    /// Aborts if `t` does not hold a value
    public fun swap<Element>(t: &mut Option<Element>, e: Element): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = vector::pop_back(vec_ref);
        vector::push_back(vec_ref, e);
        old_value
    }
    spec swap {
        pragma opaque;
        include AbortsIfNone<Element>;
        ensures result == spec_borrow(old(t));
        ensures spec_is_some(t);
        ensures spec_borrow(t) == e;
    }

    /// Swap the old value inside `t` with `e` and return the old value;
    /// or if there is no old value, fill it with `e`.
    /// Different from swap(), swap_or_fill() allows for `t` not holding a value.
    public fun swap_or_fill<Element>(t: &mut Option<Element>, e: Element): Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if (vector::is_empty(vec_ref)) none()
            else some(vector::pop_back(vec_ref));
        vector::push_back(vec_ref, e);
        old_value
    }
    spec swap_or_fill {
        pragma opaque;
        aborts_if false;
        ensures result == old(t);
        ensures spec_borrow(t) == e;
    }

    /// Destroys `t.` If `t` holds a value, return it. Returns `default` otherwise
    public fun destroy_with_default<Element: drop>(t: Option<Element>, default: Element): Element {
        let Option { vec } = t;
        if (vector::is_empty(&mut vec)) default
        else vector::pop_back(&mut vec)
    }
    spec destroy_with_default {
        pragma opaque;
        aborts_if false;
        ensures result == (if (spec_is_some(t)) spec_borrow(t) else default);
    }

    /// Unpack `t` and return its contents
    /// Aborts if `t` does not hold a value
    public fun destroy_some<Element>(t: Option<Element>): Element {
        assert!(is_some(&t), EOPTION_NOT_SET);
        let Option { vec } = t;
        let elem = vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
        elem
    }
    spec destroy_some {
        pragma opaque;
        include AbortsIfNone<Element>;
        ensures result == spec_borrow(t);
    }

    /// Unpack `t`
    /// Aborts if `t` holds a value
    public fun destroy_none<Element>(t: Option<Element>) {
        assert!(is_none(&t), EOPTION_IS_SET);
        let Option { vec } = t;
        vector::destroy_empty(vec)
    }
    spec destroy_none {
        pragma opaque;
        aborts_if spec_is_some(t) with EOPTION_IS_SET;
    }

    /// Convert `t` into a vector of length 1 if it is `Some`,
    /// and an empty vector otherwise
    public fun to_vec<Element>(t: Option<Element>): vector<Element> {
        let Option { vec } = t;
        vec
    }
    spec to_vec {
        pragma opaque;
        aborts_if false;
        ensures result == t.vec;
    }
    /// Apply the function to the optional element, consuming it. Does nothing if no value present.
    public inline fun for_each<Element>(o: Option<Element>, f: |Element|) {
        if (is_some(&o)) {
            f(destroy_some(o))
        } else {
            destroy_none(o)
        }
    }

    /// Apply the function to the optional element reference. Does nothing if no value present.
    public inline fun for_each_ref<Element>(o: &Option<Element>, f: |&Element|) {
        if (is_some(o)) {
            f(borrow(o))
        }
    }

    /// Apply the function to the optional element reference. Does nothing if no value present.
    public inline fun for_each_mut<Element>(o: &mut Option<Element>, f: |&mut Element|) {
        if (is_some(o)) {
            f(borrow_mut(o))
        }
    }

    /// Folds the function over the optional element.
    public inline fun fold<Accumulator, Element>(
        o: Option<Element>,
        init: Accumulator,
        f: |Accumulator,Element|Accumulator
    ): Accumulator {
        if (is_some(&o)) {
            f(init, destroy_some(o))
        } else {
            destroy_none(o);
            init
        }
    }

    /// Maps the content of an option.
    public inline fun map<Element, OtherElement>(o: Option<Element>, f: |Element|OtherElement): Option<OtherElement> {
        if (is_some(&o)) {
            some(f(destroy_some(o)))
        } else {
            destroy_none(o);
            none()
        }
    }

    /// Maps the content of an option without destroying the original option.
    public inline fun map_ref<Element, OtherElement>(
        o: &Option<Element>, f: |&Element|OtherElement): Option<OtherElement> {
        if (is_some(o)) {
            some(f(borrow(o)))
        } else {
            none()
        }
    }

    /// Filters the content of an option
    public inline fun filter<Element:drop>(o: Option<Element>, f: |&Element|bool): Option<Element> {
        if (is_some(&o) && f(borrow(&o))) {
            o
        } else {
            none()
        }
    }

    /// Returns true if the option contains an element which satisfies predicate.
    public inline fun any<Element>(o: &Option<Element>, p: |&Element|bool): bool {
        is_some(o) && p(borrow(o))
    }

    /// Utility function to destroy an option that is not droppable.
    public inline fun destroy<Element>(o: Option<Element>, d: |Element|) {
        let vec = to_vec(o);
        vector::destroy(vec, |e| d(e));
    }

    spec module {} // switch documentation context back to module level

    spec module {
        pragma aborts_if_is_strict;
    }

    /// # Helper Schema

    spec schema AbortsIfNone<Element> {
        t: Option<Element>;
        aborts_if spec_is_none(t) with EOPTION_NOT_SET;
    }
}


================================================
File: aptos-move/framework/move-stdlib/sources/signer.move
================================================
module std::signer {
    /// Borrows the address of the signer
    /// Conceptually, you can think of the `signer` as being a struct wrapper around an
    /// address
    /// ```
    /// struct signer has drop { addr: address }
    /// ```
    /// `borrow_address` borrows this inner field
    native public fun borrow_address(s: &signer): &address;

    // Copies the address of the signer
    public fun address_of(s: &signer): address {
        *borrow_address(s)
    }

    /// Return true only if `s` is a transaction signer. This is a spec function only available in spec.
    spec native fun is_txn_signer(s: signer): bool;

    /// Return true only if `a` is a transaction signer address. This is a spec function only available in spec.
    spec native fun is_txn_signer_addr(a: address): bool;
}


================================================
File: aptos-move/framework/move-stdlib/sources/string.move
================================================
/// The `string` module defines the `String` type which represents UTF8 encoded strings.
module std::string {
    use std::vector;
    use std::option::{Self, Option};

    /// An invalid UTF8 encoding.
    const EINVALID_UTF8: u64 = 1;

    /// Index out of range.
    const EINVALID_INDEX: u64 = 2;

    /// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.
    struct String has copy, drop, store {
        bytes: vector<u8>,
    }

    /// Creates a new string from a sequence of bytes. Aborts if the bytes do not represent valid utf8.
    public fun utf8(bytes: vector<u8>): String {
        assert!(internal_check_utf8(&bytes), EINVALID_UTF8);
        String{bytes}
    }

    /// Tries to create a new string from a sequence of bytes.
    public fun try_utf8(bytes: vector<u8>): Option<String> {
        if (internal_check_utf8(&bytes)) {
            option::some(String{bytes})
        } else {
            option::none()
        }
    }

    /// Returns a reference to the underlying byte vector.
    public fun bytes(s: &String): &vector<u8> {
        &s.bytes
    }

    /// Checks whether this string is empty.
    public fun is_empty(s: &String): bool {
        vector::is_empty(&s.bytes)
    }

    /// Returns the length of this string, in bytes.
    public fun length(s: &String): u64 {
        vector::length(&s.bytes)
    }

    /// Appends a string.
    public fun append(s: &mut String, r: String) {
        vector::append(&mut s.bytes, r.bytes)
    }

    /// Appends bytes which must be in valid utf8 format.
    public fun append_utf8(s: &mut String, bytes: vector<u8>) {
        append(s, utf8(bytes))
    }

    /// Insert the other string at the byte index in given string. The index must be at a valid utf8 char
    /// boundary.
    public fun insert(s: &mut String, at: u64, o: String) {
        let bytes = &s.bytes;
        assert!(at <= vector::length(bytes) && internal_is_char_boundary(bytes, at), EINVALID_INDEX);
        let l = length(s);
        let front = sub_string(s, 0, at);
        let end = sub_string(s, at, l);
        append(&mut front, o);
        append(&mut front, end);
        *s = front;
    }

    /// Returns a sub-string using the given byte indices, where `i` is the first byte position and `j` is the start
    /// of the first byte not included (or the length of the string). The indices must be at valid utf8 char boundaries,
    /// guaranteeing that the result is valid utf8.
    public fun sub_string(s: &String, i: u64, j: u64): String {
        let bytes = &s.bytes;
        let l = vector::length(bytes);
        assert!(
            j <= l && i <= j && internal_is_char_boundary(bytes, i) && internal_is_char_boundary(bytes, j),
            EINVALID_INDEX
        );
        String { bytes: internal_sub_string(bytes, i, j) }
    }

    /// Computes the index of the first occurrence of a string. Returns `length(s)` if no occurrence found.
    public fun index_of(s: &String, r: &String): u64 {
        internal_index_of(&s.bytes, &r.bytes)
    }

    // Native API
    public native fun internal_check_utf8(v: &vector<u8>): bool;
    native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;
    native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;
    native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;
}


================================================
File: aptos-move/framework/move-stdlib/sources/string.spec.move
================================================
spec std::string {
    spec internal_check_utf8(v: &vector<u8>): bool {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_internal_check_utf8(v);
    }

    spec internal_is_char_boundary(v: &vector<u8>, i: u64): bool {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_internal_is_char_boundary(v, i);
    }
    spec internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8> {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_internal_sub_string(v, i, j);
    }
    spec internal_index_of(v: &vector<u8>, r: &vector<u8>): u64 {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_internal_index_of(v, r);
    }
    spec fun spec_utf8(bytes: vector<u8>): String {
        String{bytes}
    }

    spec module {
        fun spec_internal_check_utf8(v: vector<u8>): bool;
        fun spec_internal_is_char_boundary(v: vector<u8>, i: u64): bool;
        fun spec_internal_sub_string(v: vector<u8>, i: u64, j: u64): vector<u8>;
        fun spec_internal_index_of(v: vector<u8>, r: vector<u8>): u64;
    }
}


================================================
File: aptos-move/framework/move-stdlib/sources/unit_test.move
================================================
#[test_only]
/// Module providing testing functionality. Only included for tests.
module std::unit_test {
    /// Return a `num_signers` number of unique signer values. No ordering or
    /// starting value guarantees are made, only that the order and values of
    /// the signers in the returned vector is deterministic.
    ///
    /// This function is also used to poison modules compiled in `test` mode.
    /// This will cause a linking failure if an attempt is made to publish a
    /// test module in a VM that isn't in unit test mode.
    native public fun create_signers_for_testing(num_signers: u64): vector<signer>;
}


================================================
File: aptos-move/framework/move-stdlib/sources/vector.move
================================================
/// A variable-sized container that can hold any type. Indexing is 0-based, and
/// vectors are growable. This module has many native functions.
/// Verification of modules that use this one uses model functions that are implemented
/// directly in Boogie. The specification language has built-in functions operations such
/// as `singleton_vector`. There are some helper functions defined here for specifications in other
/// modules as well.
///
/// >Note: We did not verify most of the
/// Move functions here because many have loops, requiring loop invariants to prove, and
/// the return on investment didn't seem worth it for these simple functions.
module std::vector {
    /// The index into the vector is out of bounds
    const EINDEX_OUT_OF_BOUNDS: u64 = 0x20000;

    /// The index into the vector is out of bounds
    const EINVALID_RANGE: u64 = 0x20001;

    /// The length of the vectors are not equal.
    const EVECTORS_LENGTH_MISMATCH: u64 = 0x20002;

    /// The step provided in `range` is invalid, must be greater than zero.
    const EINVALID_STEP: u64 = 0x20003;

    /// The range in `slice` is invalid.
    const EINVALID_SLICE_RANGE: u64 = 0x20004;

    #[bytecode_instruction]
    /// Create an empty vector.
    native public fun empty<Element>(): vector<Element>;

    #[bytecode_instruction]
    /// Return the length of the vector.
    native public fun length<Element>(v: &vector<Element>): u64;

    #[bytecode_instruction]
    /// Acquire an immutable reference to the `i`th element of the vector `v`.
    /// Aborts if `i` is out of bounds.
    native public fun borrow<Element>(v: &vector<Element>, i: u64): &Element;

    #[bytecode_instruction]
    /// Add element `e` to the end of the vector `v`.
    native public fun push_back<Element>(v: &mut vector<Element>, e: Element);

    #[bytecode_instruction]
    /// Return a mutable reference to the `i`th element in the vector `v`.
    /// Aborts if `i` is out of bounds.
    native public fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;

    #[bytecode_instruction]
    /// Pop an element from the end of vector `v`.
    /// Aborts if `v` is empty.
    native public fun pop_back<Element>(v: &mut vector<Element>): Element;

    #[bytecode_instruction]
    /// Destroy the vector `v`.
    /// Aborts if `v` is not empty.
    native public fun destroy_empty<Element>(v: vector<Element>);

    #[bytecode_instruction]
    /// Swaps the elements at the `i`th and `j`th indices in the vector `v`.
    /// Aborts if `i` or `j` is out of bounds.
    native public fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64);

    /// Return an vector of size one containing element `e`.
    public fun singleton<Element>(e: Element): vector<Element> {
        let v = empty();
        push_back(&mut v, e);
        v
    }
    spec singleton {
        aborts_if false;
        ensures result == vec(e);
    }

    /// Reverses the order of the elements in the vector `v` in place.
    public fun reverse<Element>(v: &mut vector<Element>) {
        let len = length(v);
        reverse_slice(v, 0, len);
    }

    spec reverse {
        pragma intrinsic = true;
    }

    /// Reverses the order of the elements [left, right) in the vector `v` in place.
    public fun reverse_slice<Element>(v: &mut vector<Element>, left: u64, right: u64) {
        assert!(left <= right, EINVALID_RANGE);
        if (left == right) return;
        right = right - 1;
        while (left < right) {
            swap(v, left, right);
            left = left + 1;
            right = right - 1;
        }
    }
    spec reverse_slice {
        pragma intrinsic = true;
    }

    /// Pushes all of the elements of the `other` vector into the `lhs` vector.
    public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>) {
        reverse(&mut other);
        reverse_append(lhs, other);
    }
    spec append {
        pragma intrinsic = true;
    }
    spec is_empty {
        pragma intrinsic = true;
    }

    /// Pushes all of the elements of the `other` vector into the `lhs` vector.
    public fun reverse_append<Element>(lhs: &mut vector<Element>, other: vector<Element>) {
        let len = length(&other);
        while (len > 0) {
            push_back(lhs, pop_back(&mut other));
            len = len - 1;
        };
        destroy_empty(other);
    }
    spec reverse_append {
        pragma intrinsic = true;
    }

    /// Trim a vector to a smaller size, returning the evicted elements in order
    public fun trim<Element>(v: &mut vector<Element>, new_len: u64): vector<Element> {
        let res = trim_reverse(v, new_len);
        reverse(&mut res);
        res
    }
    spec trim {
        pragma intrinsic = true;
    }

    /// Trim a vector to a smaller size, returning the evicted elements in reverse order
    public fun trim_reverse<Element>(v: &mut vector<Element>, new_len: u64): vector<Element> {
        let len = length(v);
        assert!(new_len <= len, EINDEX_OUT_OF_BOUNDS);
        let result = empty();
        while (new_len < len) {
            push_back(&mut result, pop_back(v));
            len = len - 1;
        };
        result
    }
    spec trim_reverse {
        pragma intrinsic = true;
    }


    /// Return `true` if the vector `v` has no elements and `false` otherwise.
    public fun is_empty<Element>(v: &vector<Element>): bool {
        length(v) == 0
    }

    /// Return true if `e` is in the vector `v`.
    public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return true;
            i = i + 1;
        };
        false
    }
    spec contains {
        pragma intrinsic = true;
    }

    /// Return `(true, i)` if `e` is in the vector `v` at index `i`.
    /// Otherwise, returns `(false, 0)`.
    public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return (true, i);
            i = i + 1;
        };
        (false, 0)
    }
    spec index_of {
        pragma intrinsic = true;
    }

    /// Return `(true, i)` if there's an element that matches the predicate. If there are multiple elements that match
    /// the predicate, only the index of the first one is returned.
    /// Otherwise, returns `(false, 0)`.
    public inline fun find<Element>(v: &vector<Element>, f: |&Element|bool): (bool, u64) {
        let find = false;
        let found_index = 0;
        let i = 0;
        let len = length(v);
        while (i < len) {
            // Cannot call return in an inline function so we need to resort to break here.
            if (f(borrow(v, i))) {
                find = true;
                found_index = i;
                break
            };
            i = i + 1;
        };
        (find, found_index)
    }

    /// Insert a new element at position 0 <= i <= length, using O(length - i) time.
    /// Aborts if out of bounds.
    public fun insert<Element>(v: &mut vector<Element>, i: u64, e: Element) {
        let len = length(v);
        assert!(i <= len, EINDEX_OUT_OF_BOUNDS);
        push_back(v, e);
        while (i < len) {
            swap(v, i, len);
            i = i + 1;
        };
    }
    spec insert {
        pragma intrinsic = true;
    }

    /// Remove the `i`th element of the vector `v`, shifting all subsequent elements.
    /// This is O(n) and preserves ordering of elements in the vector.
    /// Aborts if `i` is out of bounds.
    public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = length(v);
        // i out of bounds; abort
        if (i >= len) abort EINDEX_OUT_OF_BOUNDS;

        len = len - 1;
        while (i < len) swap(v, i, { i = i + 1; i });
        pop_back(v)
    }
    spec remove {
        pragma intrinsic = true;
    }

    /// Remove the first occurrence of a given value in the vector `v` and return it in a vector, shifting all
    /// subsequent elements.
    /// This is O(n) and preserves ordering of elements in the vector.
    /// This returns an empty vector if the value isn't present in the vector.
    /// Note that this cannot return an option as option uses vector and there'd be a circular dependency between option
    /// and vector.
    public fun remove_value<Element>(v: &mut vector<Element>, val: &Element): vector<Element> {
        // This doesn't cost a O(2N) run time as index_of scans from left to right and stops when the element is found,
        // while remove would continue from the identified index to the end of the vector.
        let (found, index) = index_of(v, val);
        if (found) {
            vector[remove(v, index)]
        } else {
           vector[]
        }
    }
    spec remove_value {
        pragma intrinsic = true;
    }

    /// Swap the `i`th element of the vector `v` with the last element and then pop the vector.
    /// This is O(1), but does not preserve ordering of elements in the vector.
    /// Aborts if `i` is out of bounds.
    public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(!is_empty(v), EINDEX_OUT_OF_BOUNDS);
        let last_idx = length(v) - 1;
        swap(v, i, last_idx);
        pop_back(v)
    }
    spec swap_remove {
        pragma intrinsic = true;
    }

    /// Apply the function to each element in the vector, consuming it.
    public inline fun for_each<Element>(v: vector<Element>, f: |Element|) {
        reverse(&mut v); // We need to reverse the vector to consume it efficiently
        for_each_reverse(v, |e| f(e));
    }

    /// Apply the function to each element in the vector, consuming it.
    public inline fun for_each_reverse<Element>(v: vector<Element>, f: |Element|) {
        let len = length(&v);
        while (len > 0) {
            f(pop_back(&mut v));
            len = len - 1;
        };
        destroy_empty(v)
    }

    /// Apply the function to a reference of each element in the vector.
    public inline fun for_each_ref<Element>(v: &vector<Element>, f: |&Element|) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            f(borrow(v, i));
            i = i + 1
        }
    }

    /// Apply the function to each pair of elements in the two given vectors, consuming them.
    public inline fun zip<Element1, Element2>(v1: vector<Element1>, v2: vector<Element2>, f: |Element1, Element2|) {
        // We need to reverse the vectors to consume it efficiently
        reverse(&mut v1);
        reverse(&mut v2);
        zip_reverse(v1, v2, |e1, e2| f(e1, e2));
    }

    /// Apply the function to each pair of elements in the two given vectors in the reverse order, consuming them.
    /// This errors out if the vectors are not of the same length.
    public inline fun zip_reverse<Element1, Element2>(
        v1: vector<Element1>,
        v2: vector<Element2>,
        f: |Element1, Element2|,
    ) {
        let len = length(&v1);
        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(len == length(&v2), 0x20002);
        while (len > 0) {
            f(pop_back(&mut v1), pop_back(&mut v2));
            len = len - 1;
        };
        destroy_empty(v1);
        destroy_empty(v2);
    }

    /// Apply the function to the references of each pair of elements in the two given vectors.
    /// This errors out if the vectors are not of the same length.
    public inline fun zip_ref<Element1, Element2>(
        v1: &vector<Element1>,
        v2: &vector<Element2>,
        f: |&Element1, &Element2|,
    ) {
        let len = length(v1);
        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(len == length(v2), 0x20002);
        let i = 0;
        while (i < len) {
            f(borrow(v1, i), borrow(v2, i));
            i = i + 1
        }
    }

    /// Apply the function to a reference of each element in the vector with its index.
    public inline fun enumerate_ref<Element>(v: &vector<Element>, f: |u64, &Element|) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            f(i, borrow(v, i));
            i = i + 1;
        };
    }

    /// Apply the function to a mutable reference to each element in the vector.
    public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: |&mut Element|) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            f(borrow_mut(v, i));
            i = i + 1
        }
    }

    /// Apply the function to mutable references to each pair of elements in the two given vectors.
    /// This errors out if the vectors are not of the same length.
    public inline fun zip_mut<Element1, Element2>(
        v1: &mut vector<Element1>,
        v2: &mut vector<Element2>,
        f: |&mut Element1, &mut Element2|,
    ) {
        let i = 0;
        let len = length(v1);
        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(len == length(v2), 0x20002);
        while (i < len) {
            f(borrow_mut(v1, i), borrow_mut(v2, i));
            i = i + 1
        }
    }

    /// Apply the function to a mutable reference of each element in the vector with its index.
    public inline fun enumerate_mut<Element>(v: &mut vector<Element>, f: |u64, &mut Element|) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            f(i, borrow_mut(v, i));
            i = i + 1;
        };
    }

    /// Fold the function over the elements. For example, `fold(vector[1,2,3], 0, f)` will execute
    /// `f(f(f(0, 1), 2), 3)`
    public inline fun fold<Accumulator, Element>(
        v: vector<Element>,
        init: Accumulator,
        f: |Accumulator,Element|Accumulator
    ): Accumulator {
        let accu = init;
        for_each(v, |elem| accu = f(accu, elem));
        accu
    }

    /// Fold right like fold above but working right to left. For example, `fold(vector[1,2,3], 0, f)` will execute
    /// `f(1, f(2, f(3, 0)))`
    public inline fun foldr<Accumulator, Element>(
        v: vector<Element>,
        init: Accumulator,
        f: |Element, Accumulator|Accumulator
    ): Accumulator {
        let accu = init;
        for_each_reverse(v, |elem| accu = f(elem, accu));
        accu
    }

    /// Map the function over the references of the elements of the vector, producing a new vector without modifying the
    /// original vector.
    public inline fun map_ref<Element, NewElement>(
        v: &vector<Element>,
        f: |&Element|NewElement
    ): vector<NewElement> {
        let result = vector<NewElement>[];
        for_each_ref(v, |elem| push_back(&mut result, f(elem)));
        result
    }

    /// Map the function over the references of the element pairs of two vectors, producing a new vector from the return
    /// values without modifying the original vectors.
    public inline fun zip_map_ref<Element1, Element2, NewElement>(
        v1: &vector<Element1>,
        v2: &vector<Element2>,
        f: |&Element1, &Element2|NewElement
    ): vector<NewElement> {
        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(length(v1) == length(v2), 0x20002);

        let result = vector<NewElement>[];
        zip_ref(v1, v2, |e1, e2| push_back(&mut result, f(e1, e2)));
        result
    }

    /// Map the function over the elements of the vector, producing a new vector.
    public inline fun map<Element, NewElement>(
        v: vector<Element>,
        f: |Element|NewElement
    ): vector<NewElement> {
        let result = vector<NewElement>[];
        for_each(v, |elem| push_back(&mut result, f(elem)));
        result
    }

    /// Map the function over the element pairs of the two vectors, producing a new vector.
    public inline fun zip_map<Element1, Element2, NewElement>(
        v1: vector<Element1>,
        v2: vector<Element2>,
        f: |Element1, Element2|NewElement
    ): vector<NewElement> {
        // We can't use the constant EVECTORS_LENGTH_MISMATCH here as all calling code would then need to define it
        // due to how inline functions work.
        assert!(length(&v1) == length(&v2), 0x20002);

        let result = vector<NewElement>[];
        zip(v1, v2, |e1, e2| push_back(&mut result, f(e1, e2)));
        result
    }

    /// Filter the vector using the boolean function, removing all elements for which `p(e)` is not true.
    public inline fun filter<Element:drop>(
        v: vector<Element>,
        p: |&Element|bool
    ): vector<Element> {
        let result = vector<Element>[];
        for_each(v, |elem| {
            if (p(&elem)) push_back(&mut result, elem);
        });
        result
    }

    /// Partition, sorts all elements for which pred is true to the front.
    /// Preserves the relative order of the elements for which pred is true,
    /// BUT NOT for the elements for which pred is false.
    public inline fun partition<Element>(
        v: &mut vector<Element>,
        pred: |&Element|bool
    ): u64 {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (!pred(borrow(v, i))) break;
            i = i + 1;
        };
        let p = i;
        i = i + 1;
        while (i < len) {
            if (pred(borrow(v, i))) {
                swap(v, p, i);
                p = p + 1;
            };
            i = i + 1;
        };
        p
    }

    /// rotate(&mut [1, 2, 3, 4, 5], 2) -> [3, 4, 5, 1, 2] in place, returns the split point
    /// ie. 3 in the example above
    public fun rotate<Element>(
        v: &mut vector<Element>,
        rot: u64
    ): u64 {
        let len = length(v);
        rotate_slice(v, 0, rot, len)
    }
    spec rotate {
        pragma intrinsic = true;
    }

    /// Same as above but on a sub-slice of an array [left, right) with left <= rot <= right
    /// returns the
    public fun rotate_slice<Element>(
        v: &mut vector<Element>,
        left: u64,
        rot: u64,
        right: u64
    ): u64 {
        reverse_slice(v, left, rot);
        reverse_slice(v, rot, right);
        reverse_slice(v, left, right);
        left + (right - rot)
    }
    spec rotate_slice {
        pragma intrinsic = true;
    }

    /// Partition the array based on a predicate p, this routine is stable and thus
    /// preserves the relative order of the elements in the two partitions.
    public inline fun stable_partition<Element>(
        v: &mut vector<Element>,
        p: |&Element|bool
    ): u64 {
        let len = length(v);
        let t = empty();
        let f = empty();
        while (len > 0) {
            let e = pop_back(v);
            if (p(&e)) {
                push_back(&mut t, e);
            } else {
                push_back(&mut f, e);
            };
            len = len - 1;
        };
        let pos = length(&t);
        reverse_append(v, t);
        reverse_append(v, f);
        pos
    }

    /// Return true if any element in the vector satisfies the predicate.
    public inline fun any<Element>(
        v: &vector<Element>,
        p: |&Element|bool
    ): bool {
        let result = false;
        let i = 0;
        while (i < length(v)) {
            result = p(borrow(v, i));
            if (result) {
                break
            };
            i = i + 1
        };
        result
    }

    /// Return true if all elements in the vector satisfy the predicate.
    public inline fun all<Element>(
        v: &vector<Element>,
        p: |&Element|bool
    ): bool {
        let result = true;
        let i = 0;
        while (i < length(v)) {
            result = p(borrow(v, i));
            if (!result) {
                break
            };
            i = i + 1
        };
        result
    }

    /// Destroy a vector, just a wrapper around for_each_reverse with a descriptive name
    /// when used in the context of destroying a vector.
    public inline fun destroy<Element>(
        v: vector<Element>,
        d: |Element|
    ) {
        for_each_reverse(v, |e| d(e))
    }

    public fun range(start: u64, end: u64): vector<u64> {
        range_with_step(start, end, 1)
    }

    public fun range_with_step(start: u64, end: u64, step: u64): vector<u64> {
        assert!(step > 0, EINVALID_STEP);

        let vec = vector[];
        while (start < end) {
            push_back(&mut vec, start);
            start = start + step;
        };
        vec
    }

    public fun slice<Element: copy>(
        v: &vector<Element>,
        start: u64,
        end: u64
    ): vector<Element> {
        assert!(start <= end && end <= length(v), EINVALID_SLICE_RANGE);

        let vec = vector[];
        while (start < end) {
            push_back(&mut vec, *borrow(v, start));
            start = start + 1;
        };
        vec
    }

    // =================================================================
    // Module Specification

    spec module {} // Switch to module documentation context

    /// # Helper Functions

    spec module {
        /// Check if `v1` is equal to the result of adding `e` at the end of `v2`
        fun eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
            len(v1) == len(v2) + 1 &&
            v1[len(v1)-1] == e &&
            v1[0..len(v1)-1] == v2[0..len(v2)]
        }

        /// Check if `v` is equal to the result of concatenating `v1` and `v2`
        fun eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
            len(v) == len(v1) + len(v2) &&
            v[0..len(v1)] == v1 &&
            v[len(v1)..len(v)] == v2
        }

        /// Check `v1` is equal to the result of removing the first element of `v2`
        fun eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
            len(v1) + 1 == len(v2) &&
            v1 == v2[1..len(v2)]
        }

        /// Check that `v1` is equal to the result of removing the element at index `i` from `v2`.
        fun eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
            len(v1) + 1 == len(v2) &&
            v1[0..i] == v2[0..i] &&
            v1[i..len(v1)] == v2[i + 1..len(v2)]
        }

        /// Check if `v` contains `e`.
        fun spec_contains<Element>(v: vector<Element>, e: Element): bool {
            exists x in v: x == e
        }
    }

}


================================================
File: aptos-move/framework/move-stdlib/sources/configs/features.move
================================================
/// Defines feature flags for Aptos. Those are used in Aptos specific implementations of features in
/// the Move stdlib, the Aptos stdlib, and the Aptos framework.
///
/// ============================================================================================
/// Feature Flag Definitions
///
/// Each feature flag should come with documentation which justifies the need of the flag.
/// Introduction of a new feature flag requires approval of framework owners. Be frugal when
/// introducing new feature flags, as too many can make it hard to understand the code.
///
/// Each feature flag should come with a specification of a lifetime:
///
/// - a *transient* feature flag is only needed until a related code rollout has happened. This
///   is typically associated with the introduction of new native Move functions, and is only used
///   from Move code. The owner of this feature is obliged to remove it once this can be done.
///
/// - a *permanent* feature flag is required to stay around forever. Typically, those flags guard
///   behavior in native code, and the behavior with or without the feature need to be preserved
///   for playback.
///
/// Note that removing a feature flag still requires the function which tests for the feature
/// (like `code_dependency_check_enabled` below) to stay around for compatibility reasons, as it
/// is a public function. However, once the feature flag is disabled, those functions can constantly
/// return true.
module std::features {
    use std::error;
    use std::signer;
    use std::vector;

    const EINVALID_FEATURE: u64 = 1;
    const EAPI_DISABLED: u64 = 2;
    /// Deployed to production, and disabling is deprecated.
    const EFEATURE_CANNOT_BE_DISABLED: u64 = 3;

    // --------------------------------------------------------------------------------------------
    // Code Publishing

    /// Whether validation of package dependencies is enabled, and the related native function is
    /// available. This is needed because of introduction of a new native function.
    /// Lifetime: transient
    const CODE_DEPENDENCY_CHECK: u64 = 1;

    public fun code_dependency_check_enabled(): bool acquires Features {
        is_enabled(CODE_DEPENDENCY_CHECK)
    }

    /// Whether during upgrade compatibility checking, friend functions should be treated similar like
    /// private functions.
    /// Lifetime: permanent
    const TREAT_FRIEND_AS_PRIVATE: u64 = 2;

    public fun treat_friend_as_private(): bool acquires Features {
        is_enabled(TREAT_FRIEND_AS_PRIVATE)
    }

    /// Whether the new SHA2-512, SHA3-512 and RIPEMD-160 hash function natives are enabled.
    /// This is needed because of the introduction of new native functions.
    /// Lifetime: transient
    const SHA_512_AND_RIPEMD_160_NATIVES: u64 = 3;

    public fun get_sha_512_and_ripemd_160_feature(): u64 { SHA_512_AND_RIPEMD_160_NATIVES }

    public fun sha_512_and_ripemd_160_enabled(): bool acquires Features {
        is_enabled(SHA_512_AND_RIPEMD_160_NATIVES)
    }

    /// Whether the new `aptos_stdlib::type_info::chain_id()` native for fetching the chain ID is enabled.
    /// This is needed because of the introduction of a new native function.
    /// Lifetime: transient
    const APTOS_STD_CHAIN_ID_NATIVES: u64 = 4;

    public fun get_aptos_stdlib_chain_id_feature(): u64 { APTOS_STD_CHAIN_ID_NATIVES }

    public fun aptos_stdlib_chain_id_enabled(): bool acquires Features {
        is_enabled(APTOS_STD_CHAIN_ID_NATIVES)
    }

    /// Whether to allow the use of binary format version v6.
    /// Lifetime: transient
    const VM_BINARY_FORMAT_V6: u64 = 5;

    public fun get_vm_binary_format_v6(): u64 { VM_BINARY_FORMAT_V6 }

    public fun allow_vm_binary_format_v6(): bool acquires Features {
        is_enabled(VM_BINARY_FORMAT_V6)
    }

    /// Whether gas fees are collected and distributed to the block proposers.
    /// Lifetime: transient
    const COLLECT_AND_DISTRIBUTE_GAS_FEES: u64 = 6;

    public fun get_collect_and_distribute_gas_fees_feature(): u64 { COLLECT_AND_DISTRIBUTE_GAS_FEES }

    public fun collect_and_distribute_gas_fees(): bool acquires Features {
        is_enabled(COLLECT_AND_DISTRIBUTE_GAS_FEES)
    }

    /// Whether the new `aptos_stdlib::multi_ed25519::public_key_validate_internal_v2()` native is enabled.
    /// This is needed because of the introduction of a new native function.
    /// Lifetime: transient
    const MULTI_ED25519_PK_VALIDATE_V2_NATIVES: u64 = 7;

    public fun multi_ed25519_pk_validate_v2_feature(): u64 { MULTI_ED25519_PK_VALIDATE_V2_NATIVES }

    public fun multi_ed25519_pk_validate_v2_enabled(): bool acquires Features {
        is_enabled(MULTI_ED25519_PK_VALIDATE_V2_NATIVES)
    }

    /// Whether the new BLAKE2B-256 hash function native is enabled.
    /// This is needed because of the introduction of new native function(s).
    /// Lifetime: transient
    const BLAKE2B_256_NATIVE: u64 = 8;

    public fun get_blake2b_256_feature(): u64 { BLAKE2B_256_NATIVE }

    public fun blake2b_256_enabled(): bool acquires Features {
        is_enabled(BLAKE2B_256_NATIVE)
    }

    /// Whether resource groups are enabled.
    /// This is needed because of new attributes for structs and a change in storage representation.
    const RESOURCE_GROUPS: u64 = 9;

    public fun get_resource_groups_feature(): u64 { RESOURCE_GROUPS }

    public fun resource_groups_enabled(): bool acquires Features {
        is_enabled(RESOURCE_GROUPS)
    }

    /// Whether multisig accounts (different from accounts with multi-ed25519 auth keys) are enabled.
    const MULTISIG_ACCOUNTS: u64 = 10;

    public fun get_multisig_accounts_feature(): u64 { MULTISIG_ACCOUNTS }

    public fun multisig_accounts_enabled(): bool acquires Features {
        is_enabled(MULTISIG_ACCOUNTS)
    }

    /// Whether delegation pools are enabled.
    /// Lifetime: transient
    const DELEGATION_POOLS: u64 = 11;

    public fun get_delegation_pools_feature(): u64 { DELEGATION_POOLS }

    public fun delegation_pools_enabled(): bool acquires Features {
        is_enabled(DELEGATION_POOLS)
    }

    /// Whether generic algebra basic operation support in `crypto_algebra.move` are enabled.
    ///
    /// Lifetime: transient
    const CRYPTOGRAPHY_ALGEBRA_NATIVES: u64 = 12;

    public fun get_cryptography_algebra_natives_feature(): u64 { CRYPTOGRAPHY_ALGEBRA_NATIVES }

    public fun cryptography_algebra_enabled(): bool acquires Features {
        is_enabled(CRYPTOGRAPHY_ALGEBRA_NATIVES)
    }

    /// Whether the generic algebra implementation for BLS12381 operations are enabled.
    ///
    /// Lifetime: transient
    const BLS12_381_STRUCTURES: u64 = 13;

    public fun get_bls12_381_strutures_feature(): u64 { BLS12_381_STRUCTURES }

    public fun bls12_381_structures_enabled(): bool acquires Features {
        is_enabled(BLS12_381_STRUCTURES)
    }


    /// Whether native_public_key_validate aborts when a public key of the wrong length is given
    /// Lifetime: ephemeral
    const ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH: u64 = 14;

    /// Whether struct constructors are enabled
    ///
    /// Lifetime: transient
    const STRUCT_CONSTRUCTORS: u64 = 15;

    /// Whether reward rate decreases periodically.
    /// Lifetime: transient
    const PERIODICAL_REWARD_RATE_DECREASE: u64 = 16;

    public fun get_periodical_reward_rate_decrease_feature(): u64 { PERIODICAL_REWARD_RATE_DECREASE }

    public fun periodical_reward_rate_decrease_enabled(): bool acquires Features {
        is_enabled(PERIODICAL_REWARD_RATE_DECREASE)
    }

    /// Whether enable paritial governance voting on supra_governance.
    /// Lifetime: transient
    const PARTIAL_GOVERNANCE_VOTING: u64 = 17;

    public fun get_partial_governance_voting(): u64 { PARTIAL_GOVERNANCE_VOTING }

    public fun partial_governance_voting_enabled(): bool acquires Features {
        is_enabled(PARTIAL_GOVERNANCE_VOTING)
    }

    /// Charge invariant violation error.
    /// Lifetime: transient
    const CHARGE_INVARIANT_VIOLATION: u64 = 20;

    /// Whether enable paritial governance voting on delegation_pool.
    /// Lifetime: transient
    const DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING: u64 = 21;

    public fun get_delegation_pool_partial_governance_voting(): u64 { DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING }

    public fun delegation_pool_partial_governance_voting_enabled(): bool acquires Features {
        is_enabled(DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING)
    }

    /// Whether alternate gas payer is supported
    /// Lifetime: transient
    const FEE_PAYER_ENABLED: u64 = 22;

    public fun fee_payer_enabled(): bool acquires Features {
        is_enabled(FEE_PAYER_ENABLED)
    }

    /// Whether enable MOVE functions to call create_auid method to create AUIDs.
    /// Lifetime: transient
    const APTOS_UNIQUE_IDENTIFIERS: u64 = 23;

    public fun get_auids(): u64 {
        error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
     }

    public fun auids_enabled(): bool {
        true
    }

    /// Whether the Bulletproofs zero-knowledge range proof module is enabled, and the related native function is
    /// available. This is needed because of the introduction of a new native function.
    /// Lifetime: transient
    const BULLETPROOFS_NATIVES: u64 = 24;

    public fun get_bulletproofs_feature(): u64 { BULLETPROOFS_NATIVES }

    public fun bulletproofs_enabled(): bool acquires Features {
        is_enabled(BULLETPROOFS_NATIVES)
    }

    /// Fix the native formatter for signer.
    /// Lifetime: transient
    const SIGNER_NATIVE_FORMAT_FIX: u64 = 25;

    public fun get_signer_native_format_fix_feature(): u64 { SIGNER_NATIVE_FORMAT_FIX }

    public fun signer_native_format_fix_enabled(): bool acquires Features {
        is_enabled(SIGNER_NATIVE_FORMAT_FIX)
    }

    /// Whether emit function in `event.move` are enabled for module events.
    ///
    /// Lifetime: transient
    const MODULE_EVENT: u64 = 26;

    public fun get_module_event_feature(): u64 { MODULE_EVENT }

    public fun module_event_enabled(): bool acquires Features {
        is_enabled(MODULE_EVENT)
    }

    /// Whether the fix for a counting bug in the script path of the signature checker pass is enabled.
    /// Lifetime: transient
    const SIGNATURE_CHECKER_V2_SCRIPT_FIX: u64 = 29;

    public fun get_aggregator_v2_api_feature(): u64 {
        abort error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
    }

    public fun aggregator_v2_api_enabled(): bool {
        true
    }

    #[deprecated]
    public fun get_aggregator_snapshots_feature(): u64 {
        abort error::invalid_argument(EINVALID_FEATURE)
    }

    #[deprecated]
    public fun aggregator_snapshots_enabled(): bool {
        abort error::invalid_argument(EINVALID_FEATURE)
    }

    const SAFER_RESOURCE_GROUPS: u64 = 31;

    const SAFER_METADATA: u64 = 32;

    const SINGLE_SENDER_AUTHENTICATOR: u64 = 33;

    /// Whether the automatic creation of accounts is enabled for sponsored transactions.
    /// Lifetime: transient
    const SPONSORED_AUTOMATIC_ACCOUNT_CREATION: u64 = 34;

    public fun get_sponsored_automatic_account_creation(): u64 { SPONSORED_AUTOMATIC_ACCOUNT_CREATION }

    public fun sponsored_automatic_account_creation_enabled(): bool acquires Features {
        is_enabled(SPONSORED_AUTOMATIC_ACCOUNT_CREATION)
    }

    const FEE_PAYER_ACCOUNT_OPTIONAL: u64 = 35;

    public fun get_concurrent_token_v2_feature(): u64 {
        error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
    }

    public fun concurrent_token_v2_enabled(): bool {
        true
    }

    #[deprecated]
    public fun get_concurrent_assets_feature(): u64 {
        abort error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
    }

    #[deprecated]
    public fun concurrent_assets_enabled(): bool {
        abort error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
    }

    const LIMIT_MAX_IDENTIFIER_LENGTH: u64 = 38;

    /// Whether allow changing beneficiaries for operators.
    /// Lifetime: transient
    const OPERATOR_BENEFICIARY_CHANGE: u64 = 39;

    public fun get_operator_beneficiary_change_feature(): u64 { OPERATOR_BENEFICIARY_CHANGE }

    public fun operator_beneficiary_change_enabled(): bool acquires Features {
        is_enabled(OPERATOR_BENEFICIARY_CHANGE)
    }

    const VM_BINARY_FORMAT_V7: u64 = 40;

    const RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET: u64 = 41;

    /// Whether the operator commission rate change in delegation pool is enabled.
    /// Lifetime: transient
    const COMMISSION_CHANGE_DELEGATION_POOL: u64 = 42;

    public fun get_commission_change_delegation_pool_feature(): u64 { COMMISSION_CHANGE_DELEGATION_POOL }

    public fun commission_change_delegation_pool_enabled(): bool acquires Features {
        is_enabled(COMMISSION_CHANGE_DELEGATION_POOL)
    }

    /// Whether the generic algebra implementation for BN254 operations are enabled.
    ///
    /// Lifetime: transient
    const BN254_STRUCTURES: u64 = 43;

    public fun get_bn254_strutures_feature(): u64 { BN254_STRUCTURES }

    public fun bn254_structures_enabled(): bool acquires Features {
        is_enabled(BN254_STRUCTURES)
    }

    /// Deprecated by `aptos_framework::randomness_config::RandomnessConfig`.
    const RECONFIGURE_WITH_DKG: u64 = 45;

    public fun get_reconfigure_with_dkg_feature(): u64 { RECONFIGURE_WITH_DKG }

    public fun reconfigure_with_dkg_enabled(): bool acquires Features {
        is_enabled(RECONFIGURE_WITH_DKG)
    }

    /// Whether the OIDB feature is enabled, possibly with the ZK-less verification mode.
    ///
    /// Lifetime: transient
    const KEYLESS_ACCOUNTS: u64 = 46;

    public fun get_keyless_accounts_feature(): u64 { KEYLESS_ACCOUNTS }

    public fun keyless_accounts_enabled(): bool acquires Features {
        is_enabled(KEYLESS_ACCOUNTS)
    }

    /// Whether the ZK-less mode of the keyless accounts feature is enabled.
    ///
    /// Lifetime: transient
    const KEYLESS_BUT_ZKLESS_ACCOUNTS: u64 = 47;

    public fun get_keyless_but_zkless_accounts_feature(): u64 { KEYLESS_BUT_ZKLESS_ACCOUNTS }

    public fun keyless_but_zkless_accounts_feature_enabled(): bool acquires Features {
        is_enabled(KEYLESS_BUT_ZKLESS_ACCOUNTS)
    }

    /// Deprecated by `aptos_framework::jwk_consensus_config::JWKConsensusConfig`.
    const JWK_CONSENSUS: u64 = 49;

    public fun get_jwk_consensus_feature(): u64 { JWK_CONSENSUS }

    public fun jwk_consensus_enabled(): bool acquires Features {
        is_enabled(JWK_CONSENSUS)
    }

    /// Whether enable Fungible Asset creation
    /// to create higher throughput concurrent variants.
    /// Lifetime: transient
    const CONCURRENT_FUNGIBLE_ASSETS: u64 = 50;

    public fun get_concurrent_fungible_assets_feature(): u64 { CONCURRENT_FUNGIBLE_ASSETS }

    public fun concurrent_fungible_assets_enabled(): bool acquires Features {
        is_enabled(CONCURRENT_FUNGIBLE_ASSETS)
    }

    /// Whether deploying to objects is enabled.
    const OBJECT_CODE_DEPLOYMENT: u64 = 52;

    public fun is_object_code_deployment_enabled(): bool acquires Features {
        is_enabled(OBJECT_CODE_DEPLOYMENT)
    }

    /// Whether checking the maximum object nesting is enabled.
    const MAX_OBJECT_NESTING_CHECK: u64 = 53;

    public fun get_max_object_nesting_check_feature(): u64 { MAX_OBJECT_NESTING_CHECK }

    public fun max_object_nesting_check_enabled(): bool acquires Features {
        is_enabled(MAX_OBJECT_NESTING_CHECK)
    }

    /// Whether keyless accounts support passkey-based ephemeral signatures.
    ///
    /// Lifetime: transient
    const KEYLESS_ACCOUNTS_WITH_PASSKEYS: u64 = 54;

    public fun get_keyless_accounts_with_passkeys_feature(): u64 { KEYLESS_ACCOUNTS_WITH_PASSKEYS }

    public fun keyless_accounts_with_passkeys_feature_enabled(): bool acquires Features {
        is_enabled(KEYLESS_ACCOUNTS_WITH_PASSKEYS)
    }

    /// Whether the Multisig V2 enhancement feature is enabled.
    ///
    /// Lifetime: transient
    const MULTISIG_V2_ENHANCEMENT: u64 = 55;

    public fun get_multisig_v2_enhancement_feature(): u64 { MULTISIG_V2_ENHANCEMENT }

    public fun multisig_v2_enhancement_feature_enabled(): bool acquires Features {
        is_enabled(MULTISIG_V2_ENHANCEMENT)
    }

    /// Whether delegators allowlisting for delegation pools is supported.
    /// Lifetime: transient
    const DELEGATION_POOL_ALLOWLISTING: u64 = 56;

    public fun get_delegation_pool_allowlisting_feature(): u64 { DELEGATION_POOL_ALLOWLISTING }

    public fun delegation_pool_allowlisting_enabled(): bool acquires Features {
        is_enabled(DELEGATION_POOL_ALLOWLISTING)
    }

    /// Whether aptos_framwork enables the behavior of module event migration.
    ///
    /// Lifetime: transient
    const MODULE_EVENT_MIGRATION: u64 = 57;

    public fun get_module_event_migration_feature(): u64 { MODULE_EVENT_MIGRATION }

    public fun module_event_migration_enabled(): bool acquires Features {
        is_enabled(MODULE_EVENT_MIGRATION)
    }

    /// Whether the transaction context extension is enabled. This feature allows the module
    /// `transaction_context` to provide contextual information about the user transaction.
    ///
    /// Lifetime: transient
    const TRANSACTION_CONTEXT_EXTENSION: u64 = 59;

    public fun get_transaction_context_extension_feature(): u64 { TRANSACTION_CONTEXT_EXTENSION }

    public fun transaction_context_extension_enabled(): bool acquires Features {
        is_enabled(TRANSACTION_CONTEXT_EXTENSION)
    }

    /// Whether migration from coin to fungible asset feature is enabled.
    ///
    /// Lifetime: transient
    const COIN_TO_FUNGIBLE_ASSET_MIGRATION: u64 = 60;

    public fun get_coin_to_fungible_asset_migration_feature(): u64 { COIN_TO_FUNGIBLE_ASSET_MIGRATION }

    public fun coin_to_fungible_asset_migration_feature_enabled(): bool acquires Features {
        is_enabled(COIN_TO_FUNGIBLE_ASSET_MIGRATION)
    }

    const PRIMARY_APT_FUNGIBLE_STORE_AT_USER_ADDRESS: u64 = 61;

    #[deprecated]
    public fun get_primary_apt_fungible_store_at_user_address_feature(
    ): u64 {
        abort error::invalid_argument(EINVALID_FEATURE)
    }

    #[deprecated]
    public fun primary_apt_fungible_store_at_user_address_enabled(): bool acquires Features {
        is_enabled(PRIMARY_APT_FUNGIBLE_STORE_AT_USER_ADDRESS)
    }

    const AGGREGATOR_V2_IS_AT_LEAST_API: u64 = 66;

    public fun aggregator_v2_is_at_least_api_enabled(): bool acquires Features {
        is_enabled(AGGREGATOR_V2_IS_AT_LEAST_API)
    }

    /// Whether we use more efficient native implementation of computing object derived address
    const OBJECT_NATIVE_DERIVED_ADDRESS: u64 = 62;

    public fun get_object_native_derived_address_feature(): u64 { OBJECT_NATIVE_DERIVED_ADDRESS }

    public fun object_native_derived_address_enabled(): bool acquires Features {
        is_enabled(OBJECT_NATIVE_DERIVED_ADDRESS)
    }

    /// Whether the dispatchable fungible asset standard feature is enabled.
    ///
    /// Lifetime: transient
    const DISPATCHABLE_FUNGIBLE_ASSET: u64 = 63;

    public fun get_dispatchable_fungible_asset_feature(): u64 { DISPATCHABLE_FUNGIBLE_ASSET }

    public fun dispatchable_fungible_asset_enabled(): bool acquires Features {
        is_enabled(DISPATCHABLE_FUNGIBLE_ASSET)
    }

    /// Lifetime: transient
    const NEW_ACCOUNTS_DEFAULT_TO_FA_SUPRA_STORE: u64 = 64;

    public fun get_new_accounts_default_to_fa_supra_store_feature(): u64 { NEW_ACCOUNTS_DEFAULT_TO_FA_SUPRA_STORE }

    public fun new_accounts_default_to_fa_supra_store_enabled(): bool acquires Features {
        is_enabled(NEW_ACCOUNTS_DEFAULT_TO_FA_SUPRA_STORE)
    }

    /// Lifetime: transient
    const OPERATIONS_DEFAULT_TO_FA_SUPRA_STORE: u64 = 65;

    public fun get_operations_default_to_fa_supra_store_feature(): u64 { OPERATIONS_DEFAULT_TO_FA_SUPRA_STORE }

    public fun operations_default_to_fa_supra_store_enabled(): bool acquires Features {
        is_enabled(OPERATIONS_DEFAULT_TO_FA_SUPRA_STORE)
    }

    /// Whether enable concurent Fungible Balance
    /// to create higher throughput concurrent variants.
    /// Lifetime: transient
    const CONCURRENT_FUNGIBLE_BALANCE: u64 = 67;

    public fun get_concurrent_fungible_balance_feature(): u64 { CONCURRENT_FUNGIBLE_BALANCE }

    public fun concurrent_fungible_balance_enabled(): bool acquires Features {
        is_enabled(CONCURRENT_FUNGIBLE_BALANCE)
    }

    /// Whether to default new Fungible Store to the concurrent variant.
    /// Lifetime: transient
    const DEFAULT_TO_CONCURRENT_FUNGIBLE_BALANCE: u64 = 68;

    public fun get_default_to_concurrent_fungible_balance_feature(): u64 { DEFAULT_TO_CONCURRENT_FUNGIBLE_BALANCE }

    public fun default_to_concurrent_fungible_balance_enabled(): bool acquires Features {
        is_enabled(DEFAULT_TO_CONCURRENT_FUNGIBLE_BALANCE)
    }

    /// Whether the multisig v2 fix is enabled. Once enabled, the multisig transaction execution will explicitly
    /// abort if the provided payload does not match the payload stored on-chain.
    ///
    /// Lifetime: transient
    const ABORT_IF_MULTISIG_PAYLOAD_MISMATCH: u64 = 70;

    public fun get_abort_if_multisig_payload_mismatch_feature(): u64 { ABORT_IF_MULTISIG_PAYLOAD_MISMATCH }

    public fun abort_if_multisig_payload_mismatch_enabled(): bool acquires Features {
        is_enabled(ABORT_IF_MULTISIG_PAYLOAD_MISMATCH)
    }

    // ============================================================================================
    // Feature Flag Implementation

    /// The provided signer has not a framework address.
    const EFRAMEWORK_SIGNER_NEEDED: u64 = 1;

    /// The enabled features, represented by a bitset stored on chain.
    struct Features has key {
        features: vector<u8>,
    }

    /// This resource holds the feature vec updates received in the current epoch.
    /// On epoch change, the updates take effect and this buffer is cleared.
    struct PendingFeatures has key {
        features: vector<u8>,
    }

    /// Deprecated to prevent validator set changes during DKG.
    ///
    /// Genesis/tests should use `change_feature_flags_internal()` for feature vec initialization.
    ///
    /// Governance proposals should use `change_feature_flags_for_next_epoch()` to enable/disable features.
    public fun change_feature_flags(_framework: &signer, _enable: vector<u64>, _disable: vector<u64>) {
        abort (error::invalid_state(EAPI_DISABLED))
    }

    /// Update feature flags directly. Only used in genesis/tests.
    fun change_feature_flags_internal(framework: &signer, enable: vector<u64>, disable: vector<u64>) acquires Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));
        if (!exists<Features>(@std)) {
            move_to<Features>(framework, Features { features: vector[] })
        };
        let features = &mut borrow_global_mut<Features>(@std).features;
        vector::for_each_ref(&enable, |feature| {
            set(features, *feature, true);
        });
        vector::for_each_ref(&disable, |feature| {
            set(features, *feature, false);
        });
    }

    /// Enable and disable features for the next epoch.
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            borrow_global<Features>(@std).features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }

    /// Apply all the pending feature flag changes. Should only be used at the end of a reconfiguration with DKG.
    ///
    /// While the scope is public, it can only be usd in system transactions like `block_prologue` and governance proposals,
    /// who have permission to set the flag that's checked in `extract()`.
    public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
        ensure_framework_signer(framework);
        if (exists<PendingFeatures>(@std)) {
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            if (exists<Features>(@std)) {
                borrow_global_mut<Features>(@std).features = features;
            } else {
                move_to(framework, Features { features })
            }
        }
    }

    #[view]
    /// Check whether the feature is enabled.
    public fun is_enabled(feature: u64): bool acquires Features {
        exists<Features>(@std) &&
            contains(&borrow_global<Features>(@std).features, feature)
    }

    /// Helper to include or exclude a feature flag.
    fun set(features: &mut vector<u8>, feature: u64, include: bool) {
        let byte_index = feature / 8;
        let bit_mask = 1 << ((feature % 8) as u8);
        while (vector::length(features) <= byte_index) {
            vector::push_back(features, 0)
        };
        let entry = vector::borrow_mut(features, byte_index);
        if (include)
            *entry = *entry | bit_mask
        else
            *entry = *entry & (0xff ^ bit_mask)
    }

    /// Helper to check whether a feature flag is enabled.
    fun contains(features: &vector<u8>, feature: u64): bool {
        let byte_index = feature / 8;
        let bit_mask = 1 << ((feature % 8) as u8);
        byte_index < vector::length(features) && (*vector::borrow(features, byte_index) & bit_mask) != 0
    }

    fun apply_diff(features: &mut vector<u8>, enable: vector<u64>, disable: vector<u64>) {
        vector::for_each(enable, |feature| {
            set(features, feature, true);
        });
        vector::for_each(disable, |feature| {
            set(features, feature, false);
        });
    }

    fun ensure_framework_signer(account: &signer) {
        let addr = signer::address_of(account);
        assert!(addr == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));
    }

    #[verify_only]
    public fun change_feature_flags_for_verification(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires Features {
        change_feature_flags_internal(framework, enable, disable)
    }

    #[test_only]
    public fun change_feature_flags_for_testing(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires Features {
        change_feature_flags_internal(framework, enable, disable)
    }

    #[test]
    fun test_feature_sets() {
        let features = vector[];
        set(&mut features, 1, true);
        set(&mut features, 5, true);
        set(&mut features, 17, true);
        set(&mut features, 23, true);
        assert!(contains(&features, 1), 0);
        assert!(contains(&features, 5), 1);
        assert!(contains(&features, 17), 2);
        assert!(contains(&features, 23), 3);
        set(&mut features, 5, false);
        set(&mut features, 17, false);
        assert!(contains(&features, 1), 0);
        assert!(!contains(&features, 5), 1);
        assert!(!contains(&features, 17), 2);
        assert!(contains(&features, 23), 3);
    }

    #[test(fx = @std)]
    fun test_change_feature_txn(fx: signer) acquires Features {
        change_feature_flags_for_testing(&fx, vector[1, 9, 23], vector[]);
        assert!(is_enabled(1), 1);
        assert!(is_enabled(9), 2);
        assert!(is_enabled(23), 3);
        change_feature_flags_for_testing(&fx, vector[17], vector[9]);
        assert!(is_enabled(1), 1);
        assert!(!is_enabled(9), 2);
        assert!(is_enabled(17), 3);
        assert!(is_enabled(23), 4);
    }
}


================================================
File: aptos-move/framework/move-stdlib/sources/configs/features.spec.move
================================================
/// Maintains feature flags.
spec std::features {
    spec Features {
        pragma bv=b"0";
    }

    spec PendingFeatures {
        pragma bv=b"0";
    }

    spec set(features: &mut vector<u8>, feature: u64, include: bool) {
        pragma bv=b"0";
        aborts_if false;
        ensures feature / 8 < len(features);
        ensures include == spec_contains(features, feature);
    }


    spec apply_diff(features: &mut vector<u8>, enable: vector<u64>, disable: vector<u64>) {
        aborts_if [abstract] false; // TODO(#12011)
        ensures [abstract] forall i in disable: !spec_contains(features, i);
        ensures [abstract] forall i in enable: !vector::spec_contains(disable, i)
            ==> spec_contains(features, i);
        pragma opaque;
    }

    spec contains(features: &vector<u8>, feature: u64): bool {
        pragma bv=b"0";
        aborts_if false;
        ensures result == spec_contains(features, feature);
    }

    spec change_feature_flags_for_next_epoch(framework: &signer, enable: vector<u64>, disable: vector<u64>) {
        aborts_if signer::address_of(framework) != @std;
        // TODO(tengzhang): add functional spec
        // TODO(#12526): undo declaring opaque once fixed
        pragma opaque;
        modifies global<Features>(@std);
        modifies global<PendingFeatures>(@std);
    }

    spec fun spec_contains(features: vector<u8>, feature: u64): bool {
        ((int2bv((((1 as u8) << ((feature % (8 as u64)) as u64)) as u8)) as u8) & features[feature/8] as u8) > (0 as u8)
            && (feature / 8) < len(features)
    }

    spec change_feature_flags_internal(framework: &signer, enable: vector<u64>, disable: vector<u64>) {
        pragma opaque;
        modifies global<Features>(@std);
        aborts_if signer::address_of(framework) != @std;
    }

    spec is_enabled(feature: u64): bool {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_is_enabled(feature);
    }

    spec fun spec_is_enabled(feature: u64): bool;

    spec fun spec_periodical_reward_rate_decrease_enabled(): bool {
        spec_is_enabled(PERIODICAL_REWARD_RATE_DECREASE)
    }

    spec fun spec_fee_payer_enabled(): bool {
        spec_is_enabled(FEE_PAYER_ENABLED)
    }

    spec fun spec_collect_and_distribute_gas_fees_enabled(): bool {
        spec_is_enabled(COLLECT_AND_DISTRIBUTE_GAS_FEES)
    }

    spec fun spec_module_event_enabled(): bool {
        spec_is_enabled(MODULE_EVENT)
    }

    spec periodical_reward_rate_decrease_enabled {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_periodical_reward_rate_decrease_enabled();
    }

    spec fun spec_partial_governance_voting_enabled(): bool {
        spec_is_enabled(PARTIAL_GOVERNANCE_VOTING)
    }

    spec partial_governance_voting_enabled {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_partial_governance_voting_enabled();
    }

    spec module_event_enabled {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_module_event_enabled();
    }

    spec fun spec_abort_if_multisig_payload_mismatch_enabled(): bool {
        spec_is_enabled(ABORT_IF_MULTISIG_PAYLOAD_MISMATCH)
    }

    spec abort_if_multisig_payload_mismatch_enabled {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_abort_if_multisig_payload_mismatch_enabled();
    }

    spec on_new_epoch(framework: &signer) {
        requires @std == signer::address_of(framework);
        let features_pending = global<PendingFeatures>(@std).features;
        let post features_std = global<Features>(@std).features;
        ensures exists<PendingFeatures>(@std) ==> features_std == features_pending;
        aborts_if false;
    }

    spec fun spec_sha_512_and_ripemd_160_enabled(): bool {
        spec_is_enabled(SHA_512_AND_RIPEMD_160_NATIVES)
    }
}


================================================
File: aptos-move/framework/move-stdlib/src/lib.rs
================================================
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

pub mod natives;


================================================
File: aptos-move/framework/move-stdlib/src/natives/bcs.rs
================================================
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use aptos_gas_schedule::gas_params::natives::move_stdlib::*;
use aptos_native_interface::{
    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeError,
    SafeNativeResult,
};
use move_core_types::{
    gas_algebra::NumBytes, vm_status::sub_status::NFE_BCS_SERIALIZATION_FAILURE,
};
use move_vm_runtime::native_functions::NativeFunction;
use move_vm_types::{
    loaded_data::runtime_types::Type,
    values::{values_impl::Reference, Value},
};
use smallvec::{smallvec, SmallVec};
use std::collections::VecDeque;

/***************************************************************************************************
 * native fun to_bytes
 *
 *   gas cost: size_of(val_type) * input_unit_cost +        | get type layout
 *             size_of(val) * input_unit_cost +             | serialize value
 *             max(size_of(output), 1) * output_unit_cost
 *
 *             If any of the first two steps fails, a partial cost + an additional failure_cost
 *             will be charged.
 *
 **************************************************************************************************/
/// Rust implementation of Move's `native public fun to_bytes<T>(&T): vector<u8>`
#[inline]
fn native_to_bytes(
    context: &mut SafeNativeContext,
    mut ty_args: Vec<Type>,
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(args.len() == 1);

    // pop type and value
    let ref_to_val = safely_pop_arg!(args, Reference);
    let arg_type = ty_args.pop().unwrap();

    // get type layout
    let layout = match context.type_to_type_layout(&arg_type) {
        Ok(layout) => layout,
        Err(_) => {
            context.charge(BCS_TO_BYTES_FAILURE)?;
            return Err(SafeNativeError::Abort {
                abort_code: NFE_BCS_SERIALIZATION_FAILURE,
            });
        },
    };

    // serialize value
    let val = ref_to_val.read_ref()?;
    let serialized_value = match val.simple_serialize(&layout) {
        Some(serialized_value) => serialized_value,
        None => {
            context.charge(BCS_TO_BYTES_FAILURE)?;
            return Err(SafeNativeError::Abort {
                abort_code: NFE_BCS_SERIALIZATION_FAILURE,
            });
        },
    };
    context
        .charge(BCS_TO_BYTES_PER_BYTE_SERIALIZED * NumBytes::new(serialized_value.len() as u64))?;

    Ok(smallvec![Value::vector_u8(serialized_value)])
}

/***************************************************************************************************
 * module
 **************************************************************************************************/
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let funcs = [("to_bytes", native_to_bytes as RawSafeNative)];

    builder.make_named_natives(funcs)
}


================================================
File: aptos-move/framework/move-stdlib/src/natives/hash.rs
================================================
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use aptos_gas_schedule::gas_params::natives::move_stdlib::*;
use aptos_native_interface::{
    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeResult,
};
use move_core_types::gas_algebra::NumBytes;
use move_vm_runtime::native_functions::NativeFunction;
use move_vm_types::{loaded_data::runtime_types::Type, values::Value};
use sha2::{Digest, Sha256};
use sha3::Sha3_256;
use smallvec::{smallvec, SmallVec};
use std::collections::VecDeque;

/***************************************************************************************************
 * native fun sha2_256
 *
 *   gas cost: base_cost + unit_cost * max(input_length_in_bytes, legacy_min_input_len)
 *
 **************************************************************************************************/
#[inline]
fn native_sha2_256(
    context: &mut SafeNativeContext,
    _ty_args: Vec<Type>,
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    let hash_arg = safely_pop_arg!(arguments, Vec<u8>);

    context.charge(
        HASH_SHA2_256_BASE + HASH_SHA2_256_PER_BYTE * NumBytes::new(hash_arg.len() as u64),
    )?;

    let hash_vec = Sha256::digest(hash_arg.as_slice()).to_vec();
    Ok(smallvec![Value::vector_u8(hash_vec)])
}

/***************************************************************************************************
 * native fun sha3_256
 *
 *   gas cost: base_cost + unit_cost * max(input_length_in_bytes, legacy_min_input_len)
 *
 **************************************************************************************************/
#[inline]
fn native_sha3_256(
    context: &mut SafeNativeContext,
    _ty_args: Vec<Type>,
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    let hash_arg = safely_pop_arg!(arguments, Vec<u8>);

    context.charge(
        HASH_SHA3_256_BASE + HASH_SHA3_256_PER_BYTE * NumBytes::new(hash_arg.len() as u64),
    )?;

    let hash_vec = Sha3_256::digest(hash_arg.as_slice()).to_vec();
    Ok(smallvec![Value::vector_u8(hash_vec)])
}

/***************************************************************************************************
 * module
 **************************************************************************************************/
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let natives = [
        ("sha2_256", native_sha2_256 as RawSafeNative),
        ("sha3_256", native_sha3_256),
    ];

    builder.make_named_natives(natives)
}


================================================
File: aptos-move/framework/move-stdlib/src/natives/mod.rs
================================================
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

pub mod bcs;
pub mod hash;
pub mod signer;
pub mod string;
#[cfg(feature = "testing")]
pub mod unit_test;

use aptos_native_interface::SafeNativeBuilder;
use move_core_types::account_address::AccountAddress;
use move_vm_runtime::native_functions::{make_table_from_iter, NativeFunctionTable};

pub fn all_natives(
    move_std_addr: AccountAddress,
    builder: &mut SafeNativeBuilder,
) -> NativeFunctionTable {
    let mut natives = vec![];

    macro_rules! add_natives {
        ($module_name:expr, $natives:expr) => {
            natives.extend(
                $natives.map(|(func_name, func)| ($module_name.to_string(), func_name, func)),
            );
        };
    }

    builder.with_incremental_gas_charging(false, |builder| {
        add_natives!("bcs", bcs::make_all(builder));
        add_natives!("hash", hash::make_all(builder));
        add_natives!("signer", signer::make_all(builder));
        add_natives!("string", string::make_all(builder));
        #[cfg(feature = "testing")]
        {
            add_natives!("unit_test", unit_test::make_all(builder));
        }
    });

    make_table_from_iter(move_std_addr, natives)
}


================================================
File: aptos-move/framework/move-stdlib/src/natives/signer.rs
================================================
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use aptos_gas_schedule::gas_params::natives::move_stdlib::*;
use aptos_native_interface::{
    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeResult,
};
use move_vm_runtime::native_functions::NativeFunction;
use move_vm_types::{
    loaded_data::runtime_types::Type,
    values::{values_impl::SignerRef, Value},
};
use smallvec::{smallvec, SmallVec};
use std::collections::VecDeque;

/***************************************************************************************************
 * native fun borrow_address
 *
 *   gas cost: base_cost
 *
 **************************************************************************************************/
#[inline]
fn native_borrow_address(
    context: &mut SafeNativeContext,
    _ty_args: Vec<Type>,
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    let signer_reference = safely_pop_arg!(arguments, SignerRef);

    context.charge(SIGNER_BORROW_ADDRESS_BASE)?;

    Ok(smallvec![signer_reference.borrow_signer()?])
}

/***************************************************************************************************
 * module
 **************************************************************************************************/
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let natives = [("borrow_address", native_borrow_address as RawSafeNative)];
    builder.make_named_natives(natives)
}


================================================
File: aptos-move/framework/move-stdlib/src/natives/string.rs
================================================
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

//! Implementation of native functions for utf8 strings.

use aptos_gas_schedule::gas_params::natives::move_stdlib::*;
use aptos_native_interface::{
    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeResult,
};
use move_core_types::gas_algebra::NumBytes;
use move_vm_runtime::native_functions::NativeFunction;
use move_vm_types::{
    loaded_data::runtime_types::Type,
    values::{Value, VectorRef},
};
use smallvec::{smallvec, SmallVec};
use std::collections::VecDeque;

// The implementation approach delegates all utf8 handling to Rust.
// This is possible without copying of bytes because (a) we can
// get a `std::cell::Ref<Vec<u8>>` from a `vector<u8>` and in turn a `&[u8]`
// from that (b) assuming that `vector<u8>` embedded in a string
// is already valid utf8, we can use `str::from_utf8_unchecked` to
// create a `&str` view on the bytes without a copy. Once we have this
// view, we can call ut8 functions like length, substring, etc.

/***************************************************************************************************
 * native fun internal_check_utf8
 *
 *   gas cost: base_cost + unit_cost * length_in_bytes
 *
 **************************************************************************************************/
fn native_check_utf8(
    context: &mut SafeNativeContext,
    _ty_args: Vec<Type>,
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 1);
    let s_arg = safely_pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();

    context.charge(
        STRING_CHECK_UTF8_BASE
            + STRING_CHECK_UTF8_PER_BYTE * NumBytes::new(s_ref.as_slice().len() as u64),
    )?;

    let ok = std::str::from_utf8(s_ref.as_slice()).is_ok();
    // TODO: extensible native cost tables

    Ok(smallvec![Value::bool(ok)])
}

/***************************************************************************************************
 * native fun internal_is_char_boundary
 *
 *   gas cost: base_cost
 *
 **************************************************************************************************/
fn native_is_char_boundary(
    context: &mut SafeNativeContext,
    _ty_args: Vec<Type>,
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 2);

    context.charge(STRING_IS_CHAR_BOUNDARY_BASE)?;

    let i = safely_pop_arg!(args, u64);
    let s_arg = safely_pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();
    let ok = unsafe {
        // This is safe because we guarantee the bytes to be utf8.
        std::str::from_utf8_unchecked(s_ref.as_slice()).is_char_boundary(i as usize)
    };

    Ok(smallvec![Value::bool(ok)])
}

/***************************************************************************************************
 * native fun internal_sub_string
 *
 *   gas cost: base_cost + unit_cost * sub_string_length_in_bytes
 *
 **************************************************************************************************/
fn native_sub_string(
    context: &mut SafeNativeContext,
    _ty_args: Vec<Type>,
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 3);

    context.charge(STRING_SUB_STRING_BASE)?;

    let j = safely_pop_arg!(args, u64) as usize;
    let i = safely_pop_arg!(args, u64) as usize;

    if j < i {
        // TODO: The abort code should follow the error convention.
        return Err(aptos_native_interface::SafeNativeError::Abort { abort_code: 1 });
    }

    context.charge(STRING_SUB_STRING_PER_BYTE * NumBytes::new((j - i) as u64))?;

    let s_arg = safely_pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();
    let s_str = unsafe {
        // This is safe because we guarantee the bytes to be utf8.
        std::str::from_utf8_unchecked(s_ref.as_slice())
    };
    let v = Value::vector_u8(s_str[i..j].as_bytes().iter().cloned());

    Ok(smallvec![v])
}

/***************************************************************************************************
 * native fun internal_index_of
 *
 *   gas cost: base_cost + unit_cost * bytes_searched
 *
 **************************************************************************************************/
fn native_index_of(
    context: &mut SafeNativeContext,
    _ty_args: Vec<Type>,
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 2);

    context.charge(STRING_INDEX_OF_BASE)?;

    let r_arg = safely_pop_arg!(args, VectorRef);
    let r_ref = r_arg.as_bytes_ref();
    let r_str = unsafe { std::str::from_utf8_unchecked(r_ref.as_slice()) };

    context.charge(STRING_INDEX_OF_PER_BYTE_PATTERN * NumBytes::new(r_str.len() as u64))?;

    let s_arg = safely_pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();
    let s_str = unsafe { std::str::from_utf8_unchecked(s_ref.as_slice()) };
    let pos = match s_str.find(r_str) {
        Some(size) => size,
        None => s_str.len(),
    };

    // TODO(Gas): What is the algorithm used for the search?
    //            Ideally it should be something like KMP with O(n) time complexity...
    context.charge(STRING_INDEX_OF_PER_BYTE_SEARCHED * NumBytes::new(pos as u64))?;

    Ok(smallvec![Value::u64(pos as u64)])
}

/***************************************************************************************************
 * module
 **************************************************************************************************/
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let natives = [
        ("internal_check_utf8", native_check_utf8 as RawSafeNative),
        ("internal_is_char_boundary", native_is_char_boundary),
        ("internal_sub_string", native_sub_string),
        ("internal_index_of", native_index_of),
    ];

    builder.make_named_natives(natives)
}


================================================
File: aptos-move/framework/move-stdlib/src/natives/unit_test.rs
================================================
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use aptos_native_interface::{
    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeResult,
};
use move_core_types::account_address::AccountAddress;
use move_vm_runtime::native_functions::NativeFunction;
use move_vm_types::{loaded_data::runtime_types::Type, values::Value};
use smallvec::{smallvec, SmallVec};
use std::collections::VecDeque;

/***************************************************************************************************
 * native fun create_signers_for_testing
 *
 *   gas cost: base_cost + unit_cost * num_of_signers
 *
 **************************************************************************************************/
fn to_le_bytes(i: u64) -> [u8; AccountAddress::LENGTH] {
    let bytes = i.to_le_bytes();
    let mut result = [0u8; AccountAddress::LENGTH];
    result[..bytes.len()].clone_from_slice(bytes.as_ref());
    result
}

fn native_create_signers_for_testing(
    _context: &mut SafeNativeContext,
    ty_args: Vec<Type>,
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(args.len() == 1);

    let num_signers = safely_pop_arg!(args, u64);

    let signers = Value::vector_for_testing_only(
        (0..num_signers).map(|i| Value::signer(AccountAddress::new(to_le_bytes(i)))),
    );

    Ok(smallvec![signers])
}

/***************************************************************************************************
 * module
 **************************************************************************************************/
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let natives = [(
        "create_signers_for_testing",
        native_create_signers_for_testing as RawSafeNative,
    )];

    builder.make_named_natives(natives)
}


================================================
File: aptos-move/framework/move-stdlib/tests/bcs_tests.move
================================================
#[test_only]
module std::bcs_tests {
    use std::bcs;

    struct Box<T> has copy, drop, store { x: T }
    struct Box3<T> has copy, drop, store { x: Box<Box<T>> }
    struct Box7<T> has copy, drop, store { x: Box3<Box3<T>> }
    struct Box15<T> has copy, drop, store { x: Box7<Box7<T>> }
    struct Box31<T> has copy, drop, store { x: Box15<Box15<T>> }
    struct Box63<T> has copy, drop, store { x: Box31<Box31<T>> }
    struct Box127<T> has copy, drop, store { x: Box63<Box63<T>> }

    /* Deactivated because of address size dependency
    #[test]
    fun bcs_address() {
        let addr = @0x89b9f9d1fadc027cf9532d6f99041522;
        let expected_output = x"89b9f9d1fadc027cf9532d6f99041522";
        assert!(bcs::to_bytes(&addr) == expected_output, 0);
    }
    */

    #[test]
    fun bcs_bool() {
        let expected_output = x"01";
        assert!(bcs::to_bytes(&true) == expected_output, 0);
    }

    #[test]
    fun bcs_u8() {
        let expected_output = x"01";
        assert!(bcs::to_bytes(&1u8) == expected_output, 0);
    }

    #[test]
    fun bcs_u64() {
        let expected_output = x"0100000000000000";
        assert!(bcs::to_bytes(&1) == expected_output, 0);
    }

    #[test]
    fun bcs_u128() {
        let expected_output = x"01000000000000000000000000000000";
        assert!(bcs::to_bytes(&1u128) == expected_output, 0);
    }

    #[test]
    fun bcs_vec_u8() {
        let v = x"0f";
        let expected_output = x"010f";
        assert!(bcs::to_bytes(&v) == expected_output, 0);
    }

    fun box3<T>(x: T): Box3<T> {
        Box3 { x: Box { x: Box { x } } }
    }

    fun box7<T>(x: T): Box7<T> {
        Box7 { x: box3(box3(x)) }
    }

    fun box15<T>(x: T): Box15<T> {
        Box15 { x: box7(box7(x)) }
    }

    fun box31<T>(x: T): Box31<T> {
        Box31 { x: box15(box15(x)) }
    }

    fun box63<T>(x: T): Box63<T> {
        Box63 { x: box31(box31(x)) }
    }

    fun box127<T>(x: T): Box127<T> {
        Box127 { x: box63(box63(x)) }
    }

    #[test]
    fun encode_128() {
        bcs::to_bytes(&box127(true));
    }

    /* Deactivated because we now limit the depth of values you could create inside the VM
    #[test]
    #[expected_failure(abort_code = 453, location = std::bcs)]
    fun encode_129() {
        bcs::to_bytes(&Box { x: box127(true) });
    }
    */
}


================================================
File: aptos-move/framework/move-stdlib/tests/bit_vector_tests.move
================================================
#[test_only]
module std::bit_vector_tests {
    use std::bit_vector;

    #[test_only]
    fun test_bitvector_set_unset_of_size(k: u64) {
        let bitvector = bit_vector::new(k);
        let index = 0;
        while (index < k) {
            bit_vector::set(&mut bitvector, index);
            assert!(bit_vector::is_index_set(&bitvector, index), 0);
            index = index + 1;
            let index_to_right = index;
            while (index_to_right < k) {
                assert!(!bit_vector::is_index_set(&bitvector, index_to_right), 1);
                index_to_right = index_to_right + 1;
            };
        };
        // now go back down unsetting
        index = 0;

        while (index < k) {
            bit_vector::unset(&mut bitvector, index);
            assert!(!bit_vector::is_index_set(&bitvector, index), 0);
            index = index + 1;
            let index_to_right = index;
            while (index_to_right < k) {
                assert!(bit_vector::is_index_set(&bitvector, index_to_right), 1);
                index_to_right = index_to_right + 1;
            };
        };
    }

    #[test]
    #[expected_failure(abort_code = bit_vector::EINDEX)]
    fun set_bit_out_of_bounds() {
        let bitvector = bit_vector::new(bit_vector::word_size());
        bit_vector::set(&mut bitvector, bit_vector::word_size());
    }

    #[test]
    #[expected_failure(abort_code = bit_vector::EINDEX)]
    fun unset_bit_out_of_bounds() {
        let bitvector = bit_vector::new(bit_vector::word_size());
        bit_vector::unset(&mut bitvector, bit_vector::word_size());
    }

    #[test]
    #[expected_failure(abort_code = bit_vector::EINDEX)]
    fun index_bit_out_of_bounds() {
        let bitvector = bit_vector::new(bit_vector::word_size());
        bit_vector::is_index_set(&mut bitvector, bit_vector::word_size());
    }

    #[test]
    fun test_set_bit_and_index_basic() {
        test_bitvector_set_unset_of_size(8)
    }

    #[test]
    fun test_set_bit_and_index_odd_size() {
        test_bitvector_set_unset_of_size(300)
    }

    #[test]
    fun longest_sequence_no_set_zero_index() {
        let bitvector = bit_vector::new(100);
        assert!(bit_vector::longest_set_sequence_starting_at(&bitvector, 0) == 0, 0);
    }

    #[test]
    fun longest_sequence_one_set_zero_index() {
        let bitvector = bit_vector::new(100);
        bit_vector::set(&mut bitvector, 1);
        assert!(bit_vector::longest_set_sequence_starting_at(&bitvector, 0) == 0, 0);
    }

    #[test]
    fun longest_sequence_no_set_nonzero_index() {
        let bitvector = bit_vector::new(100);
        assert!(bit_vector::longest_set_sequence_starting_at(&bitvector, 51) == 0, 0);
    }

    #[test]
    fun longest_sequence_two_set_nonzero_index() {
        let bitvector = bit_vector::new(100);
        bit_vector::set(&mut bitvector, 50);
        bit_vector::set(&mut bitvector, 52);
        assert!(bit_vector::longest_set_sequence_starting_at(&bitvector, 51) == 0, 0);
    }

    #[test]
    fun longest_sequence_with_break() {
        let bitvector = bit_vector::new(100);
        let i = 0;
        while (i < 20) {
            bit_vector::set(&mut bitvector, i);
            i = i + 1;
        };
        // create a break in the run
        i = i + 1;
        while (i < 100) {
            bit_vector::set(&mut bitvector, i);
            i = i + 1;
        };
        assert!(bit_vector::longest_set_sequence_starting_at(&bitvector, 0) == 20, 0);
        assert!(bit_vector::longest_set_sequence_starting_at(&bitvector, 20) == 0, 0);
        assert!(bit_vector::longest_set_sequence_starting_at(&bitvector, 21) == 100 - 21, 0);
    }

    #[test]
    fun test_shift_left() {
        let bitlen = 133;
        let bitvector = bit_vector::new(bitlen);

        let i = 0;
        while (i < bitlen) {
            bit_vector::set(&mut bitvector, i);
            i = i + 1;
        };

        i = bitlen - 1;
        while (i > 0) {
            assert!(bit_vector::is_index_set(&bitvector, i), 0);
            bit_vector::shift_left(&mut bitvector, 1);
            assert!(!bit_vector::is_index_set(&bitvector,  i), 1);
            i = i - 1;
        };
    }

    #[test]
    fun test_shift_left_specific_amount() {
        let bitlen = 300;
        let shift_amount = 133;
        let bitvector = bit_vector::new(bitlen);

        bit_vector::set(&mut bitvector, 201);
        assert!(bit_vector::is_index_set(&bitvector, 201), 0);

        bit_vector::shift_left(&mut bitvector, shift_amount);
        assert!(bit_vector::is_index_set(&bitvector, 201 - shift_amount), 1);
        assert!(!bit_vector::is_index_set(&bitvector, 201), 2);

        // Make sure this shift clears all the bits
        bit_vector::shift_left(&mut bitvector, bitlen  - 1);

        let i = 0;
        while (i < bitlen) {
            assert!(!bit_vector::is_index_set(&bitvector, i), 3);
            i = i + 1;
        }
    }

    #[test]
    fun test_shift_left_specific_amount_to_unset_bit() {
        let bitlen = 50;
        let chosen_index = 24;
        let shift_amount = 3;
        let bitvector = bit_vector::new(bitlen);

        let i = 0;

        while (i < bitlen) {
            bit_vector::set(&mut bitvector, i);
            i = i + 1;
        };

        bit_vector::unset(&mut bitvector, chosen_index);
        assert!(!bit_vector::is_index_set(&bitvector, chosen_index), 0);

        bit_vector::shift_left(&mut bitvector, shift_amount);

        i = 0;

        while (i < bitlen) {
            // only chosen_index - shift_amount and the remaining bits should be BitVector::unset
            if ((i == chosen_index - shift_amount) || (i >= bitlen - shift_amount)) {
                assert!(!bit_vector::is_index_set(&bitvector, i), 1);
            } else {
                assert!(bit_vector::is_index_set(&bitvector, i), 2);
            };
            i = i + 1;
        }
    }

    #[test]
    fun shift_left_at_size() {
        let bitlen = 133;
        let bitvector = bit_vector::new(bitlen);

        let i = 0;
        while (i < bitlen) {
            bit_vector::set(&mut bitvector, i);
            i = i + 1;
        };

        bit_vector::shift_left(&mut bitvector, bitlen - 1);
        i = bitlen - 1;
        while (i > 0) {
            assert!(!bit_vector::is_index_set(&bitvector,  i), 1);
            i = i - 1;
        };
    }

    #[test]
    fun shift_left_more_than_size() {
        let bitlen = 133;
        let bitvector = bit_vector::new(bitlen);
        bit_vector::shift_left(&mut bitvector, bitlen);
    }

    #[test]
    #[expected_failure(abort_code = bit_vector::ELENGTH)]
    fun empty_bitvector() {
        bit_vector::new(0);
    }

    #[test]
    fun single_bit_bitvector() {
        let bitvector = bit_vector::new(1);
        assert!(bit_vector::length(&bitvector) == 1, 0);
    }
}


================================================
File: aptos-move/framework/move-stdlib/tests/fixedpoint32_tests.move
================================================
#[test_only]
module std::fixed_point32_tests {
    use std::fixed_point32;

    #[test]
    #[expected_failure(abort_code = fixed_point32::EDENOMINATOR)]
    fun create_div_zero() {
        // A denominator of zero should cause an arithmetic error.
        fixed_point32::create_from_rational(2, 0);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point32::ERATIO_OUT_OF_RANGE)]
    fun create_overflow() {
        // The maximum value is 2^32 - 1. Check that anything larger aborts
        // with an overflow.
        fixed_point32::create_from_rational(4294967296, 1); // 2^32
    }

    #[test]
    #[expected_failure(abort_code = fixed_point32::ERATIO_OUT_OF_RANGE)]
    fun create_underflow() {
        // The minimum non-zero value is 2^-32. Check that anything smaller
        // aborts.
        fixed_point32::create_from_rational(1, 8589934592); // 2^-33
    }

    #[test]
    fun create_zero() {
        let x = fixed_point32::create_from_rational(0, 1);
        assert!(fixed_point32::is_zero(x), 0);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point32::EDIVISION_BY_ZERO)]
    fun divide_by_zero() {
        // Dividing by zero should cause an arithmetic error.
        let f = fixed_point32::create_from_raw_value(0);
        fixed_point32::divide_u64(1, f);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point32::EDIVISION)]
    fun divide_overflow_small_divisore() {
        let f = fixed_point32::create_from_raw_value(1); // 0x0.00000001
        // Divide 2^32 by the minimum fractional value. This should overflow.
        fixed_point32::divide_u64(4294967296, f);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point32::EDIVISION)]
    fun divide_overflow_large_numerator() {
        let f = fixed_point32::create_from_rational(1, 2); // 0.5
        // Divide the maximum u64 value by 0.5. This should overflow.
        fixed_point32::divide_u64(18446744073709551615, f);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point32::EMULTIPLICATION)]
    fun multiply_overflow_small_multiplier() {
        let f = fixed_point32::create_from_rational(3, 2); // 1.5
        // Multiply the maximum u64 value by 1.5. This should overflow.
        fixed_point32::multiply_u64(18446744073709551615, f);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point32::EMULTIPLICATION)]
    fun multiply_overflow_large_multiplier() {
        let f = fixed_point32::create_from_raw_value(18446744073709551615);
        // Multiply 2^33 by the maximum fixed-point value. This should overflow.
        fixed_point32::multiply_u64(8589934592, f);
    }

    #[test]
    fun exact_multiply() {
        let f = fixed_point32::create_from_rational(3, 4); // 0.75
        let nine = fixed_point32::multiply_u64(12, f); // 12 * 0.75
        assert!(nine == 9, 0);
    }

    #[test]
    fun exact_divide() {
        let f = fixed_point32::create_from_rational(3, 4); // 0.75
        let twelve = fixed_point32::divide_u64(9, f); // 9 / 0.75
        assert!(twelve == 12, 0);
    }

    #[test]
    fun multiply_truncates() {
        let f = fixed_point32::create_from_rational(1, 3); // 0.333...
        let not_three = fixed_point32::multiply_u64(9, copy f); // 9 * 0.333...
        // multiply_u64 does NOT round -- it truncates -- so values that
        // are not perfectly representable in binary may be off by one.
        assert!(not_three == 2, 0);

        // Try again with a fraction slightly larger than 1/3.
        let f = fixed_point32::create_from_raw_value(fixed_point32::get_raw_value(f) + 1);
        let three = fixed_point32::multiply_u64(9, f);
        assert!(three == 3, 1);
    }

    #[test]
    fun create_from_rational_max_numerator_denominator() {
        // Test creating a 1.0 fraction from the maximum u64 value.
        let f = fixed_point32::create_from_rational(18446744073709551615, 18446744073709551615);
        let one = fixed_point32::get_raw_value(f);
        assert!(one == 4294967296, 0); // 0x1.00000000
    }

    #[test]
    fun min_can_return_smaller_fixed_point_number() {
        let one = fixed_point32::create_from_rational(1, 1);
        let two = fixed_point32::create_from_rational(2, 1);
        let smaller_number1 = fixed_point32::min(one, two);
        let val1 = fixed_point32::get_raw_value(smaller_number1);
        assert!(val1 == 4294967296, 0);  // 0x1.00000000
        let smaller_number2 = fixed_point32::min(two, one);
        let val2 = fixed_point32::get_raw_value(smaller_number2);
        assert!(val2 == 4294967296, 0);  // 0x1.00000000
    }

    #[test]
    fun max_can_return_larger_fixed_point_number() {
        let one = fixed_point32::create_from_rational(1, 1);
        let two = fixed_point32::create_from_rational(2, 1);
        let larger_number1 = fixed_point32::max(one, two);
        let larger_number2 = fixed_point32::max(two, one);
        let val1 = fixed_point32::get_raw_value(larger_number1);
        assert!(val1 == 8589934592, 0);  // 0x2.00000000
        let val2 = fixed_point32::get_raw_value(larger_number2);
        assert!(val2 == 8589934592, 0);  // 0x2.00000000
    }

    #[test]
    fun floor_can_return_the_correct_number_zero() {
        let point_five = fixed_point32::create_from_rational(1, 2);
        let val = fixed_point32::floor(point_five);
        assert!(val == 0, 0);
    }

    #[test]
    fun create_from_u64_create_correct_fixed_point_number() {
        let one = fixed_point32::create_from_u64(1);
        let val = fixed_point32::get_raw_value(one);
        assert!(val == 4294967296, 0);
    }

    #[test]
    #[expected_failure(abort_code = fixed_point32::ERATIO_OUT_OF_RANGE)]
    fun create_from_u64_throw_error_when_number_too_large() {
        fixed_point32::create_from_u64(4294967296); // (u64 >> 32) + 1
    }

    #[test]
    fun floor_can_return_the_correct_number_one() {
        let three_point_five = fixed_point32::create_from_rational(7, 2); // 3.5
        let val = fixed_point32::floor(three_point_five);
        assert!(val == 3, 0);
    }

    #[test]
    fun ceil_can_round_up_correctly() {
        let point_five = fixed_point32::create_from_rational(1, 2); // 0.5
        let val = fixed_point32::ceil(point_five);
        assert!(val == 1, 0);
    }

    #[test]
    fun ceil_will_not_change_if_number_already_integer() {
        let one = fixed_point32::create_from_rational(1, 1); // 0.5
        let val = fixed_point32::ceil(one);
        assert!(val == 1, 0);
    }

    #[test]
    fun round_can_round_up_correctly() {
        let point_five = fixed_point32::create_from_rational(1, 2); // 0.5
        let val = fixed_point32::round(point_five);
        assert!(val == 1, 0);
    }

    #[test]
    fun round_can_round_down_correctly() {
        let num = fixed_point32::create_from_rational(499, 1000); // 0.499
        let val = fixed_point32::round(num);
        assert!(val == 0, 0);
    }
}


================================================
File: aptos-move/framework/move-stdlib/tests/hash_tests.move
================================================
#[test_only]
module std::hash_tests {
    use std::hash;

    #[test]
    fun sha2_256_expected_hash() {
        let input = x"616263";
        let expected_output = x"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad";
        assert!(hash::sha2_256(input) == expected_output, 0);
    }

    #[test]
    fun sha3_256_expected_hash() {
        let input = x"616263";
        let expected_output = x"3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532";
        assert!(hash::sha3_256(input) == expected_output, 0);
    }
}


================================================
File: aptos-move/framework/move-stdlib/tests/option_tests.move
================================================
#[test_only]
module std::option_tests {
    use std::option;
    use std::vector;

    #[test]
    fun option_none_is_none() {
        let none = option::none<u64>();
        assert!(option::is_none(&none), 0);
        assert!(!option::is_some(&none), 1);
    }

    #[test]
    fun option_some_is_some() {
        let some = option::some(5);
        assert!(!option::is_none(&some), 0);
        assert!(option::is_some(&some), 1);
    }

    #[test]
    fun option_contains() {
        let none = option::none<u64>();
        let some = option::some(5);
        let some_other = option::some(6);
        assert!(option::contains(&some, &5), 0);
        assert!(option::contains(&some_other, &6), 1);
        assert!(!option::contains(&none, &5), 2);
        assert!(!option::contains(&some_other, &5), 3);
    }

    #[test]
    fun option_borrow_some() {
        let some = option::some(5);
        let some_other = option::some(6);
        assert!(*option::borrow(&some) == 5, 3);
        assert!(*option::borrow(&some_other) == 6, 4);
    }

    #[test]
    #[expected_failure(abort_code = option::EOPTION_NOT_SET)]
    fun option_borrow_none() {
        option::borrow(&option::none<u64>());
    }

    #[test]
    fun borrow_mut_some() {
        let some = option::some(1);
        let ref = option::borrow_mut(&mut some);
        *ref = 10;
        assert!(*option::borrow(&some) == 10, 0);
    }

    #[test]
    #[expected_failure(abort_code = option::EOPTION_NOT_SET)]
    fun borrow_mut_none() {
        option::borrow_mut(&mut option::none<u64>());
    }

    #[test]
    fun borrow_with_default() {
        let none = option::none<u64>();
        let some = option::some(5);
        assert!(*option::borrow_with_default(&some, &7) == 5, 0);
        assert!(*option::borrow_with_default(&none, &7) == 7, 1);
    }

    #[test]
    fun get_with_default() {
        let none = option::none<u64>();
        let some = option::some(5);
        assert!(option::get_with_default(&some, 7) == 5, 0);
        assert!(option::get_with_default(&none, 7) == 7, 1);
    }

    #[test]
    fun extract_some() {
        let opt = option::some(1);
        assert!(option::extract(&mut opt) == 1, 0);
        assert!(option::is_none(&opt), 1);
    }

    #[test]
    #[expected_failure(abort_code = option::EOPTION_NOT_SET)]
    fun extract_none() {
        option::extract(&mut option::none<u64>());
    }

    #[test]
    fun swap_some() {
        let some = option::some(5);
        assert!(option::swap(&mut some, 1) == 5, 0);
        assert!(*option::borrow(&some) == 1, 1);
    }

    #[test]
    fun swap_or_fill_some() {
        let some = option::some(5);
        assert!(option::swap_or_fill(&mut some, 1) == option::some(5), 0);
        assert!(*option::borrow(&some) == 1, 1);
    }

    #[test]
    fun swap_or_fill_none() {
        let none = option::none();
        assert!(option::swap_or_fill(&mut none, 1) == option::none(), 0);
        assert!(*option::borrow(&none) == 1, 1);
    }

    #[test]
    #[expected_failure(abort_code = option::EOPTION_NOT_SET)]
    fun swap_none() {
        option::swap(&mut option::none<u64>(), 1);
    }

    #[test]
    fun fill_none() {
        let none = option::none<u64>();
        option::fill(&mut none, 3);
        assert!(option::is_some(&none), 0);
        assert!(*option::borrow(&none) == 3, 1);
    }

    #[test]
    #[expected_failure(abort_code = option::EOPTION_IS_SET)]
    fun fill_some() {
        option::fill(&mut option::some(3), 0);
    }

    #[test]
    fun destroy_with_default() {
        assert!(option::destroy_with_default(option::none<u64>(), 4) == 4, 0);
        assert!(option::destroy_with_default(option::some(4), 5) == 4, 1);
    }

    #[test]
    fun destroy_some() {
        assert!(option::destroy_some(option::some(4)) == 4, 0);
    }

    #[test]
    #[expected_failure(abort_code = option::EOPTION_NOT_SET)]
    fun destroy_some_none() {
        option::destroy_some(option::none<u64>());
    }

    #[test]
    fun destroy_none() {
        option::destroy_none(option::none<u64>());
    }

    #[test]
    #[expected_failure(abort_code = option::EOPTION_IS_SET)]
    fun destroy_none_some() {
        option::destroy_none(option::some<u64>(0));
    }

    #[test]
    fun into_vec_some() {
        let v = option::to_vec(option::some<u64>(0));
        assert!(vector::length(&v) == 1, 0);
        let x = vector::pop_back(&mut v);
        assert!(x == 0, 1);
    }

    #[test]
    fun into_vec_none() {
        let v: vector<u64> = option::to_vec(option::none());
        assert!(vector::is_empty(&v), 0);
    }

    #[test]
    fun test_for_each() {
        let r = 0;
        option::for_each(option::some(1), |x| r = x);
        assert!(r == 1, 0);
        r = 0;
        option::for_each(option::none<u64>(), |x| r = x);
        assert!(r == 0, 1);
    }

    #[test]
    fun test_for_each_ref() {
        let r = 0;
        option::for_each_ref(&option::some(1), |x| r = *x);
        assert!(r == 1, 0);
        r = 0;
        option::for_each_ref(&option::none<u64>(), |x| r = *x);
        assert!(r == 0, 1);
    }

    #[test]
    fun test_for_each_mut() {
        let o = option::some(0);
        option::for_each_mut(&mut o, |x| *x = 1);
        assert!(o == option::some(1), 0);
    }

    #[test]
    fun test_fold() {
        let r = option::fold(option::some(1), 1, |a, b| a + b);
        assert!(r == 2, 0);
        let r = option::fold(option::none<u64>(), 1, |a, b| a + b);
        assert!(r == 1, 0);
    }

    #[test]
    fun test_map() {
        let x = option::map(option::some(1), |e| e + 1);
        assert!(option::extract(&mut x) == 2, 0);
    }

    #[test]
    fun test_map_ref() {
        let x = option::map_ref(&option::some(1), |e| *e + 1);
        assert!(option::extract(&mut x) == 2, 0);
    }

    #[test]
    fun test_filter() {
        let x = option::filter(option::some(1), |e| *e != 1);
        assert!(option::is_none(&x), 0);
    }

    #[test]
    fun test_any() {
        let r = option::any(&option::some(1), |e| *e == 1);
        assert!(r, 0);
    }


}


================================================
File: aptos-move/framework/move-stdlib/tests/string_tests.move
================================================
#[test_only]
module std::string_tests {
    use std::string;

    #[test]
    fun test_valid_utf8() {
        let sparkle_heart = vector[240, 159, 146, 150];
        let s = string::utf8(sparkle_heart);
        assert!(string::length(&s) == 4, 22);
    }

    #[test]
    #[expected_failure(abort_code = string::EINVALID_UTF8)]
    fun test_invalid_utf8() {
        let no_sparkle_heart = vector[0, 159, 146, 150];
        let s = string::utf8(no_sparkle_heart);
        assert!(string::length(&s) == 1, 22);
    }

    #[test]
    fun test_sub_string() {
        let s = string::utf8(b"abcd");
        let sub = string::sub_string(&s, 2, 4);
        assert!(sub == string::utf8(b"cd"), 22)
    }

    #[test]
    #[expected_failure(abort_code = string::EINVALID_INDEX)]
    fun test_sub_string_invalid_boundary() {
        let sparkle_heart = vector[240, 159, 146, 150];
        let s = string::utf8(sparkle_heart);
        let _sub = string::sub_string(&s, 1, 4);
    }

    #[test]
    #[expected_failure(abort_code = string::EINVALID_INDEX)]
    fun test_sub_string_invalid_index() {
        let s = string::utf8(b"abcd");
        let _sub = string::sub_string(&s, 4, 5);
    }

    #[test]
    fun test_sub_string_empty() {
        let s = string::utf8(b"abcd");
        let sub = string::sub_string(&s, 4, 4);
        assert!(string::is_empty(&sub), 22)
    }

    #[test]
    fun test_index_of() {
        let s = string::utf8(b"abcd");
        let r = string::utf8(b"bc");
        let p = string::index_of(&s, &r);
        assert!(p == 1, 22)
    }

    #[test]
    fun test_index_of_fail() {
        let s = string::utf8(b"abcd");
        let r = string::utf8(b"bce");
        let p = string::index_of(&s, &r);
        assert!(p == 4, 22)
    }

    #[test]
    fun test_append() {
        let s = string::utf8(b"abcd");
        string::append(&mut s, string::utf8(b"ef"));
        assert!(s == string::utf8(b"abcdef"), 22)
    }

    #[test]
    fun test_insert() {
        let s = string::utf8(b"abcd");
        string::insert(&mut s, 1, string::utf8(b"xy"));
        assert!(s == string::utf8(b"axybcd"), 22)
    }
}


================================================
File: aptos-move/framework/move-stdlib/tests/vector_tests.move
================================================
#[test_only]
module std::vector_tests {
    use std::vector as V;
    use std::vector;

    struct R has store { }
    struct Droppable has drop {}
    struct NotDroppable {}

    #[test]
    fun test_singleton_contains() {
        assert!(*V::borrow(&V::singleton(0), 0) == 0, 0);
        assert!(*V::borrow(&V::singleton(true), 0) == true, 0);
        assert!(*V::borrow(&V::singleton(@0x1), 0) == @0x1, 0);
    }

    #[test]
    fun test_singleton_len() {
        assert!(V::length(&V::singleton(0)) == 1, 0);
        assert!(V::length(&V::singleton(true)) == 1, 0);
        assert!(V::length(&V::singleton(@0x1)) == 1, 0);
    }

    #[test]
    fun test_empty_is_empty() {
        assert!(V::is_empty(&V::empty<u64>()), 0);
    }

    #[test]
    fun append_empties_is_empty() {
        let v1 = V::empty<u64>();
        let v2 = V::empty<u64>();
        V::append(&mut v1, v2);
        assert!(V::is_empty(&v1), 0);
    }

    #[test]
    fun append_respects_order_empty_lhs() {
        let v1 = V::empty();
        let v2 = V::empty();
        V::push_back(&mut v2, 0);
        V::push_back(&mut v2, 1);
        V::push_back(&mut v2, 2);
        V::push_back(&mut v2, 3);
        V::append(&mut v1, v2);
        assert!(!V::is_empty(&v1), 0);
        assert!(V::length(&v1) == 4, 1);
        assert!(*V::borrow(&v1, 0) == 0, 2);
        assert!(*V::borrow(&v1, 1) == 1, 3);
        assert!(*V::borrow(&v1, 2) == 2, 4);
        assert!(*V::borrow(&v1, 3) == 3, 5);
    }

    #[test]
    fun append_respects_order_empty_rhs() {
        let v1 = V::empty();
        let v2 = V::empty();
        V::push_back(&mut v1, 0);
        V::push_back(&mut v1, 1);
        V::push_back(&mut v1, 2);
        V::push_back(&mut v1, 3);
        V::append(&mut v1, v2);
        assert!(!V::is_empty(&v1), 0);
        assert!(V::length(&v1) == 4, 1);
        assert!(*V::borrow(&v1, 0) == 0, 2);
        assert!(*V::borrow(&v1, 1) == 1, 3);
        assert!(*V::borrow(&v1, 2) == 2, 4);
        assert!(*V::borrow(&v1, 3) == 3, 5);
    }

    #[test]
    fun append_respects_order_nonempty_rhs_lhs() {
        let v1 = V::empty();
        let v2 = V::empty();
        V::push_back(&mut v1, 0);
        V::push_back(&mut v1, 1);
        V::push_back(&mut v1, 2);
        V::push_back(&mut v1, 3);
        V::push_back(&mut v2, 4);
        V::push_back(&mut v2, 5);
        V::push_back(&mut v2, 6);
        V::push_back(&mut v2, 7);
        V::append(&mut v1, v2);
        assert!(!V::is_empty(&v1), 0);
        assert!(V::length(&v1) == 8, 1);
        let i = 0;
        while (i < 8) {
            assert!(*V::borrow(&v1, i) == i, i);
            i = i + 1;
        }
    }

    #[test]
    fun test_trim() {
        {
            let v = V::empty<u64>();
            assert!(&V::trim(&mut v, 0) == &vector[], 0);
        };
        {
            let v = vector[1];
            assert!(&V::trim(&mut v, 1) == &vector[], 1);
            assert!(&V::trim(&mut v, 0) == &vector[1], 2);
        };
        {
            let v = vector[1, 2];
            assert!(&V::trim(&mut v, 0) == &vector[1, 2], 3);
        };
    }
    #[test]
    #[expected_failure(abort_code = V::EINDEX_OUT_OF_BOUNDS)]
    fun test_trim_fail() {
        let v = vector[1];
        V::trim(&mut v, 2);
    }

    #[test]
    #[expected_failure(vector_error, minor_status = 1, location = Self)]
    fun borrow_out_of_range() {
        let v = V::empty();
        V::push_back(&mut v, 7);
        V::borrow(&v, 1);
    }

    #[test]
    fun vector_contains() {
        let vec = V::empty();
        assert!(!V::contains(&vec, &0), 1);

        V::push_back(&mut vec, 0);
        assert!(V::contains(&vec, &0), 2);
        assert!(!V::contains(&vec, &1), 3);

        V::push_back(&mut vec, 1);
        assert!(V::contains(&vec, &0), 4);
        assert!(V::contains(&vec, &1), 5);
        assert!(!V::contains(&vec, &2), 6);

        V::push_back(&mut vec, 2);
        assert!(V::contains(&vec, &0), 7);
        assert!(V::contains(&vec, &1), 8);
        assert!(V::contains(&vec, &2), 9);
        assert!(!V::contains(&vec, &3), 10);
    }

    #[test]
    fun destroy_empty() {
        V::destroy_empty(V::empty<u64>());
        V::destroy_empty(V::empty<R>());
    }

    #[test]
    fun destroy_empty_with_pops() {
        let v = V::empty();
        V::push_back(&mut v, 42);
        V::pop_back(&mut v);
        V::destroy_empty(v);
    }

    #[test]
    #[expected_failure(vector_error, minor_status = 3, location = Self)]
    fun destroy_non_empty() {
        let v = V::empty();
        V::push_back(&mut v, 42);
        V::destroy_empty(v);
    }

    #[test]
    fun get_set_work() {
        let vec = V::empty();
        V::push_back(&mut vec, 0);
        V::push_back(&mut vec, 1);
        assert!(*V::borrow(&vec, 1) == 1, 0);
        assert!(*V::borrow(&vec, 0) == 0, 1);

        *V::borrow_mut(&mut vec, 0) = 17;
        assert!(*V::borrow(&vec, 1) == 1, 0);
        assert!(*V::borrow(&vec, 0) == 17, 0);
    }

    #[test]
    #[expected_failure(vector_error, minor_status = 2, location = Self)]
    fun pop_out_of_range() {
        let v = V::empty<u64>();
        V::pop_back(&mut v);
    }

    #[test]
    fun swap_different_indices() {
        let vec = V::empty();
        V::push_back(&mut vec, 0);
        V::push_back(&mut vec, 1);
        V::push_back(&mut vec, 2);
        V::push_back(&mut vec, 3);
        V::swap(&mut vec, 0, 3);
        V::swap(&mut vec, 1, 2);
        assert!(*V::borrow(&vec, 0) == 3, 0);
        assert!(*V::borrow(&vec, 1) == 2, 0);
        assert!(*V::borrow(&vec, 2) == 1, 0);
        assert!(*V::borrow(&vec, 3) == 0, 0);
    }

    #[test]
    fun swap_same_index() {
        let vec = V::empty();
        V::push_back(&mut vec, 0);
        V::push_back(&mut vec, 1);
        V::push_back(&mut vec, 2);
        V::push_back(&mut vec, 3);
        V::swap(&mut vec, 1, 1);
        assert!(*V::borrow(&vec, 0) == 0, 0);
        assert!(*V::borrow(&vec, 1) == 1, 0);
        assert!(*V::borrow(&vec, 2) == 2, 0);
        assert!(*V::borrow(&vec, 3) == 3, 0);
    }

    #[test]
    fun remove_singleton_vector() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        assert!(V::remove(&mut v, 0) == 0, 0);
        assert!(V::length(&v) == 0, 0);
    }

    #[test]
    fun remove_nonsingleton_vector() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);

        assert!(V::remove(&mut v, 1) == 1, 0);
        assert!(V::length(&v) == 3, 0);
        assert!(*V::borrow(&v, 0) == 0, 0);
        assert!(*V::borrow(&v, 1) == 2, 0);
        assert!(*V::borrow(&v, 2) == 3, 0);
    }

    #[test]
    fun remove_nonsingleton_vector_last_elem() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);

        assert!(V::remove(&mut v, 3) == 3, 0);
        assert!(V::length(&v) == 3, 0);
        assert!(*V::borrow(&v, 0) == 0, 0);
        assert!(*V::borrow(&v, 1) == 1, 0);
        assert!(*V::borrow(&v, 2) == 2, 0);
    }

    #[test]
    #[expected_failure(abort_code = V::EINDEX_OUT_OF_BOUNDS)]
    fun remove_empty_vector() {
        let v = V::empty<u64>();
        V::remove(&mut v, 0);
    }

    #[test]
    #[expected_failure(abort_code = V::EINDEX_OUT_OF_BOUNDS)]
    fun remove_out_of_bound_index() {
        let v = V::empty<u64>();
        V::push_back(&mut v, 0);
        V::remove(&mut v, 1);
    }

    #[test]
    fun remove_value_singleton_vector() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        assert!(V::borrow(&V::remove_value(&mut v, &0), 0) == &0, 0);
        assert!(V::length(&v) == 0, 0);
    }

    #[test]
    fun remove_value_nonsingleton_vector() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);

        assert!(V::borrow(&V::remove_value(&mut v, &2), 0) == &2, 0);
        assert!(V::length(&v) == 3, 0);
        assert!(*V::borrow(&v, 0) == 0, 0);
        assert!(*V::borrow(&v, 1) == 1, 0);
        assert!(*V::borrow(&v, 2) == 3, 0);
    }

    #[test]
    fun remove_value_nonsingleton_vector_last_elem() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);

        assert!(V::borrow(&V::remove_value(&mut v, &3), 0) == &3, 0);
        assert!(V::length(&v) == 3, 0);
        assert!(*V::borrow(&v, 0) == 0, 0);
        assert!(*V::borrow(&v, 1) == 1, 0);
        assert!(*V::borrow(&v, 2) == 2, 0);
    }

    #[test]
    fun remove_value_empty_vector() {
        let v = V::empty<u64>();
        assert!(V::length(&V::remove_value(&mut v, &1)) == 0, 0);
        assert!(V::length(&v) == 0, 1);
    }

    #[test]
    fun remove_value_nonexistent() {
        let v = V::empty<u64>();
        V::push_back(&mut v, 0);
        assert!(V::length(&V::remove_value(&mut v, &1)) == 0, 0);
        assert!(V::length(&v) == 1, 1);
    }

    #[test]
    fun reverse_vector_empty() {
        let v = V::empty<u64>();
        let is_empty = V::is_empty(&v);
        V::reverse(&mut v);
        assert!(is_empty == V::is_empty(&v), 0);
    }

    #[test]
    fun reverse_singleton_vector() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        assert!(*V::borrow(&v, 0) == 0, 1);
        V::reverse(&mut v);
        assert!(*V::borrow(&v, 0) == 0, 2);
    }

    #[test]
    fun reverse_vector_nonempty_even_length() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);

        assert!(*V::borrow(&v, 0) == 0, 1);
        assert!(*V::borrow(&v, 1) == 1, 2);
        assert!(*V::borrow(&v, 2) == 2, 3);
        assert!(*V::borrow(&v, 3) == 3, 4);

        V::reverse(&mut v);

        assert!(*V::borrow(&v, 3) == 0, 5);
        assert!(*V::borrow(&v, 2) == 1, 6);
        assert!(*V::borrow(&v, 1) == 2, 7);
        assert!(*V::borrow(&v, 0) == 3, 8);
    }

    #[test]
    fun reverse_vector_nonempty_odd_length_non_singleton() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);

        assert!(*V::borrow(&v, 0) == 0, 1);
        assert!(*V::borrow(&v, 1) == 1, 2);
        assert!(*V::borrow(&v, 2) == 2, 3);

        V::reverse(&mut v);

        assert!(*V::borrow(&v, 2) == 0, 4);
        assert!(*V::borrow(&v, 1) == 1, 5);
        assert!(*V::borrow(&v, 0) == 2, 6);
    }

    #[test]
    #[expected_failure(vector_error, minor_status = 1, location = Self)]
    fun swap_empty() {
        let v = V::empty<u64>();
        V::swap(&mut v, 0, 0);
    }

    #[test]
    #[expected_failure(vector_error, minor_status = 1, location = Self)]
    fun swap_out_of_range() {
        let v = V::empty<u64>();

        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);

        V::swap(&mut v, 1, 10);
    }

    #[test]
    #[expected_failure(abort_code = V::EINDEX_OUT_OF_BOUNDS)]
    fun swap_remove_empty() {
        let v = V::empty<u64>();
        V::swap_remove(&mut v, 0);
    }

    #[test]
    fun swap_remove_singleton() {
        let v = V::empty<u64>();
        V::push_back(&mut v, 0);
        assert!(V::swap_remove(&mut v, 0) == 0, 0);
        assert!(V::is_empty(&v), 1);
    }

    #[test]
    fun swap_remove_inside_vector() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);

        assert!(*V::borrow(&v, 0) == 0, 1);
        assert!(*V::borrow(&v, 1) == 1, 2);
        assert!(*V::borrow(&v, 2) == 2, 3);
        assert!(*V::borrow(&v, 3) == 3, 4);

        assert!(V::swap_remove(&mut v, 1) == 1, 5);
        assert!(V::length(&v) == 3, 6);

        assert!(*V::borrow(&v, 0) == 0, 7);
        assert!(*V::borrow(&v, 1) == 3, 8);
        assert!(*V::borrow(&v, 2) == 2, 9);

    }

    #[test]
    fun swap_remove_end_of_vector() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);

        assert!(*V::borrow(&v, 0) == 0, 1);
        assert!(*V::borrow(&v, 1) == 1, 2);
        assert!(*V::borrow(&v, 2) == 2, 3);
        assert!(*V::borrow(&v, 3) == 3, 4);

        assert!(V::swap_remove(&mut v, 3) == 3, 5);
        assert!(V::length(&v) == 3, 6);

        assert!(*V::borrow(&v, 0) == 0, 7);
        assert!(*V::borrow(&v, 1) == 1, 8);
        assert!(*V::borrow(&v, 2) == 2, 9);
    }

    #[test]
    #[expected_failure(vector_error, minor_status = 1, location = std::vector)]
    fun swap_remove_out_of_range() {
        let v = V::empty();
        V::push_back(&mut v, 0);
        V::swap_remove(&mut v, 1);
    }

    #[test]
    fun push_back_and_borrow() {
        let v = V::empty();
        V::push_back(&mut v, 7);
        assert!(!V::is_empty(&v), 0);
        assert!(V::length(&v) == 1, 1);
        assert!(*V::borrow(&v, 0) == 7, 2);

        V::push_back(&mut v, 8);
        assert!(V::length(&v) == 2, 3);
        assert!(*V::borrow(&v, 0) == 7, 4);
        assert!(*V::borrow(&v, 1) == 8, 5);
    }

    #[test]
    fun index_of_empty_not_has() {
        let v = V::empty();
        let (has, index) = V::index_of(&v, &true);
        assert!(!has, 0);
        assert!(index == 0, 1);
    }

    #[test]
    fun index_of_nonempty_not_has() {
        let v = V::empty();
        V::push_back(&mut v, false);
        let (has, index) = V::index_of(&v, &true);
        assert!(!has, 0);
        assert!(index == 0, 1);
    }

    #[test]
    fun index_of_nonempty_has() {
        let v = V::empty();
        V::push_back(&mut v, false);
        V::push_back(&mut v, true);
        let (has, index) = V::index_of(&v, &true);
        assert!(has, 0);
        assert!(index == 1, 1);
    }

    // index_of will return the index first occurence that is equal
    #[test]
    fun index_of_nonempty_has_multiple_occurences() {
        let v = V::empty();
        V::push_back(&mut v, false);
        V::push_back(&mut v, true);
        V::push_back(&mut v, true);
        let (has, index) = V::index_of(&v, &true);
        assert!(has, 0);
        assert!(index == 1, 1);
    }

    #[test]
    fun find_empty_not_has() {
        let v = V::empty<u64>();
        let (has, index) = V::find(&v, |_x| true);
        assert!(!has, 0);
        assert!(index == 0, 1);
    }

    #[test]
    fun find_nonempty_not_has() {
        let v = V::empty();
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        let (has, index) = V::find(&v, |x| *x == 3);
        assert!(!has, 0);
        assert!(index == 0, 1);
    }

    #[test]
    fun find_nonempty_has() {
        let v = V::empty();
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);
        let (has, index) = V::find(&v, |x| *x == 2);
        assert!(has, 0);
        assert!(index == 1, 1);
    }

    #[test]
    fun find_nonempty_has_multiple_occurences() {
        let v = V::empty();
        V::push_back(&mut v, 1);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 2);
        V::push_back(&mut v, 3);
        let (has, index) = V::find(&v, |x| *x == 2);
        assert!(has, 0);
        assert!(index == 1, 1);
    }

    #[test]
    fun length() {
        let empty = V::empty();
        assert!(V::length(&empty) == 0, 0);
        let i = 0;
        let max_len = 42;
        while (i < max_len) {
            V::push_back(&mut empty, i);
            assert!(V::length(&empty) == i + 1, i);
            i = i + 1;
        }
    }

    #[test]
    fun pop_push_back() {
        let v = V::empty();
        let i = 0;
        let max_len = 42;

        while (i < max_len) {
            V::push_back(&mut v, i);
            i = i + 1;
        };

        while (i > 0) {
            assert!(V::pop_back(&mut v) == i - 1, i);
            i = i - 1;
        };
    }

    #[test_only]
    fun test_natives_with_type<T>(x1: T, x2: T): (T, T) {
        let v = V::empty();
        assert!(V::length(&v) == 0, 0);
        V::push_back(&mut v, x1);
        assert!(V::length(&v) == 1, 1);
        V::push_back(&mut v, x2);
        assert!(V::length(&v) == 2, 2);
        V::swap(&mut v, 0, 1);
        x1 = V::pop_back(&mut v);
        assert!(V::length(&v) == 1, 3);
        x2 = V::pop_back(&mut v);
        assert!(V::length(&v) == 0, 4);
        V::destroy_empty(v);
        (x1, x2)
    }

    #[test]
    fun test_natives_with_different_instantiations() {
        test_natives_with_type<u8>(1u8, 2u8);
        test_natives_with_type<u64>(1u64, 2u64);
        test_natives_with_type<u128>(1u128, 2u128);
        test_natives_with_type<bool>(true, false);
        test_natives_with_type<address>(@0x1, @0x2);

        test_natives_with_type<vector<u8>>(V::empty(), V::empty());

        test_natives_with_type<Droppable>(Droppable{}, Droppable{});
        (NotDroppable {}, NotDroppable {}) = test_natives_with_type<NotDroppable>(
            NotDroppable {},
            NotDroppable {}
        );
    }

    #[test]
    fun test_for_each() {
        let v = vector[1, 2, 3];
        let s = 0;
        V::for_each(v, |e| {
            s = s + e;
        });
        assert!(s == 6, 0)
    }

    #[test]
    fun test_zip() {
        let v1 = vector[1, 2, 3];
        let v2 = vector[10, 20, 30];
        let s = 0;
        V::zip(v1, v2, |e1, e2| s = s + e1 * e2);
        assert!(s == 140, 0);
    }

    #[test]
    // zip is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::EVECTORS_LENGTH_MISMATCH, location = Self)]
    fun test_zip_mismatching_lengths_should_fail() {
        let v1 = vector[1];
        let v2 = vector[10, 20];
        let s = 0;
        V::zip(v1, v2, |e1, e2| s = s + e1 * e2);
    }

    #[test]
    fun test_enumerate_ref() {
        let v = vector[1, 2, 3];
        let i_s = 0;
        let s = 0;
        V::enumerate_ref(&v, |i, e| {
            i_s = i_s + i;
            s = s + *e;
        });
        assert!(i_s == 3, 0);
        assert!(s == 6, 0);
    }

    #[test]
    fun test_for_each_ref() {
        let v = vector[1, 2, 3];
        let s = 0;
        V::for_each_ref(&v, |e| s = s + *e);
        assert!(s == 6, 0)
    }

    #[test]
    fun test_for_each_mut() {
        let v = vector[1, 2, 3];
        let s = 2;
        V::for_each_mut(&mut v, |e| { *e = s; s = s + 1 });
        assert!(v == vector[2, 3, 4], 0)
    }

    #[test]
    fun test_zip_ref() {
        let v1 = vector[1, 2, 3];
        let v2 = vector[10, 20, 30];
        let s = 0;
        V::zip_ref(&v1, &v2, |e1, e2| s = s + *e1 * *e2);
        assert!(s == 140, 0);
    }

    #[test]
    // zip_ref is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::EVECTORS_LENGTH_MISMATCH, location = Self)]
    fun test_zip_ref_mismatching_lengths_should_fail() {
        let v1 = vector[1];
        let v2 = vector[10, 20];
        let s = 0;
        V::zip_ref(&v1, &v2, |e1, e2| s = s + *e1 * *e2);
    }

    #[test]
    fun test_zip_mut() {
        let v1 = vector[1, 2, 3];
        let v2 = vector[10, 20, 30];
        V::zip_mut(&mut v1, &mut v2, |e1, e2| {
            let e1: &mut u64 = e1;
            let e2: &mut u64 = e2;
            *e1 = *e1 + 1;
            *e2 = *e2 + 10;
        });
        assert!(v1 == vector[2, 3, 4], 0);
        assert!(v2 == vector[20, 30, 40], 0);
    }

    #[test]
    fun test_zip_map() {
        let v1 = vector[1, 2, 3];
        let v2 = vector[10, 20, 30];
        let result = V::zip_map(v1, v2, |e1, e2| e1 + e2);
        assert!(result == vector[11, 22, 33], 0);
    }

    #[test]
    fun test_zip_map_ref() {
        let v1 = vector[1, 2, 3];
        let v2 = vector[10, 20, 30];
        let result = V::zip_map_ref(&v1, &v2, |e1, e2| *e1 + *e2);
        assert!(result == vector[11, 22, 33], 0);
    }

    #[test]
    // zip_mut is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::EVECTORS_LENGTH_MISMATCH, location = Self)]
    fun test_zip_mut_mismatching_lengths_should_fail() {
        let v1 = vector[1];
        let v2 = vector[10, 20];
        let s = 0;
        V::zip_mut(&mut v1, &mut v2, |e1, e2| s = s + *e1 * *e2);
    }

    #[test]
    // zip_map is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::EVECTORS_LENGTH_MISMATCH, location = Self)]
    fun test_zip_map_mismatching_lengths_should_fail() {
        let v1 = vector[1];
        let v2 = vector[10, 20];
        V::zip_map(v1, v2, |e1, e2| e1 * e2);
    }

    #[test]
    // zip_map_ref is an inline function so any error code will be reported at the call site.
    #[expected_failure(abort_code = V::EVECTORS_LENGTH_MISMATCH, location = Self)]
    fun test_zip_map_ref_mismatching_lengths_should_fail() {
        let v1 = vector[1];
        let v2 = vector[10, 20];
        V::zip_map_ref(&v1, &v2, |e1, e2| *e1 * *e2);
    }

    #[test]
    fun test_enumerate_mut() {
        let v = vector[1, 2, 3];
        let i_s = 0;
        let s = 2;
        V::enumerate_mut(&mut v, |i, e| {
            i_s = i_s + i;
            *e = s;
            s = s + 1
        });
        assert!(i_s == 3, 0);
        assert!(v == vector[2, 3, 4], 0);
    }

    #[test]
    fun test_fold() {
        let v = vector[1, 2, 3];
        let s = V::fold(v, 0, |r, e| r + e);
        assert!(s == 6 , 0)
    }

    #[test]
    fun test_foldr() {
        // use non-commutative minus operation to test the difference between fold and foldr
        {
            let v = vector[3, 2, 1];
            // ((100 - 3) - 2) - 1 = 94
            let s = V::fold(v, 100, |l, r| l - r);
            assert!(s == 94, 0)
        };
        {
            let v = vector[3, 2, 1];
            // 3 - (2 - (1 - 0)) = 2
            let s = V::foldr(v, 0, |l, r| l - r);
            assert!(s == 2, 1)
        }
    }

    #[test]
    fun test_map() {
        let v = vector[1, 2, 3];
        let s = V::map(v, |x| x + 1);
        assert!(s == vector[2, 3, 4] , 0)
    }

    #[test]
    fun test_map_ref() {
        let v = vector[1, 2, 3];
        let s = V::map_ref(&v, |x| *x + 1);
        assert!(s == vector[2, 3, 4] , 0)
    }

    #[test]
    fun test_filter() {
        let v = vector[1, 2, 3];
        let s = V::filter(v, |x| *x % 2 == 0);
        assert!(s == vector[2] , 0)
    }

    #[test]
    fun test_any() {
        let v = vector[1, 2, 3];
        let r = V::any(&v, |x| *x > 2);
        assert!(r, 0)
    }

    #[test]
    fun test_all() {
        let v = vector[1, 2, 3];
        let r = V::all(&v, |x| *x >= 1);
        assert!(r, 0)
    }

    #[test]
    fun test_rotate() {
        let v = vector[1, 2, 3, 4, 5];
        assert!(vector::rotate(&mut v, 2) == 3, 0);
        assert!(&v == &vector[3, 4, 5, 1, 2], 1);

        assert!(vector::rotate_slice(&mut v, 1, 2, 5) == 4, 2);
        assert!(&v == &vector[3, 5, 1, 2, 4], 3);

        assert!(vector::rotate_slice(&mut v, 0, 0, 5) == 5, 2);
        assert!(&v == &vector[3, 5, 1, 2, 4], 3);
        assert!(vector::rotate_slice(&mut v, 0, 5, 5) == 0, 2);
        assert!(&v == &vector[3, 5, 1, 2, 4], 3);
    }

    #[test]
    fun test_partition() {
        let v = vector[1, 2, 3, 4, 5];
        assert!(vector::partition(&mut v, |n| *n % 2 == 0) == 2, 0);
        assert!(&v == &vector[2, 4, 3, 1, 5], 1);

        assert!(vector::partition(&mut v, |_n| false) == 0, 0);
        assert!(&v == &vector[2, 4, 3, 1, 5], 1);

        assert!(vector::partition(&mut v, |_n| true) == 5, 0);
        assert!(&v == &vector[2, 4, 3, 1, 5], 1);
    }

    #[test]
    fun test_stable_partition() {
        let v:vector<u64> = vector[1, 2, 3, 4, 5];

        assert!(vector::stable_partition(&mut v, |n| *n % 2 == 0) == 2, 0);
        assert!(&v == &vector[2, 4, 1, 3, 5], 1);

        assert!(vector::partition(&mut v, |_n| false) == 0, 0);
        assert!(&v == &vector[2, 4, 1, 3, 5], 1);

        assert!(vector::partition(&mut v, |_n| true) == 5, 0);
        assert!(&v == &vector[2, 4, 1, 3, 5], 1);
    }

    #[test]
    fun test_insert() {
        let v:vector<u64> = vector[1, 2, 3, 4, 5];

        vector::insert(&mut v,2, 6);
        assert!(&v == &vector[1, 2, 6, 3, 4, 5], 1);

        vector::insert(&mut v,6, 7);
        assert!(&v == &vector[1, 2, 6, 3, 4, 5, 7], 1);
    }

    #[test]
    #[expected_failure(abort_code = V::EINDEX_OUT_OF_BOUNDS)]
    fun test_insert_out_of_bounds() {
        let v:vector<u64> = vector[1, 2, 3, 4, 5];

        vector::insert(&mut v,6, 6);
    }

    #[test]
    fun test_range() {
        let result = vector::range(5, 10);
        assert!(result == vector[5, 6, 7, 8, 9], 1);
    }

    #[test]
    fun test_range_with_step() {
        let result = vector::range_with_step(0, 10, 2);
        assert!(result == vector[0, 2, 4, 6, 8], 1);

        let empty_result = vector::range_with_step(10, 10, 2);
        assert!(empty_result == vector[], 1);

        // Test with `start` greater than `end`
        let reverse_result = vector::range_with_step(10, 0, 2);
        assert!(reverse_result == vector[], 1);
    }

    #[test]
    #[expected_failure(abort_code = V::EINVALID_STEP)]
    fun test_range_with_invalid_step() {
        vector::range_with_step(0, 10, 0);
    }

    #[test]
    fun test_slice() {
        let v = &vector[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

        let slice_beginning = vector::slice(v, 0, 3);
        assert!(slice_beginning == vector[0, 1, 2], 1);

        let slice_end = vector::slice(v, 7, 10);
        assert!(slice_end == vector[7, 8, 9], 1);

        let empty_slice = vector::slice(v, 5, 5);
        assert!(empty_slice == vector[], 1);
        let empty_slice = vector::slice(v, 0, 0);
        assert!(empty_slice == vector[], 1);

        let full_slice = &vector::slice(v, 0, 10);
        assert!(full_slice == v, 1);
    }

    #[test]
    #[expected_failure(abort_code = V::EINVALID_SLICE_RANGE)]
    fun test_slice_invalid_range() {
        let v = &vector[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        vector::slice(v, 7, 6); // start is greater than end
    }

    #[test]
    #[expected_failure(abort_code = V::EINVALID_SLICE_RANGE)]
    fun test_slice_out_of_bounds() {
        let v = &vector[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        vector::slice(v, 0, 11); // end is out of bounds
    }

    #[test_only]
    struct MoveOnly {}

    #[test]
    fun test_destroy() {
        let v = vector[MoveOnly {}];
        vector::destroy(v, |m| { let MoveOnly {} = m; })
    }
}


